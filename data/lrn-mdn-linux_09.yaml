- en: Chapter 9\. Advanced Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 高级主题
- en: This final chapter is a bit of a mixed bag. We cover a range of topics, from
    virtual machines to security to new ways to use Linux. What the topics in this
    chapter have in common is that most of them are relevant for you only if you have
    a specific use case in mind, or if you require them in a professional setup.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这章节是一个综合性的章节。我们涵盖了从虚拟机到安全性再到新的Linux使用方式等多个主题。这章节的共同点是，如果你有特定的用例，或者在专业设置中需要它们，这些主题对你来说大多是相关的。
- en: 'We start off the chapter with how processes on a single machine can communicate
    and share data. There is a wealth of interprocess communication (IPC) mechanisms
    available, and here we focus on well-established and -used features: signals,
    named pipes, and Unix domain sockets.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从单台机器上的进程如何通信和共享数据开始这一章节。有丰富的进程间通信（IPC）机制可用，在这里我们专注于成熟和广泛使用的特性：信号，命名管道和Unix域套接字。
- en: Then, we look at virtual machines (VMs). In contrast to the containers we discussed
    in [“Containers”](ch06.xhtml#containers) (which are good for application-level
    dependency management), VMs provide strong isolation for your workloads. You come
    across VMs most often in the context of the public cloud and in the general case
    in data centers. Having said that, using VMs locally can also be useful, such
    as for testing or to simulate distributed systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看看虚拟机（VM）。与我们在[“容器”](ch06.xhtml#containers)中讨论过的容器相比（适用于应用程序级别的依赖管理），VM为您的工作负载提供了强大的隔离。您在公共云环境和数据中心中经常会遇到VM，使用VM在本地也非常有用，例如用于测试或模拟分布式系统。
- en: The next section in this chapter focuses on modern Linux distributions, which
    are usually container-centric and assume immutability. You’ll often find said
    distros in the context of distributed systems such as Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一节重点介绍现代Linux发行版，这些发行版通常以容器为中心，并假定为不可变状态。您经常会在像Kubernetes这样的分布式系统环境中找到这些发行版。
- en: We then move on to selected security topics, covering Kerberos, a widely used
    authentication suite, and pluggable authentication modules (PAM), an extension
    mechanism Linux provides for authentication.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们转向选定的安全主题，涵盖了Kerberos，一个广泛使用的身份验证套件，以及可插入认证模块（PAM），这是Linux提供的用于身份验证的扩展机制。
- en: In the last part of this chapter, we review Linux solutions and use cases that,
    at the time of writing, are not yet mainstream. But they could be relevant to
    you and are worth exploring.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们回顾了Linux的解决方案和使用案例，这些在撰写时尚未成为主流，但它们可能对您有用，值得探索。
- en: Interprocess Communication
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程间通信
- en: In Linux there is a long list of [interprocess communication (IPC)](https://oreil.ly/tWp40)
    options available, ranging from pipes to sockets to shared memory. IPC enables
    processes to communicate, synchronize activities, and share data. For example,
    the [Docker daemon](https://oreil.ly/aZur8) uses configurable sockets to manage
    containers. In this section, we review some popular IPC options and their use
    cases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，有许多[进程间通信（IPC）](https://oreil.ly/tWp40)选项可供选择，从管道到套接字再到共享内存。IPC使进程能够通信，同步活动并共享数据。例如，[Docker守护程序](https://oreil.ly/aZur8)使用可配置的套接字来管理容器。在本节中，我们回顾了一些流行的IPC选项及其使用案例。
- en: Signals
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: '[*Signals*](https://oreil.ly/0y6ru) were originally developed as a way for
    the kernel to notify user space processes about a certain event. Think of signals
    as an asynchronous notification sent to a process. There are many signals available
    (use the `man 7 signal` command to learn more), and most of them come with a default
    action, such as stop or terminate the process.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[*信号*](https://oreil.ly/0y6ru)最初开发用作内核向用户空间进程通知某些事件的一种方式。将信号视为发送给进程的异步通知。有许多可用的信号（使用`man
    7 signal`命令了解更多），其中大多数都有默认动作，例如停止或终止进程。'
- en: With most signals, you define a custom handler, rather than letting Linux carry
    on with the default action. This is useful when you want to, for example, do some
    clean-up work or simply ignore certain signals. [Table 9-1](#tab-signals) shows
    the most common signals that you should be familiar with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数信号都可以定义自定义处理程序，而不是让Linux继续执行默认动作。当您想要做一些清理工作或简单地忽略某些信号时，这非常有用。[表格 9-1](#tab-signals)展示了您应该熟悉的最常见信号。
- en: Table 9-1\. Common signals
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1. 常见信号
- en: '| Signal | Meaning | Default action | Handle option | Key combination |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 信号 | 含义 | 默认动作 | 处理选项 | 快捷键组合 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `SIGHUP` | Tell a daemon process to reread its config file | Terminate process
    | `nohup` or custom handler | N/A |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `SIGHUP` | 告诉守护进程重新读取其配置文件 | 终止进程 | `nohup`或自定义处理器 | N/A |'
- en: '| `SIGINT` | User interruption from keyboard | Terminate process | Custom handler
    | Ctrl+C |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `SIGINT` | 用户通过键盘中断 | 终止进程 | 自定义处理器 | Ctrl+C |'
- en: '| `SIGQUIT` | User quit from keyboard | [core dump](https://oreil.ly/jeuEo)
    and terminate process | Custom handler | Ctrl+\ |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `SIGQUIT` | 用户通过键盘退出 | [核心转储](https://oreil.ly/jeuEo)并终止进程 | 自定义处理器 | Ctrl+\
    |'
- en: '| `SIGKILL` | Kill signal | Terminate process | Cannot be handled | N/A |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `SIGKILL` | 强制终止信号 | 终止进程 | 无法处理 | N/A |'
- en: '| `SIGSTOP` | Stop process | Stop process | Cannot be handled | N/A |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSTOP` | 停止进程 | 停止进程 | 无法处理 | N/A |'
- en: '| `SIGTSTP` | User caused stop from keyboard | Stop process | Custom handler
    | Ctrl+Z |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTSTP` | 用户通过键盘停止 | 停止进程 | 自定义处理器 | Ctrl+Z |'
- en: '| `SIGTERM` | Graceful termination | Terminate process | Custom handler | N/A
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTERM` | 优雅终止 | 终止进程 | 自定义处理器 | N/A |'
- en: There are also signals that don’t have defined meanings (`SIGUSR1` and `SIGUSR2`)
    that processes can use to communicate with each other, sending asynchronous notification,
    if both parties agree on the semantics of the signal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些没有定义含义的信号（`SIGUSR1`和`SIGUSR2`），进程可以使用它们来相互通信，发送异步通知，前提是双方同意信号的语义。
- en: 'One typical way to send a signal to a process is the somewhat strangely named
    `kill` command (due to its default behavior to cause processes to terminate):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 发送信号给进程的一个典型方式是有些奇怪命名的`kill`命令（由于其默认行为是导致进程终止）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_advanced_topics_CO1-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_topics_CO1-1)'
- en: We set up a very simple program here that simply sleeps. With `&`, we put it
    into the background.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里设置了一个非常简单的程序，只是简单地休眠。用`&`将其放到后台运行。
- en: '[![2](Images/2.png)](#co_advanced_topics_CO1-2)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_topics_CO1-2)'
- en: The shell job control confirms that our program runs as a job with ID 1 in the
    background and reports its PID (`17030`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: shell作业控制确认我们的程序作为后台作业运行，并报告其PID（`17030`）。
- en: '[![3](Images/3.png)](#co_advanced_topics_CO1-3)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_topics_CO1-3)'
- en: Using `ps`, we check if the program is still running.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps`，我们检查程序是否仍在运行。
- en: '[![4](Images/4.png)](#co_advanced_topics_CO1-4)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_advanced_topics_CO1-4)'
- en: Here is our program (compare PID).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的程序（比较PID）。
- en: '[![5](Images/5.png)](#co_advanced_topics_CO1-5)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_advanced_topics_CO1-5)'
- en: By default, `kill` sends the `SIGTERM` to the process, and the default action
    is to terminate the process gracefully. We provide `kill` with the PID of our
    process (`17030`), and since we didn’t register a custom handler, it is terminated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`kill`发送`SIGTERM`信号给进程，而默认动作是优雅地终止进程。我们提供`kill`命令与我们进程的PID（`17030`），由于我们没有注册自定义处理程序，它被终止。
- en: 'Now we’ll look at how to handle a signal with [`trap`](https://oreil.ly/pp6O4).
    This allows us to define a custom handler in a shell environment (command line
    or script):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用[`trap`](https://oreil.ly/pp6O4)处理信号。这允许我们在shell环境（命令行或脚本）中定义一个自定义处理器：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_advanced_topics_CO2-1)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_topics_CO2-1)'
- en: With `trap "echo kthxbye" SIGINT`, we register a handler, telling Linux that
    when the user presses Ctrl+C (causing a `SIGINT` signal to be sent to our process),
    Linux should execute `echo kthxbye` before the default action (terminate).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`trap "echo kthxbye" SIGINT`，我们注册一个处理程序，告诉Linux当用户按下Ctrl+C时（导致`SIGINT`信号发送到我们的进程），Linux应该在默认动作（终止）之前执行`echo
    kthxbye`。
- en: '[![2](Images/2.png)](#co_advanced_topics_CO2-2)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_topics_CO2-2)'
- en: We see the user interruption (`^C` is the same as Ctrl+C) and then our custom
    handler getting executed, printing `kthxbye`, as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到用户中断（`^C`等同于Ctrl+C），然后我们的自定义处理程序执行，如预期地打印`kthxbye`。
- en: Signals are a simple yet powerful IPC mechanism, and now you know the basics
    of how to send and handle signals in Linux. Next up, we discuss two more elaborate
    and powerful IPC mechanisms—named pipes and UNIX domain sockets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一种简单而强大的IPC机制，现在您已经了解了如何在Linux中发送和处理信号的基础知识。接下来，我们讨论两种更为复杂和强大的IPC机制——命名管道和UNIX域套接字。
- en: Named Pipes
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名管道
- en: In [“Streams”](ch03.xhtml#shell-streams), we talked about pipes (`|`) that you
    can use to pass data from one process to another by connecting the `stdout` of
    one process with `stdin` of another process. We call these pipes *unnamed*. Taking
    this idea a step further, [named pipes](https://oreil.ly/iHMrK) are pipes to which
    you can assign custom names.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“流”](ch03.xhtml#shell-streams)中，我们讨论了通过使用管道符（`|`）可以将数据从一个进程传递到另一个进程，方法是将一个进程的`stdout`与另一个进程的`stdin`连接起来。我们称这些管道为*未命名*管道。进一步延伸这个想法，[命名管道](https://oreil.ly/iHMrK)是可以分配自定义名称的管道。
- en: Just like unnamed pipes, named pipes work with normal file I/O (`open`, `write`,
    etc.) and provide first in, first out (FIFO) delivery. Unlike unnamed pipes, the
    lifetime of a named pipe is not limited to the processes it’s used with. Technically,
    named pipes are a wrapper around pipes, using the `pipefs` pseudo filesystem (see
    [“Pseudo Filesystems”](ch05.xhtml#pseudo-fs)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像未命名管道一样，命名管道与正常的文件I/O（`open`、`write`等）一起工作，并提供先进先出（FIFO）传递。与未命名管道不同，命名管道的生命周期不限于使用它的进程。从技术上讲，命名管道是管道的一种包装，使用`pipefs`伪文件系统（参见[“伪文件系统”](ch05.xhtml#pseudo-fs)）。
- en: 'Let’s see a named pipe in action to better appreciate what you can do with
    them. We create a named pipe called `examplepipe` in the following, along with
    one publisher and one consumer process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看命名管道的实际应用，以更好地理解它们能做什么。我们在下文中创建了一个名为`examplepipe`的命名管道，并创建了一个发布者和一个消费者进程：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_advanced_topics_CO3-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_topics_CO3-1)'
- en: We create a named pipe called `examplepipe`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`examplepipe`的命名管道。
- en: '[![2](Images/2.png)](#co_advanced_topics_CO3-2)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_topics_CO3-2)'
- en: 'Looking at the pipe with `ls` reveals its type: the first letter is a `p`,
    indicating it’s a named pipe we’re looking at.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ls`查看管道的类型：第一个字母是`p`，表示我们正在查看一个命名管道。
- en: '[![3](Images/3.png)](#co_advanced_topics_CO3-3)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_topics_CO3-3)'
- en: Using a loop, we publish the character `x` into our pipe. Note that unless some
    other process reads from `examplepipe`, the pipe is blocked. No further writing
    into it is possible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环，我们将字符`x`发布到我们的管道中。请注意，除非有其他进程从`examplepipe`读取，否则管道将被阻塞。不能再向其写入数据。
- en: '[![4](Images/4.png)](#co_advanced_topics_CO3-4)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_advanced_topics_CO3-4)'
- en: We launch a second process that reads from the pipe in a loop.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动了第二个进程，它在循环中从管道中读取。
- en: '[![5](Images/5.png)](#co_advanced_topics_CO3-5)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_advanced_topics_CO3-5)'
- en: As a result of our setup we see `x` appearing on the terminal, roughly every
    five seconds. In other words, it appears every time the process with PID `19636`
    is able to read from the named pipe with `cat`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的设置，我们看到每隔大约五秒钟终端上出现`x`。换句话说，每次进程PID为`19636`的进程能够从带有`cat`的命名管道中读取时，它就会出现。
- en: Named pipes are easy to use. Thanks to their design, they look and feel like
    normal files. But they’re also limited, since they support only one direction
    and one consumer. The next IPC mechanism we look at addresses these limitations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道易于使用。由于其设计，它们看起来和感觉像普通文件。但它们也有局限性，因为它们仅支持单向和单个消费者。我们接下来看看的IPC机制解决了这些限制。
- en: UNIX Domain Sockets
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNIX域套接字
- en: 'We’ve already talked about sockets in the context of networking. There are
    also other kinds of sockets that work exclusively in the context of a single machine,
    and one such kind is called [UNIX domain sockets](https://oreil.ly/nCd6r): these
    are bidirectional, multiway communication endpoints. This means you can have multiple
    consumers.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在网络环境中讨论了套接字。还有其他种类的套接字专门在单台机器的上下文中使用，其中一种称为[UNIX域套接字](https://oreil.ly/nCd6r)：这些是双向的、多路通信端点。这意味着您可以有多个消费者。
- en: 'Domain sockets come in [three flavors](https://oreil.ly/AlVUf): stream-oriented
    (`SOCK_STREAM`), datagram-oriented (`SOCK_DGRAM`), and sequenced-packet (`SOCK_SEQPACKET`).
    The addressing works based on filesystem pathnames. Rather than having IP addresses
    and ports, a simple file path is sufficient.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 域套接字有[三种类型](https://oreil.ly/AlVUf)：面向流（`SOCK_STREAM`）、面向数据报（`SOCK_DGRAM`）和顺序数据包（`SOCK_SEQPACKET`）。寻址基于文件系统路径名。与IP地址和端口不同，一个简单的文件路径就足够了。
- en: Usually, you would be using domain sockets [programmatically](https://oreil.ly/o8Ikj).
    However, you might find yourself in a situation where you need to troubleshoot
    a system and want to use, for example, the [`socat` tool](https://oreil.ly/lWjrs)
    from the command line to interact manually with a socket.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会通过编程的方式使用域套接字（[链接](https://oreil.ly/o8Ikj)）。然而，您可能会发现自己处于需要排除系统故障并希望使用例如[`socat`工具](https://oreil.ly/lWjrs)从命令行手动与套接字交互的情况。
- en: Virtual Machines
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机
- en: This section is about an established technique that allows us to emulate multiple
    VMs using a physical machine such as your laptop or a server in a data center.
    This yields a more flexible and powerful way to run different workloads, potentially
    from different tenants in a strongly isolated manner. We focus on hardware-assisted
    virtualization for x86 architectures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲述了一种成熟的技术，使我们能够使用像您的笔记本电脑或数据中心中的服务器这样的物理机器模拟多个虚拟机。这提供了一种更灵活、更强大的方式来运行不同的工作负载，可能是来自不同租户的，具有强隔离的方式。我们重点关注
    x86 架构的硬件辅助虚拟化。
- en: 'In [Figure 9-1](#fig-virt), you see the virtualization architecture on a conceptual
    level, comprising the following (starting from the bottom):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[   在 [图 9-1](#fig-virt) 中，您可以看到概念层面的虚拟化架构，包含以下内容（从底部开始）：
- en: The CPU
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CPU
- en: Must support hardware virtualization.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 必须支持硬件虚拟化。
- en: The kernel-based virtual machine
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内核的虚拟机
- en: Found in the Linux kernel; discussed in [“Kernel-Based Virtual Machine”](#kvm).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 Linux 内核中；在[“基于内核的虚拟机”](#kvm)中讨论。
- en: Components in the user space
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间中的组件
- en: 'Components in the user space include the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间中的组件包括以下内容：
- en: A Virtual Machine Monitor (VMM)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机监控器（VMM）
- en: Manages VMs and emulates virtual devices, such as [QEMU](https://www.qemu.org)
    and Firecracker (see [“Firecracker”](#firecracker)). There is also [libvirt](https://libvirt.org),
    a library that exposes a generic API aiming to standardize VMM, which you can
    use programmatically (not explicitly shown in the figure; consider it part of
    the VMM block).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 管理虚拟机并模拟虚拟设备，如 [QEMU](https://www.qemu.org) 和 Firecracker（见[“Firecracker”](#firecracker)）。还有
    [libvirt](https://libvirt.org)，一个暴露通用 API 的库，旨在标准化 VMM，您可以通过编程使用（在图中未明确显示；视为 VMM
    块的一部分）。
- en: The guest kernel
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 来宾内核
- en: Typically also a Linux kernel but could also be Windows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常也是 Linux 内核，但也可以是 Windows。
- en: The guest processes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 来宾进程
- en: Running on the guest kernel.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在来宾内核上。
- en: '![lmlx 0901](Images/lmlx_0901.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![lmlx 0901](Images/lmlx_0901.png)'
- en: Figure 9-1\. Virtualization architecture
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 虚拟化架构
- en: The processes that run natively on the host kernel (in [Figure 9-1](#fig-virt),
    process 1 and process 2) are isolated from the guest processes. This means that
    in general the physical CPU and memory of the host are not affected by guest activities.
    For example, if there’s an attack going on in the VM, the host kernel and processes
    are unaffected (as long as the VM is not given special access to the host system).
    Note that there may be exceptions to this in practice, such as [rowhammer](https://oreil.ly/L7qH9)
    or [Meltdown and Spectre](https://oreil.ly/ZlgRE).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在主机内核上的进程（在 [图 9-1](#fig-virt) 中，进程 1 和进程 2）与来宾进程隔离。这意味着一般来说，主机的物理 CPU 和内存不会受到来宾活动的影响。例如，如果虚拟机中有攻击，主机内核和进程不会受到影响（只要虚拟机没有特殊权限访问主机系统）。请注意，实际情况中可能会有例外，例如
    [rowhammer](https://oreil.ly/L7qH9) 或 [Meltdown 和 Spectre](https://oreil.ly/ZlgRE)。
- en: Kernel-Based Virtual Machine
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于内核的虚拟机
- en: The [Kernel-based Virtual Machine (KVM)](https://oreil.ly/vTINW) is a Linux-native
    virtualization solution for x86 hardware that supports virtualization extensions,
    such as the case with [AMD-V](https://oreil.ly/XXAM8) or [Intel VT](https://oreil.ly/SAbNc).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[基于内核的虚拟机（KVM）](https://oreil.ly/vTINW)是一个针对支持虚拟化扩展的 x86 硬件的 Linux 本地虚拟化解决方案，如
    [AMD-V](https://oreil.ly/XXAM8) 或 [Intel VT](https://oreil.ly/SAbNc)。'
- en: 'There are two parts to the KVM kernel modules: the core module (`kvm.ko`) and
    CPU architecture-specific modules (`kvm-intel.ko`/`kvm-amd.ko`). With KVM, the
    Linux kernel is the hypervisor, taking care of most of the heavy lifting. In addition,
    there are drivers such as the integrated [Virtio](https://oreil.ly/g37Qe) that
    allow for I/O virtualization.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: KVM 内核模块有两个部分：核心模块（`kvm.ko`）和特定于 CPU 架构的模块（`kvm-intel.ko`/`kvm-amd.ko`）。通过 KVM，Linux
    内核作为超视图管理程序，负责大部分的重负担。此外，还有诸如集成的 [Virtio](https://oreil.ly/g37Qe) 这样的驱动程序，允许进行
    I/O 虚拟化。
- en: 'Today, hardware usually supports virtualization and KVM is already available,
    but in order to see if your system is capable of using KVM, you can do the following
    check (output edited):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，硬件通常支持虚拟化，KVM 已经可用，但为了检查您的系统是否能够使用 KVM，您可以执行以下检查（输出已编辑）：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_advanced_topics_CO4-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_topics_CO4-1)'
- en: Search for `svm` or `vmx` in the CPU information (note that it reports on a
    per-CPU basis, so if you have eight cores, you would see this `flags` block repeated
    eight times).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CPU 信息中搜索 `svm` 或 `vmx`（请注意，它是按 CPU 计算的，因此如果您有八个核心，您将看到这个 `flags` 块重复出现八次）。
- en: '[![2](Images/2.png)](#co_advanced_topics_CO4-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_topics_CO4-2)'
- en: We see `vmx` is listed, so we’re good concerning hardware-assisted virtualization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到列出了 `vmx`，所以在硬件辅助虚拟化方面，一切都很好。
- en: '[![3](Images/3.png)](#co_advanced_topics_CO4-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_topics_CO4-3)'
- en: Here we check if the KVM kernel modules are available.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们检查 KVM 内核模块是否可用。
- en: '[![4](Images/4.png)](#co_advanced_topics_CO4-4)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_advanced_topics_CO4-4)'
- en: This tells us that we have the `kvm_intel` kernel module loaded, so we’re all
    set concerning KVM usage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们已加载了 `kvm_intel` 内核模块，因此在使用 KVM 方面一切都设置好了。
- en: One modern way to manage KVMs is with Firecracker.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 KVM 的一种现代方式是使用 Firecracker。
- en: Firecracker
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firecracker
- en: '[Firecracker](https://oreil.ly/UpNPK) is a VMM that can manage KVM instances.
    It is written in Rust and was developed at Amazon Web Services primarily for serverless
    offerings, such as AWS Lambda and AWS Fargate.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[Firecracker](https://oreil.ly/UpNPK) 是一个可以管理 KVM 实例的 VMM。它用 Rust 编写，主要在亚马逊网络服务（AWS）上开发，用于无服务器提供，如
    AWS Lambda 和 AWS Fargate。'
- en: Firecracker is [designed](https://oreil.ly/6D8Wk) to safely run multitenant
    workloads on the same physical machine. The Firecracker VMM manages so-called
    *microVMs* that expose an HTTP API to the host, allowing you to launch, query,
    and stop the microVMs. It emulates network interfaces by using [TUN/TAP devices](https://oreil.ly/ojWvm)
    on the host, and block devices are backed by files on the host, supporting Virtio
    devices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Firecracker 被 [设计](https://oreil.ly/6D8Wk) 以安全地在同一物理机上运行多租户工作负载。Firecracker
    VMM 管理所谓的 *microVMs*，向主机公开 HTTP API，允许您启动、查询和停止 microVMs。它通过在主机上使用 [TUN/TAP 设备](https://oreil.ly/ojWvm)
    模拟网络接口，并且块设备由主机上的文件支持，支持 Virtio 设备。
- en: From a security perspective, in addition to the virtualization discussed so
    far, Firecracker by default uses seccomp filters (see [“seccomp Profiles”](ch04.xhtml#seccomp))
    to limit the host system calls it can use. cgroups can also be used. From an observability
    point of view, you can gather logs and metrics from Firecracker, via named pipes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，除了迄今讨论的虚拟化外，Firecracker 默认使用 seccomp 过滤器（参见[“seccomp Profiles”](ch04.xhtml#seccomp)）来限制它可以使用的主机系统调用。还可以使用
    cgroups。从可观察性的角度来看，您可以通过命名管道从 Firecracker 收集日志和指标。
- en: With that we move on to modern Linux distributions that focus on immutability
    and leverage containers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们转向专注于不变性并利用容器的现代 Linux 发行版。
- en: Modern Linux Distros
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代 Linux 发行版
- en: 'The most prominent traditional Linux distributions include the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的传统 Linux 发行版包括以下几种：
- en: The Red Hat family (RHEL, Fedora, and CentOS/Rocky)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红帽家族（RHEL、Fedora 和 CentOS/Rocky）
- en: The Debian-based family (Ubuntu, Mint, Kali, Parrot OS, elementary OS, etc.)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Debian 的家族（Ubuntu、Mint、Kali、Parrot OS、elementary OS 等）
- en: The SUSE family (openSUSE and Enterprise)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUSE 家族（openSUSE 和 Enterprise）
- en: Gentoo
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gentoo
- en: Arch Linux
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arch Linux
- en: These are all perfectly fine distros. Depending on your needs and preferences,
    you can choose from being fully in control and taking care of everything yourself
    (from installation to patching) to having a fully managed offering where the distro
    takes care of most of the tasks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常好的发行版。根据您的需求和偏好，您可以选择从完全控制和自己处理一切（从安装到打补丁）到完全托管的方案，在这种情况下，发行版将处理大部分任务。
- en: 'With the rise of containers, as discussed in [“Containers”](ch06.xhtml#containers),
    the role of the host operating system has changed. In the context of containers,
    traditional package managers (see [“Packages and Package Managers”](ch06.xhtml#package-managers))
    play a different role: most base container images tend to be built from particular
    Linux distros, and dependencies are met within the containers with *.deb* or *.rpm*
    packages, while the container images package up all the application-level dependencies
    on top of them.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器的兴起，如在 [“容器”](ch06.xhtml#containers) 中讨论的那样，主机操作系统的角色发生了变化。在容器的上下文中，传统的包管理器（参见
    [“包和包管理器”](ch06.xhtml#package-managers)）扮演了不同的角色：大多数基础容器镜像通常是从特定的 Linux 发行版构建的，并且容器内部通过
    *.deb* 或 *.rpm* 包来满足所有应用程序级别的依赖关系。
- en: 'Further, making incremental changes to a system turns out to be a big challenge.
    This is especially true when you need to do it at scale, such as when you need
    to administrate a fleet of machines. Hence, for modern distros, the focus is increasingly
    on immutability. The idea is that any change in the configuration or code (think:
    a patch that fixes a security issue or a new feature) causes the creation of a
    new artifact, such as a container image that gets launched (in contrast to changing
    the running system).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对系统进行增量更改证明是一个巨大的挑战。特别是当您需要在规模化环境中进行管理时，比如需要管理一群机器时。因此，对于现代发行版来说，焦点越来越多地放在不变性上。其思想是，对配置或代码（比如修复安全问题或新增功能的补丁）的任何更改都会导致新构件的创建，例如一个容器映像，而不是更改运行中的系统。
- en: When I say “modern Linux distros,” I mean distros that are container-centric,
    with immutability and auto-upgrading (pioneered by Chrome) front and center. Let’s
    have a look at some examples of modern distros.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“现代Linux发行版”时，我指的是以容器为中心，以不变性和自动升级（由Chrome开创）为核心的发行版。让我们看一些现代发行版的例子。
- en: Red Hat Enterprise Linux CoreOS
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Red Hat Enterprise Linux CoreOS
- en: 'In 2013, a young start-up called CoreOS made [CoreOS Linux (later renamed Container
    Linux)](https://oreil.ly/XjqPV) available. Its main features included a dual-partition
    scheme for system updates and the lack of a package manager. In other words, all
    apps would run as containers natively. In the ecosystem, a number of tools were
    developed that are still in use (such as `etcd`; think: a distributed version
    of the */etc* directory for configuration tasks).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，一家名为CoreOS的年轻初创公司发布了[CoreOS Linux（后来改名为Container Linux）](https://oreil.ly/XjqPV)。其主要特点包括系统更新的双分区方案和缺少包管理器。换句话说，所有应用程序都将作为容器在本地运行。在这个生态系统中，开发了许多仍在使用的工具（如`etcd`；想象一个用于配置任务的分布式版本的*/etc*目录）。
- en: After Red Hat acquired CoreOS (the company), it announced the intention to merge
    the CoreOS Linux with Red Hat’s own Project Atomic (that had similar goals). This
    merger led to [Red Hat Enterprise Linux CoreOS (RHCOS)](https://oreil.ly/38kzX),
    which is not meant to be used on its own but in the context of the Red Hat Kubernetes
    distribution called OpenShift Container Platform.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Red Hat收购了CoreOS（公司）之后，它宣布了将CoreOS Linux与Red Hat自己的Project Atomic（具有类似目标的项目）合并的意图。这一合并导致了[Red
    Hat Enterprise Linux CoreOS (RHCOS)](https://oreil.ly/38kzX)，这并不意味着它可以单独使用，而是在Red
    Hat称为OpenShift Container Platform的Kubernetes发行版的上下文中使用。
- en: Flatcar Container Linux
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flatcar Container Linux
- en: A little bit after Red Hat announced its plans around Container Linux, a German
    startup called Kinvolk GmbH (now part of Microsoft) announced that it would fork
    and continue to develop Container Linux under the new brand name [Flatcar Container
    Linux](https://oreil.ly/rNJrt).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，Red Hat宣布其在Container Linux周围的计划后，一家名为Kinvolk GmbH（现为Microsoft的一部分）的德国初创公司宣布将继续在新品牌[Flatcar
    Container Linux](https://oreil.ly/rNJrt)下分叉并继续开发Container Linux。
- en: Flatcar describes itself as a container-native, lightweight operating system
    with use cases in container orchestrators such as Kubernetes and IoT/edge computing.
    It continues the CoreOS tradition of auto-upgrades (optional with its own update
    manager, [Nebraska](https://oreil.ly/Qepv6)) and has a powerful yet simple-to-use
    provisioning utility called [Ignition](https://oreil.ly/4vEQv) that enables you
    to have fine-grained control over boot devices (also used by RHCOS for that purpose).
    Further, there is no package manager; everything is running in containers. You
    can manage the life cycle of the containerized apps with `systemctl` on a single
    machine or more typically with Kubernetes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Flatcar自称是一个容器本地化、轻量级操作系统，适用于容器编排器如Kubernetes和IoT/边缘计算。它延续了CoreOS的传统自动升级（可选与其自己的更新管理器[Nebraska](https://oreil.ly/Qepv6)）并且有一个称为[Ignition](https://oreil.ly/4vEQv)的强大而简单易用的引导设备配置实用程序，使您能够对启动设备进行精细控制（RHCOS也用于此目的）。此外，它没有包管理器；一切都在容器中运行。您可以使用`systemctl`在单台机器上管理容器化应用的生命周期，或者更常见地使用Kubernetes。
- en: Bottlerocket
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓶子火箭
- en: '[Bottlerocket](https://oreil.ly/fIKrQ) is a Linux-based operating system developed
    by AWS and meant for [hosting containers](https://oreil.ly/5Eaxd). Written in
    Rust, it is used in a number of their offerings, such as Amazon EKS and Amazon
    ECS.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[瓶子火箭](https://oreil.ly/fIKrQ)是由AWS开发的基于Linux的操作系统，专为[托管容器](https://oreil.ly/5Eaxd)而设计。用Rust编写，用于多种服务，如Amazon
    EKS和Amazon ECS。'
- en: Akin to Flatcar and CoreOS, instead of a package manager, Bottlerocket uses
    an OCI image-based model for app upgrades and rollbacks. Bottlerocket uses a (by
    and large) read-only, integrity-checked filesystem based on [dm-verity](https://oreil.ly/xicaW).
    To gain access (via SSH, although discouraged) and control Bottlerocket, it runs
    a so-called [control container](https://oreil.ly/KB6eX), in a separate `containerd`
    instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flatcar和CoreOS类似，Bottlerocket不使用包管理器，而是使用基于OCI镜像的模型进行应用程序升级和回滚。 Bottlerocket使用（大体上）只读、完整性检查的文件系统，基于[dm-verity](https://oreil.ly/xicaW)。为了通过SSH（虽然不推荐）访问和控制Bottlerocket，它运行一个所谓的[控制容器](https://oreil.ly/KB6eX)，在一个独立的`containerd`实例中。
- en: RancherOS
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RancherOS
- en: '[RancherOS](https://oreil.ly/73UxM) is a Linux distro where everything is a
    container managed by Docker. Sponsored by Rancher (now SUSE), it is optimized
    for container workloads as in their Kubernetes distro. It runs two Docker instances:
    the system Docker, which runs as the first process, and the user Docker, which
    is used to create application containers. RancherOS has a small footprint, which
    makes it really great to use in the context of embedded systems and edge computing.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[RancherOS](https://oreil.ly/73UxM)是一个Linux发行版，其中一切都是由Docker管理的容器。由Rancher（现为SUSE）赞助，它针对容器工作负载进行了优化，如同其Kubernetes发行版。它运行两个Docker实例：系统Docker作为第一个进程运行，用户Docker用于创建应用程序容器。RancherOS具有很小的占用空间，非常适合嵌入式系统和边缘计算环境中使用。'
- en: Selected Security Topics
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选定的安全主题
- en: In [Chapter 4](ch04.xhtml#access-control), we discussed a number of access control
    mechanisms. We discussed *authentication* (*authn*, for short), which verifies
    the identity of a user and is a precondition for any sort of *authorization* (*authz*,
    for short). In this section, we briefly discuss two widely used authn tools that
    you should be aware of.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#access-control)中，我们讨论了许多访问控制机制。我们讨论了*认证*（简称为*authn*），用于验证用户的身份，并且是任何*授权*（简称为*authz*）的先决条件。在本节中，我们简要讨论了两个广泛使用的认证工具，您应该注意它们。
- en: Kerberos
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kerberos
- en: '[Kerberos](https://kerberos.org) is an authn suite developed by the Massachusetts
    Institute of Technology in the 1980s. Today, it’s formally specified in [RFC 4120](https://oreil.ly/7woDK)
    and related IETF documents. The core idea of Kerberos is that we’re usually dealing
    with insecure networks, but we want a secure way for clients and services to prove
    their identity to one another.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kerberos](https://kerberos.org)是麻省理工学院在1980年代开发的认证套件。今天，它在[RFC 4120](https://oreil.ly/7woDK)和相关的IETF文件中有正式规范。Kerberos的核心思想是，我们通常处理不安全的网络，但我们希望客户端和服务之间能够安全地证明其身份。'
- en: 'Conceptually, the Kerberos authn process, shown in [Figure 9-2](#fig-kerberos),
    works as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，Kerberos认证过程如[图9-2](#fig-kerberos)所示，工作原理如下：
- en: '![lmlx 0902](Images/lmlx_0902.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![lmlx 0902](Images/lmlx_0902.png)'
- en: Figure 9-2\. Kerberos protocol concept
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-2\. Kerberos协议概念
- en: A client (for example, a program on your laptop) sends a request to a Kerberos
    component called the Key Distribution Center (KDC), asking for credentials for
    a given service, such as printing or a directory.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个客户端（例如，您笔记本上的程序）向称为密钥分发中心（KDC）的Kerberos组件发送请求，请求为特定服务（如打印或目录）获取凭据。
- en: The KDC responds with the requested credentials—that is, a ticket for the service
    and a temporary encryption key (session key).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: KDC响应所请求的凭据——即服务的票证和临时加密密钥（会话密钥）。
- en: The client transmits the ticket (which contains the client’s identity and a
    copy of the session key) to the service.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将票证（其中包含客户端的身份和会话密钥的副本）传输给服务。
- en: The session key, shared by the client and service, is used to authenticate the
    client and may optionally be used to authenticate the service.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话密钥由客户端和服务共享，用于验证客户端，并且可选择用于验证服务。
- en: There are also challenges with Kerberos, such as the central role that the KDC
    plays (a single point of failure) and its strict time requirements (it requires
    clock synchronization between the client and the server via NTP). Overall, while
    not simple to operate and administrate, Kerberos is widely used and supported
    in the enterprise and cloud providers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos也存在一些挑战，例如KDC扮演的中心角色（单点故障）以及其严格的时间要求（需要通过NTP在客户端和服务器之间进行时钟同步）。总体而言，尽管操作和管理不简单，Kerberos在企业和云服务提供商中得到了广泛使用和支持。
- en: Pluggable Authentication Modules
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可插拔认证模块
- en: 'Historically, a program would manage the user authentication process itself.
    With [pluggable authentication modules (PAM)](http://www.linux-pam.org), a flexible
    way to develop programs that are independent of a concrete authentication scheme
    has arrived in Linux (PAM has been around since the end of the 1990s in the wider
    UNIX ecosystem). PAM uses a modular architecture, providing developers a powerful
    library to interface with it. It also allows system administrators to plug in
    different modules, such as the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上，程序会自行管理用户认证过程。使用[可插拔认证模块（PAM）](http://www.linux-pam.org)，Linux引入了一种灵活的开发程序的方式，独立于具体的认证方案（PAM自1990年代末起在更广泛的UNIX生态系统中存在）。PAM采用模块化架构，为开发人员提供了一个强大的库来与之交互。它还允许系统管理员插入不同的模块，例如以下内容：
- en: '[`pam_localuser`](https://oreil.ly/NCs0A)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pam_localuser`](https://oreil.ly/NCs0A)'
- en: Requires that a user is listed in */etc/passwd*
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要求用户在*/etc/passwd*中列出
- en: '[`pam_keyinit`](https://oreil.ly/PkGt9)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pam_keyinit`](https://oreil.ly/PkGt9)'
- en: For session keyrings
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用于会话密钥环
- en: '[`pam_krb5`](https://oreil.ly/YinOv)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pam_krb5`](https://oreil.ly/YinOv)'
- en: For Kerberos 5 password-based checks
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Kerberos 5基于密码的检查
- en: With that, we’ve reached the end of the advanced security topics and now turn
    to more aspirational topics.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经完成了高级安全主题的讨论，现在转向更具抱负性的主题。
- en: Other Modern and Future Offerings
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他现代和未来的提供
- en: In this section, we look at exciting Linux offerings, including new ways to
    set up Linux and ways to work with Linux in new environments. In the server world
    (be it an on-premises data center or the public cloud), Linux is already the de
    facto standard, and Linux is under the hood in many mobile devices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些令人兴奋的Linux提供，包括设置Linux的新方法以及在新环境中使用Linux的方式。在服务器世界中（无论是本地数据中心还是公共云），Linux已经是事实上的标准，在许多移动设备中，Linux在幕后起着关键作用。
- en: What the topics here in this section have in common is that at the time of writing,
    they have not yet entered the mainstream. However, if you’re curious about what
    future developments might look like or where there’s still high growth potential
    for Linux, read on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的主题共同点是，目前这些主题尚未进入主流。然而，如果你对未来的发展可能是什么样子或Linux仍存在高增长潜力的领域感兴趣，请继续阅读。
- en: NixOS
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NixOS
- en: '[NixOS](https://nixos.org) is a source-based Linux distro, taking a functional
    approach to package management and system configuration as well as rollbacks for
    upgrades. I call this a “functional approach” because the artifacts are based
    on immutability.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[NixOS](https://nixos.org)是一种基于源的Linux发行版，采用功能化的包管理和系统配置方式以及用于升级回滚的机制。我将其称为“功能化的方法”，因为这些制品基于不变性。'
- en: The [Nix package manager](https://oreil.ly/Km84W) builds the entire operating
    system, from the kernel to system packages and apps. Nix offers multiuser package
    management and even allows you to install and use multiple versions of the same
    package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[Nix软件包管理器](https://oreil.ly/Km84W)构建整个操作系统，从内核到系统包和应用程序。'
- en: Unlike most other Linux distros, NixOS does not follow the Linux Standard Base
    filesystem layout as discussed in [“Common Filesystem Layouts”](ch05.xhtml#common-fs-layouts)
    (with system programs located in */usr/bin*, */usr/lib*, and so on, and the configuration
    usually located in */etc*).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他Linux发行版不同，NixOS不遵循Linux标准基础文件系统布局的讨论（位于*/usr/bin*、*/usr/lib*等位置的系统程序以及通常位于*/etc*的配置）。
- en: There are a number of interesting ideas in NixOS and its ecosystem, making it
    especially relevant for CI pipelines. Even if you don’t want to go all in, you
    can, for example, use the Nix package manager standalone (outside of NixOS).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: NixOS及其生态系统中有许多有趣的想法，使其特别适合CI流水线。即使您不想完全投入，也可以单独使用Nix软件包管理器（在NixOS之外）。
- en: Linux on the Desktop
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux桌面化
- en: While the viability of [Linux on the desktop](https://oreil.ly/eBPYT) is subject
    to ongoing discussions, there is without doubt plenty of choice concerning desktop-friendly
    distros and with them a selection of [window managers](https://oreil.ly/qylKC).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[Linux桌面化](https://oreil.ly/eBPYT)的可行性仍在讨论中，但毫无疑问，关于桌面友好的发行版以及与之相关的[窗口管理器](https://oreil.ly/qylKC)有很多选择。
- en: In good UNIX tradition, the Graphical User Interface (GUI) part is separated
    from the rest of the operating system. Usually, an [X window manager](https://oreil.ly/bTcHy)
    takes care of the GUI responsibilities (from window management to styling and
    rendering) with the help of a [display manager](https://oreil.ly/hl5gv).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 符合UNIX传统，图形用户界面（GUI）部分与操作系统的其余部分分离。通常，[X窗口管理器](https://oreil.ly/bTcHy)负责GUI的职责（从窗口管理到样式和渲染），并借助[显示管理器](https://oreil.ly/hl5gv)的帮助。
- en: On top of the window manager, implementing a desktop experience (such as icons,
    widgets, and toolbars), sit the [desktop environments](https://oreil.ly/y1VIr),
    such as KDE or MATE.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口管理器的基础上，实现桌面体验（例如图标、小部件和工具栏）的是[桌面环境](https://oreil.ly/y1VIr)，比如KDE或MATE。
- en: There are many beginner-friendly desktop Linux distros available nowadays, making
    it easy to switch from Windows or macOS. The same is true for a range of open
    source applications, from office apps (writing docs or working with spreadsheets,
    such as LibreOffice) to drawing and image editing (Gimp), to all major web browsers,
    games, media players, and utilities, to development environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如今有许多适合初学者的桌面Linux发行版，从而使从Windows或macOS切换变得容易。同样适用于各种开源应用程序，从办公应用程序（撰写文档或处理电子表格，比如LibreOffice）到绘图和图像编辑（Gimp），再到所有主要的Web浏览器、游戏、媒体播放器和实用工具，以及开发环境。
- en: 'The catalyst for Linux on the desktop might in fact come from a rather unexpected
    direction: with [Windows 11 allowing you to run graphical Linux apps](https://oreil.ly/tGgaf)
    out of the box, this might change the incentives and uptake for good. Time will
    tell.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Linux桌面的催化剂可能来自一个非常意想不到的方向：随着[Windows 11允许你直接运行图形化Linux应用程序](https://oreil.ly/tGgaf)，这可能改变相关的激励和采用情况。时机将会证明一切。
- en: Linux on Embedded Systems
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式系统上的Linux
- en: '[Linux on embedded systems](https://oreil.ly/mFKVR) is a wide field, with implementations
    ranging from cars to networking equipment (such as routers), to smart home devices
    (for example fridges) and media devices/smart TVs.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[嵌入式系统上的Linux](https://oreil.ly/mFKVR)是一个广泛的领域，涵盖从汽车到网络设备（如路由器），到智能家居设备（例如冰箱）和媒体设备/智能电视等多种实现。'
- en: One particularly interesting generic platform you can acquire for little money
    is a [Raspberry Pi (RPI)](https://www.raspberrypi.org). It comes with its own
    Linux distro called Raspberry Pi OS (a Debian-based system) and lets you install
    this and other Linux distros simply via a microSD card. The RPI has a number of
    General Purpose Input/Outputs (GPIOs), making it straightforward to use external
    sensors and circuits via a breadboard. You can experiment with, and learn electronics
    and program the hardware with, for example, Python.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以极少的费用获取一个特别有趣的通用平台，即[Raspberry Pi（RPI）](https://www.raspberrypi.org)。它配备了自己的Linux发行版称为Raspberry
    Pi OS（基于Debian的系统），通过微型SD卡可以简单地安装这个及其他Linux发行版。RPI具有多个通用输入/输出（GPIO），使得通过面包板使用外部传感器和电路变得简单。你可以通过Python等语言实验、学习电子技术并编程硬件。
- en: Linux in Cloud IDE
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云IDE中的Linux
- en: In recent years, the viability of cloud-based development environments has made
    enormous progress to a point where now (commercial) offerings exist that combine
    an IDE (usually Visual Studio Code), Git, and a range of programming languages
    in a Linux environment. All you as a developer need is a web browser and network
    access, and you can edit, test, and run code “in the cloud.”
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，基于云的开发环境的可行性取得了巨大进展，现在已经存在（商业）产品，将集成开发环境（通常是Visual Studio Code）、Git 和多种编程语言结合到Linux环境中。作为开发者，你只需一个Web浏览器和网络访问，就可以在“云端”编辑、测试和运行代码。
- en: Two notable examples of Cloud IDEs, at the time of writing, are [Gitpod](https://www.gitpod.io),
    which is available either as a managed offering or as an open source to host yourself,
    and [Codespaces](https://oreil.ly/bWNDT), which is deeply integrated into GitHub.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，两个著名的云IDE的例子分别是[Gitpod](https://www.gitpod.io)，它可以作为托管服务提供，也可以作为开源项目自行托管；以及[Codespaces](https://oreil.ly/bWNDT)，它与GitHub深度集成。
- en: Conclusion
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'This chapter covered advanced topics and refined your knowledge of basic techniques
    and tooling. If you want to enable IPC, you can use signals and named pipes. For
    isolating workloads, you can use VMs, especially modern variants such as Firecracker.
    We also discussed modern Linux distributions: if you plan to run containers (Docker),
    you may want to consider these container-centric distros that enforce immutability.
    We then moved on to selected security topics, specially Kerberos and PAM for flexible
    and/or large-scale authentication. Finally, we reviewed not-yet-mainstream Linux
    solutions such as Linux on the desktop and how you can get started with Linux
    on embedded systems, such as the Raspberry Pi, for local experimentation or development.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了高级主题，并且深化了您对基本技术和工具的了解。如果您想要启用 IPC，可以使用信号和命名管道。要隔离工作负载，可以使用虚拟机，特别是现代变体如
    Firecracker。我们还讨论了现代 Linux 发行版：如果您计划运行容器（Docker），可能需要考虑这些强制不变性的容器中心发行版。然后我们转向了选定的安全主题，特别是
    Kerberos 和 PAM 用于灵活和/或大规模认证。最后，我们回顾了尚未主流的 Linux 解决方案，例如桌面 Linux 及如何在树莓派等嵌入式系统上开始使用
    Linux 进行本地实验或开发。
- en: 'Some further reading for this chapter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的进一步阅读材料：
- en: IPC
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: IPC
- en: '[“An Introduction to Linux IPC”](https://oreil.ly/C2iwX)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Linux IPC 简介”](https://oreil.ly/C2iwX)'
- en: '[“Inter-process Communication in Linux: Using Pipes and Message Queues”](https://oreil.ly/cbi1Z)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Linux 中的进程间通信：使用管道和消息队列”](https://oreil.ly/cbi1Z)'
- en: '[“The Linux Kernel Implementation of Pipes and FIFOs”](https://oreil.ly/FUvoo)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Linux 内核中管道和 FIFO 的实现”](https://oreil.ly/FUvoo)'
- en: '[“Socat Cheatsheet”](https://oreil.ly/IwiyP)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Socat 速查表](https://oreil.ly/IwiyP)'
- en: VMs
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机
- en: '[“What Is a Virtual Machine?” (VMware)](https://oreil.ly/vJ9Uf)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[VMware 的“什么是虚拟机？”](https://oreil.ly/vJ9Uf)'
- en: '[“What Is a Virtual Machine (VM)?” (Red Hat/IBM)](https://oreil.ly/wJEG1)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“什么是虚拟机（VM）？”（Red Hat/IBM）](https://oreil.ly/wJEG1)'
- en: '[“How to Create and Manage KVM Virtual Machines from CLI”](https://oreil.ly/cTH8b)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“如何通过 CLI 创建和管理 KVM 虚拟机”](https://oreil.ly/cTH8b)'
- en: '[“KVM” via Debian Wiki](https://oreil.ly/XLVwj)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过 Debian Wiki 的“KVM”](https://oreil.ly/XLVwj)'
- en: '[QEMU machine emulator and virtualizer website](https://oreil.ly/wDCrH)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[QEMU 机器仿真器和虚拟化器网站](https://oreil.ly/wDCrH)'
- en: '[Firecracker website](https://oreil.ly/yIOxz)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Firecracker 网站](https://oreil.ly/yIOxz)'
- en: Modern distros
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现代发行版
- en: '[“Containers and Clustering”](https://oreil.ly/Z8ZNC)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“容器与集群”](https://oreil.ly/Z8ZNC)'
- en: '[“Immutability & Loose Coupling: A Match Made in Heaven”](https://oreil.ly/T89ed)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“不变性与松耦合：天作之合”](https://oreil.ly/T89ed)'
- en: '[“Tutorial: Install Flatcar Container Linux on Remote Bare Metal Servers”](https://oreil.ly/hZN1b)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“教程：在远程裸金属服务器上安装 Flatcar 容器 Linux”](https://oreil.ly/hZN1b)'
- en: '[List of image-based Linux distributions and associated tooling](https://oreil.ly/gTav0)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[基于图像的 Linux 发行版及相关工具](https://oreil.ly/gTav0)'
- en: '[“Security Features of Bottlerocket, an Open Source Linux-Based Operating System”](https://oreil.ly/Bfj7l)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bottlerocket 安全功能：一个基于开源 Linux 的操作系统](https://oreil.ly/Bfj7l)'
- en: '[“RancherOS: A Simpler Linux for Docker Lovers”](https://oreil.ly/61t6G)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“RancherOS：面向 Docker 爱好者的简化 Linux”](https://oreil.ly/61t6G)'
- en: Selected security
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的安全
- en: '[“Kerberos: The Network Authentication Protocol”](https://oreil.ly/rSPKm)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Kerberos：网络认证协议”](https://oreil.ly/rSPKm)'
- en: '[“PAM Tutorial”](https://oreil.ly/Pn9fL)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PAM 教程](https://oreil.ly/Pn9fL)'
- en: Other modern and future offerings
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其他现代和未来的选择
- en: '[“How X Window Managers Work, and How to Write One”](https://oreil.ly/LryXW)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“X 窗口管理器的工作原理及如何编写一个”](https://oreil.ly/LryXW)'
- en: '[“Purely Functional Linux with NixOS”](https://oreil.ly/qY62s)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“NixOS：纯函数式 Linux”](https://oreil.ly/qY62s)'
- en: '[“NixOS: Purely Functional System Configuration Management”](https://oreil.ly/8YALG)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“NixOS：纯函数式系统配置管理”](https://oreil.ly/8YALG)'
- en: '[“What Is a Raspberry Pi?”](https://oreil.ly/wnHxa)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“什么是树莓派？”](https://oreil.ly/wnHxa)'
- en: '[“Kubernetes on Raspberry Pi 4b with 64-bit OS from Scratch”](https://oreil.ly/cnAsx)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“在树莓派 4b 上从零开始使用 64 位操作系统部署 Kubernetes”](https://oreil.ly/cnAsx)'
- en: 'We’ve reached the end of the book. I hope this is the start of your own Linux
    journey. Thanks for staying with me, and if you have feedback, I’m always interested
    to hear from you, either via Twitter or via good old email: *modern-linux@pm.me*.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本书的阅读。希望这是您自己 Linux 旅程的起点。感谢您陪伴我到最后，如果您有反馈意见，我非常乐意听取，可以通过 Twitter 或者传统的电子邮件联系：*modern-linux@pm.me*。
