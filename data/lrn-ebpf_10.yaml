- en: Chapter 10\. eBPF Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. eBPF编程
- en: In this book so far, you’ve learned a lot about eBPF and seen many examples
    of how it’s used for a variety of applications. But what if you want to implement
    your own ideas based on eBPF? This chapter discusses your options when it comes
    to writing your own eBPF code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经学到了很多关于eBPF的知识，并看到了许多如何将其用于各种应用程序的示例。但是如果你想基于eBPF实现自己的想法，该章节将讨论你在编写自己的eBPF代码时的选择。
- en: 'As you know from reading this book, eBPF programming consists of two parts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从本书中了解到的那样，eBPF编程包括两个部分：
- en: Writing eBPF programs that run in the kernel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写在内核中运行的eBPF程序
- en: Writing the user space code that manages and interacts with eBPF programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写管理和与eBPF程序交互的用户空间代码
- en: Most of the libraries and languages I’ll discuss in this chapter require you
    as a programmer to handle both parts, with an awareness of what is being handled
    where. But `bpftrace`, perhaps the simplest eBPF programming language, masks this
    distinction from the programmer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章讨论的大多数库和语言都要求你作为程序员处理这两部分，并意识到处理的具体位置。但是`bpftrace`，也许是最简单的eBPF编程语言，掩盖了程序员对这种区别的感知。
- en: Bpftrace
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bpftrace
- en: As described on the project’s *README* page, “`bpftrace` is a high-level tracing
    language for Linux eBPF … inspired by awk and C, and predecessor tracers such
    as DTrace and SystemTap.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如项目的*README*页面所描述的，“`bpftrace`是Linux eBPF的高级跟踪语言…灵感来自awk和C，以及前身跟踪器如DTrace和SystemTap。”
- en: The [`bpftrace`](https://oreil.ly/BZNZO) command-line tool converts programs
    written in this high-level language into eBPF kernel code and provides some output
    formatting for the results within the terminal. As a user, you don’t really need
    to think about the kernel–user space split.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[`bpftrace`](https://oreil.ly/BZNZO)命令行工具将用高级语言编写的程序转换为eBPF内核代码，并为终端中的结果提供一些输出格式。作为用户，你不需要真正考虑内核与用户空间的分离。'
- en: You’ll find several examples of useful one-liners in the project documentation,
    including a nice [tutorial](https://oreil.ly/Ah2QB) that takes you from writing
    a simple “Hello World” script up to writing more sophisticated scripts that can
    trace out data read from within kernel data structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文档中，您会找到几个有用的单行示例，包括一个很好的[教程](https://oreil.ly/Ah2QB)，该教程将引导您从编写简单的“Hello
    World”脚本到编写更复杂的脚本，可以跟踪内核数据结构中读取的数据。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Get a feel for the range of capabilities that `bpftrace` provides from Brendan
    Gregg’s [`bpftrace` cheat sheet](https://oreil.ly/VBwLm). Or, for in-depth coverage
    of both `bpftrace` and BCC, see his book [*BPF Performance Tools*](https://oreil.ly/kjc95).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从Brendan Gregg的[`bpftrace`速查表](https://oreil.ly/VBwLm)中了解`bpftrace`提供的各种能力。或者，深入了解`bpftrace`和BCC，参见他的书籍[*BPF性能工具*](https://oreil.ly/kjc95)。
- en: 'As its name suggests, `bpftrace` can attach to tracing (also known as perf-related)
    events, including kprobes, uprobes, and tracepoints. For example, you can list
    the available tracepoints and kprobes on a machine with the `-l` option, like
    this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`bpftrace`可以附加到跟踪（也称为与性能相关的）事件，包括kprobe、uprobe和tracepoint。例如，您可以使用`-l`选项列出机器上可用的tracepoint和kprobe，就像这样：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example finds all the available attachment points that contain “execve.”
    From this output you can see that it’s possible to attach to a kprobe called `do_execve`.
    Here’s a `bpftrace` one-line script that attaches to that event:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例查找所有包含“execve”的可用附加点。从此输出中，您可以看到可以附加到名为`do_execve`的kprobe。以下是附加到该事件的`bpftrace`单行脚本：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `{ @[comm] = count(); }` part is the script attached to that event. This
    example keeps track of the number of times the event was triggered by different
    executables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ @[comm] = count(); }`部分是附加到该事件的脚本。此示例跟踪了由不同可执行文件触发该事件的次数。'
- en: 'Scripts for `bpftrace` can coordinate multiple eBPF programs attached to different
    events. For example, consider the [*opensnoop.bt* script](https://oreil.ly/3HWZ2)
    that reports on files being opened. Here is an extract:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftrace`的脚本可以协调附加到不同事件的多个eBPF程序。例如，考虑报告被打开文件的[*opensnoop.bt*脚本](https://oreil.ly/3HWZ2)。以下是摘录：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script defines two different eBPF programs, each attached to two different
    kernel tracepoints, at the entry to and exit from the `open()` and `openat()`
    syscalls.^([1](ch10.html#ch10fn1)) Both of these syscalls are used to open files
    and take a filename as an input argument. The program triggered by either flavor
    of syscall entry caches that filename, storing it in a map where the key is the
    current thread ID. When the exit tracepoint is hit, the cached filename is retrieved
    from this map by the `/@filename[tid]/` line in the script.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本定义了两个不同的eBPF程序，分别附加到两个不同的内核跟踪点，即进入和退出`open()`和`openat()`系统调用时。^([1](ch10.html#ch10fn1))这两个系统调用都用于打开文件，并将文件名作为输入参数。由任一系统调用进入触发的程序会缓存该文件名，并将其存储在映射中，其中键是当前线程ID。当触发退出跟踪点时，脚本中的`/@filename[tid]/`行将从该映射中检索缓存的文件名。
- en: 'Running this script generates output like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将生成如下输出：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve just told you there are four eBPF programs attached to tracepoints, so
    why does this output say there are six probes? The answer is that there are two
    “special probes” for the `BEGIN` and `END` clauses that the full version of this
    program includes to initialize and clean up the script (very similar to the awk
    language). I’ve omitted those clauses here for brevity, but you can find them
    in the [source code in GitHub](https://oreil.ly/X8wgW).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚告诉过你有四个eBPF程序附加到跟踪点，那么为什么这个输出中说有六个探针？答案是这里有两个“特殊探针”用于该程序的`BEGIN`和`END`子句，这类似于awk语言的完整版本。出于简洁起见，我在这里省略了这些子句，但你可以在[GitHub上的源代码中](https://oreil.ly/X8wgW)找到它们。
- en: 'If you’re using `bpftrace`, you don’t need to know about the underlying programs
    and maps, but for those of you who have read earlier chapters of this book, those
    concepts should be familiar to you by now. If you’re interested to see the programs
    and maps that are loaded in the kernel while a `bpftrace` program is running,
    you can easily do this with `bpftool` (just as you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)).
    Here’s the output I got while running *opensnoop.bt*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`bpftrace`，你不需要了解底层的程序和映射，但如果你已经阅读了本书的前几章，这些概念对你来说应该已经很熟悉了。如果你有兴趣查看在运行`bpftrace`程序时加载到内核中的程序和映射，你可以轻松使用`bpftool`来完成（就像你在[第三章](ch03.html#anatomy_of_an_ebpf_program)中看到的那样）。这是我在运行*opensnoop.bt*时得到的输出：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can clearly see the four tracepoint programs, plus the hash map that’s used
    for caching the filenames and the `perf_event_array` that is being used to pass
    output data from kernel to user space.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到四个跟踪点程序，以及用于缓存文件名的哈希映射和用于将内核输出数据传递到用户空间的`perf_event_array`。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `bpftrace` utility is built on top of BCC, which you met elsewhere in this
    book and which I’ll cover later in this chapter. `bpftrace` scripts get converted
    into BCC programs, which are then compiled at runtime using the LLVM/Clang toolchain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftrace`实用程序是建立在BCC之上的，你在本书的其他地方也遇到过，并且我将在本章后面进行详细介绍。`bpftrace`脚本被转换为BCC程序，然后使用LLVM/Clang工具链在运行时编译。'
- en: If you want command-line tools for eBPF-based performance measurement, you may
    well find that your needs are met using [`bpftrace`](https://oreil.ly/u5FrJ).
    But although `bpftrace` can be a powerful tool for using eBPF for tracing, it
    doesn’t open up the full range of possibilities that eBPF enables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用基于eBPF的性能测量的命令行工具，你可能会发现[`bpftrace`](https://oreil.ly/u5FrJ)能够满足你的需求。但尽管`bpftrace`可以成为利用eBPF进行跟踪的强大工具，它并未打开eBPF能够实现的所有可能性。
- en: To unlock the full potential of eBPF, you’ll need to directly write eBPF programs
    yourself for the kernel and also handle the user space part. These two aspects
    can, and often are, written in entirely different languages. Let’s start with
    the choices for eBPF code that runs in the kernel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分发挥eBPF的潜力，你需要直接为内核编写eBPF程序，还需要处理用户空间部分。这两个方面通常可以用完全不同的语言编写。让我们从运行在内核中的eBPF代码的选择开始。
- en: Language Choices for eBPF in the Kernel
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核中的eBPF语言选择
- en: eBPF programs can be written directly in eBPF bytecode,^([2](ch10.html#ch10fn2))
    but in practice, most are compiled to bytecode from either C or Rust. These languages
    have compilers that support eBPF bytecode as a target output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序可以直接用eBPF字节码编写，^([2](ch10.html#ch10fn2))但在实践中，大多数情况下是从C或Rust编译为字节码。这些语言的编译器支持将eBPF字节码作为目标输出。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: eBPF bytecode isn’t a suitable target for all compiled languages. If the language
    involves a runtime component (like Go, or Java’s virtual machine), it’s likely
    to be incompatible with eBPF’s verifier. For example, it’s hard to imagine how
    memory garbage collection could work hand in hand with the verifier’s checks on
    safe use of memory. Similarly, eBPF programs are required to be single threaded,
    so any concurrency features in a language couldn’t be used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF字节码并不适合所有编译语言。如果语言涉及运行时组件（如Go或Java的虚拟机），它可能与eBPF的验证器不兼容。例如，很难想象内存垃圾回收如何与验证器对内存安全使用的检查协同工作。同样，eBPF程序必须是单线程的，因此语言中的任何并发特性都无法使用。
- en: Although not really eBPF, there is an interesting project called [XDPLua](https://oreil.ly/7_3Fx)
    that proposes writing XDP programs in Lua scripts that run directly within the
    kernel. However, the initial research in this project suggested that eBPF would
    likely be more performant, and as eBPF becomes more powerful with each kernel
    release (e.g., now being able to implement loops), it’s not clear that there is
    much advantage other than the personal preference that some people might have
    to write code in Lua scripts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不完全是eBPF，但有一个有趣的项目叫做[XDPLua](https://oreil.ly/7_3Fx)，提议使用Lua脚本在内核中直接运行XDP程序。然而，该项目的初步研究表明，eBPF可能更具性能，随着每个内核版本发布，eBPF变得越来越强大（例如现在能够实现循环），并不清楚除了个人偏好外是否有其他优势。
- en: I would hazard a guess that most people who choose to write eBPF kernel code
    in Rust would also opt for the same language for the user space code, since shared
    data structures wouldn’t need to be rewritten. It’s not obligatory, though—you
    can mix and match eBPF code with whatever user space language you choose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢猜测，大多数选择用Rust编写eBPF内核代码的人也会选择同样的语言编写用户空间代码，因为共享数据结构不需要重新编写。当然，这并非强制性的——你可以将eBPF代码与任何你选择的用户空间语言混合使用。
- en: Those who choose to write the kernel-side code in C also have the option to
    write user space code in C (you’ve seen plenty of examples of that in this book
    already). But C is a pretty low-level language that requires programmers to handle
    lots of details for themselves, notably, memory management. While some people
    are comfortable doing this, many people would prefer to write the user space code
    in another, higher-level language. Whatever your preferred language, you’d like
    a library that provides eBPF support so that you don’t have to write directly
    to the system call interface you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    In the rest of this chapter we’ll discuss some of the most popular options for
    eBPF libraries in a variety of languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那些选择用C语言编写内核端代码的人也可以选择在用户空间用C语言编写代码（本书中已有多个例子）。但是C语言是一种相当底层的语言，需要程序员自己处理许多细节，特别是内存管理。虽然有些人能够轻松应对这些，但许多人更愿意用另一种更高级的语言编写用户空间代码。无论你偏爱哪种语言，你都希望有一个提供eBPF支持的库，这样你就不必直接写系统调用接口了（你在[第3章](ch03.html#anatomy_of_an_ebpf_program)看到过）
    。在本章的其余部分，我们将讨论一些流行的eBPF库选项，涵盖多种语言。
- en: BCC Python/Lua/C++
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BCC Python/Lua/C++
- en: Back in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor), the
    first “Hello World” example I gave you was a Python program written using the
    BCC library. This project includes plenty of useful performance measurement tools
    implemented using this same library (as well as newer implementations based on
    *libbpf* that I’ll come to momentarily).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)，我给你的第一个“Hello World”示例是使用BCC库编写的Python程序。该项目包括许多有用的性能测量工具，使用了同一库（以及稍后我将介绍的基于*libbpf*的新实现）。
- en: In addition to the [documentation](https://oreil.ly/Elggv) that describes how
    to use the provided BCC tools to measure performance, BCC also includes a [reference
    guide](https://oreil.ly/WgeJA) and a [Python programming tutorial](https://oreil.ly/hR3xr)
    to help you develop your own eBPF tools in this framework.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了描述如何使用提供的BCC工具来测量性能的[文档](https://oreil.ly/Elggv)，BCC还包括一个[参考指南](https://oreil.ly/WgeJA)和一个[Python编程教程](https://oreil.ly/hR3xr)，帮助您在这个框架中开发自己的eBPF工具。
- en: '[Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf) included a discussion
    of BCC’s approach to portability, which is to compile the eBPF code at runtime
    to ensure that it’s compatible with the target machine’s kernel data structures.
    In BCC, you define the kernel-side eBPF program code as a string (or the contents
    of a file that BCC reads into a string). This string gets passed to Clang for
    compilation, but before that happens, BCC does some preprocessing on the string.
    This enables it to provide handy shortcuts for the programmer, some of which you’ve
    seen already in this book. For example, here are some relevant lines from the
    example code in *chapter2/hello_map.py*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](ch05.html#co_recomma_btfcomma_and_libbpf) 讨论了 BCC 在可移植性方面的方法，即在运行时编译
    eBPF 代码，以确保其与目标机器的内核数据结构兼容。在 BCC 中，您将内核端 eBPF 程序代码定义为字符串（或 BCC 读入字符串的文件内容）。该字符串被传递给
    Clang 进行编译，但在此之前，BCC 对字符串进行了一些预处理。这使其能够为程序员提供方便的快捷方式，其中一些已经在本书中看到了。例如，以下是来自 *chapter2/hello_map.py*
    示例代码的相关行：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#code_id_10_1)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_1)'
- en: This is a Python program, which will run in user space.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行在用户空间的 Python 程序。
- en: '[![2](assets/2.png)](#code_id_10_2)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_2)'
- en: The `program` string holds the eBPF program to be compiled and then loaded into
    the kernel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`program` 字符串包含要编译并加载到内核中的 eBPF 程序。'
- en: '[![3](assets/3.png)](#code_id_10_3)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_3)'
- en: '`BPF_RINGBUF_OUTPUT` is a BCC macro that defines a ring buffer called `output`.
    This is part of the `program` string, so it’s natural to assume it’s defining
    the buffer from the kernel’s perspective. Hold that thought until we get to callout
    6.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_RINGBUF_OUTPUT` 是一个 BCC 宏，用于定义名为 `output` 的环形缓冲区。这是 `program` 字符串的一部分，因此可以自然地认为它从内核的角度定义了缓冲区。在我们到达
    callout 6 之前，请暂时保留这个想法。'
- en: '[![4](assets/4.png)](#code_id_10_4)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_4)'
- en: This line looks like a `ringbuf_output()` method on an object called `object`.
    But wait a minute—methods on objects aren’t even part of the C language! BCC is
    doing some heavy lifting here, [expanding methods](https://oreil.ly/vLVth) like
    these into underlying BPF helper functions, `bpf_ringbuf_output()` in this case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此行看起来像是 `object` 对象上的 `ringbuf_output()` 方法。但等一下 —— 对象的方法甚至不是 C 语言的一部分！BCC 在这里进行了一些繁重的工作，像这样扩展方法到底层的
    BPF 助手函数，例如在这种情况下是 `bpf_ringbuf_output()`。
- en: '[![5](assets/5.png)](#code_id_10_5)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_10_5)'
- en: This is where the program string gets rewritten into the BPF C code that Clang
    can compile. This line also loads the resultant program into the kernel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序字符串被重写为 Clang 可以编译的 BPF C 代码的地方。这行还将结果程序加载到内核中。
- en: '[![6](assets/6.png)](#code_id_10_6)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_10_6)'
- en: There is no other place in the code that defines the ring buffer called `output`,
    and yet it’s accessible from the Python user space code here. BCC does double
    duty when it preprocesses the line in callout 3, as it defines the ring buffer
    for both the user space and kernel parts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中没有定义名为`output`的环形缓冲区的其他位置，但在此处的Python用户空间代码中可以访问它。在调用 3 中，BCC 在预处理行时起到了双重作用，因为它为用户空间和内核部分都定义了环形缓冲区。
- en: As this example shows, BCC essentially provides its own C-like language for
    BPF programming. It makes life easy for the programmer, handling things like shared
    structure definitions for both kernel and user space and providing convenient
    shortcuts to wrap around BPF helper functions. This means BCC is an accessible
    way to get into eBPF programming if you’re new to the field, especially if you’re
    already comfortable with Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，BCC 实际上为 BPF 编程提供了自己的类似 C 的语言。它为程序员简化了生活，处理了诸如共享结构定义（供内核和用户空间使用）等事务，并提供了方便的快捷方式来包装
    BPF 助手函数。这意味着如果您对 Python 已经感到满意，那么 BCC 是进入 eBPF 编程的一种可访问方式，尤其是如果您对该领域还不熟悉的话。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’d like to explore BCC programming, this [tutorial aimed at Python programmers](https://oreil.ly/0pHKY)
    is a great way to walk through many more of the features and capabilities of BCC
    than there is space for in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索 BCC 编程，这个[面向 Python 程序员的教程](https://oreil.ly/0pHKY)是了解 BCC 的更多特性和能力的好方法，比本书所能包含的内容要多得多。
- en: The documentation doesn’t make it terribly clear, but as well as supporting
    Python as the language for the user space part of eBPF tools, BCC enables writing
    tools in Lua and C++. There are *lua* and *cpp* directories within the supplied
    [examples](https://oreil.ly/PP0cL) that you can base your own code on, should
    you be keen to try this approach.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文档并没有非常清楚，但除了支持Python作为eBPF工具用户空间的语言外，BCC还支持用Lua和C++编写工具。如果你有兴趣尝试这种方法，提供的[示例](https://oreil.ly/PP0cL)中有*lua*和*cpp*目录，你可以基于它们编写自己的代码。
- en: BCC may be convenient for the programmer, but because of the inefficiencies
    of distributing a compiler toolchain alongside your utility (discussed in more
    depth in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf)), if you’re looking
    to write production-quality tools that you intend to distribute, I recommend considering
    some of the other libraries discussed in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: BCC对程序员来说可能很方便，但由于在你的实用程序旁边分发编译器工具链的低效率（在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中更深入讨论），如果你打算编写可分发的生产质量工具，我建议考虑本章讨论的其他一些库。
- en: C and Libbpf
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和Libbpf
- en: You’ve seen lots of examples in this book of eBPF programs written in C, using
    the LLVM toolchain to compile into eBPF bytecode. You’ve also seen that extensions
    were added to support BTF and CO-RE. Many C programmers will also be familiar
    with the other major C compiler, GCC, and will be happy to hear that [GCC from
    version 10](https://oreil.ly/XAzxP) also supports compiling to eBPF as a target;
    however, there are still some gaps compared with the functionality provided in
    LLVM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中已经看到了很多用C编写的eBPF程序的示例，使用LLVM工具链编译成eBPF字节码。你还看到了添加了支持BTF和CO-RE的扩展。许多C程序员也熟悉另一种主要的C编译器GCC，并且将很高兴听到，从版本10开始，[GCC也支持编译为eBPF目标](https://oreil.ly/XAzxP)；然而，与LLVM提供的功能相比，仍然存在一些差距。
- en: As you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), CO-RE and
    *libbpf* enabled an approach to portable eBPF programming that doesn’t require
    shipping a compiler toolchain alongside every eBPF tool. The BCC project took
    advantage of this and, in addition to the original set of BCC performance tracing
    tools, it now has versions of these tools rewritten to take advantage of *libbpf*.
    The general consensus is that the versions of the BCC tools that have been rewritten
    based on *libbpf* are the better option to use, since they have a significantly
    lower memory footprint^([3](ch10.html#ch10fn3)) and don’t involve a start-up delay
    while the compilation step takes place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中看到的那样，CO-RE和*libbpf*实现了一种便携式eBPF编程的方法，不需要在每个eBPF工具旁边附带编译器工具链。BCC项目利用了这一点，并且除了最初的一套BCC性能跟踪工具之外，现在还有这些工具的版本重写以利用*libbpf*。普遍的共识是，基于*libbpf*重写的BCC工具版本是更好的选择，因为它们具有显著更低的内存占用^([3](ch10.html#ch10fn3))，并且不涉及在编译步骤进行时的启动延迟。
- en: If you’re comfortable with programming in C, using *libbpf* can make a lot of
    sense. You’ve seen lots of examples of this already in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C编程，使用*libbpf*会非常合理。在本书的多个示例中已经看到了很多这样的例子。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To write your own *libbpf* programs in C, the best place to start (now that
    you have read this book!) is [*libbpf-bootstrap*](https://oreil.ly/4mx81). Read
    Andrii Nakryiko’s [blog post about it](https://oreil.ly/-OW8v) as a good introduction
    to the motivations behind this project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要用C编写你自己的*libbpf*程序，现在（现在你已经读完本书！）最好的起点是[*libbpf-bootstrap*](https://oreil.ly/4mx81)。阅读Andrii
    Nakryiko的[关于该项目的博客文章](https://oreil.ly/-OW8v)，作为该项目背后动机的良好介绍。
- en: 'There’s also a library called [*libxdp*](https://oreil.ly/374mL) that builds
    on *libbpf* to allow for easier development and management of XDP programs. This
    is part of xdp-tools, which also holds one of my favorite learning resources for
    eBPF programming: the [XDP Tutorial](https://oreil.ly/E6dvl).^([4](ch10.html#ch10fn4))'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个名为[*libxdp*](https://oreil.ly/374mL)的库，它建立在*libbpf*之上，以便更轻松地开发和管理XDP程序。这是xdp-tools的一部分，该工具集还包含我喜欢的eBPF编程学习资源之一：[XDP教程](https://oreil.ly/E6dvl)。^([4](ch10.html#ch10fn4))
- en: But C is quite a challenging, low-level language. C programmers have to take
    responsibility for things like memory management and buffer handling, and it’s
    very easy to end up writing code with security vulnerabilities, not to mention
    crashes due to mishandling pointers. The eBPF verifier helps out on the kernel
    side, but there is no equivalent protection for your user space code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 C 是一门相当具有挑战性的低级语言。C 程序员必须对内存管理和缓冲区处理等事项负责，并且很容易因为处理指针不当而导致编写具有安全漏洞的代码，更不用说由于这些问题而导致崩溃。eBPF
    验证器在内核端有所帮助，但对于用户空间代码没有类似的保护机制。
- en: The good news is that there are libraries for other programming languages that
    interface to *libbpf*, or provide similar relocation functionality to allow for
    portable eBPF programs. Here are a few of the most popular ones.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，还有其他编程语言的库与 *libbpf* 接口，或提供类似重定位功能，以便于可移植的 eBPF 程序。以下是一些最流行的库。
- en: Go
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go
- en: The Go language has been widely adopted for infrastructure and cloud native
    tooling, so it’s natural that there should be options for writing eBPF code in
    it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言已被广泛应用于基础设施和云原生工具，因此在其中编写 eBPF 代码是很自然的选择。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[This article by Michael Kashin](https://oreil.ly/s9umt) provides another perspective
    comparing different eBPF libraries for Go.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[Michael Kashin 的这篇文章](https://oreil.ly/s9umt) 提供了比较不同 Go eBPF 库的另一视角。'
- en: Gobpf
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gobpf
- en: Possibly the first serious Golang implementation was the [gobpf](https://oreil.ly/pC0dF)
    project that sits alongside BCC as part of Iovisor. However, it hasn’t been actively
    maintained for a while, and as I write this, there’s some [discussion of deprecating
    it](https://oreil.ly/MnE79), so bear this in mind when making your library choice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可能第一个严肃的 Golang 实现是 [gobpf](https://oreil.ly/pC0dF) 项目，作为 Iovisor 的一部分与 BCC
    并列。然而，它已经有一段时间没有得到积极维护，在我写作此文时，有一些 [讨论计划弃用它](https://oreil.ly/MnE79)，因此在选择库时请记住这一点。
- en: Ebpf-go
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ebpf-go
- en: The [eBPF Go library included as part of the Cilium project](https://oreil.ly/BnGyl)
    is widely used (I found around 10,000 references on GitHub, and the project has
    close to 4,000 stars). It provides convenient functions for managing and loading
    eBPF programs and maps, including CO-RE support, all implemented purely in Go.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cilium 项目的一部分，包含的 eBPF Go 库](https://oreil.ly/BnGyl) 被广泛使用（我在 GitHub 上找到约
    10,000 个引用，并且该项目接近 4,000 个星）。它提供了方便的函数来管理和加载 eBPF 程序和映射，包括 CO-RE 支持，全部纯 Go 实现。'
- en: With this library you have the option to compile your eBPF programs to bytecode
    and embed that bytecode into Go source code, using a supplied tool called [bpf2go](https://oreil.ly/-kDbH).
    You need the LLVM/Clang compiler to do this generation as part of the build step.
    Once the Go code is compiled, you have a single Go binary that you can distribute
    that includes the eBPF bytecode and is portable to different kernels, without
    any dependencies other than the Linux kernel itself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此库，您可以选择将您的 eBPF 程序编译为字节码，并将该字节码嵌入到 Go 源代码中，使用名为 [bpf2go](https://oreil.ly/-kDbH)
    的提供的工具。在构建步骤中，您需要 LLVM/Clang 编译器来生成此字节码。一旦 Go 代码编译完成，您将得到一个单一的 Go 二进制文件，其中包含 eBPF
    字节码，并且可以在不同内核之间进行移植，除了 Linux 内核本身之外没有任何依赖项。
- en: The *cilium/ebpf* library also supports loading and managing eBPF programs built
    as standalone ELF files (like the **.bpf.o* examples you have seen in this book).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*cilium/ebpf* 库还支持加载和管理构建为独立 ELF 文件的 eBPF 程序（例如您在本书中看到的 **.bpf.o** 示例）。'
- en: At the time of this writing, the *cilium/ebpf* library supports the perf events
    for tracing, including the relatively recent fentry events, as well as an extensive
    set of network program types like XDP and cgroup socket attachments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，*cilium/ebpf* 库支持用于跟踪的 perf 事件，包括比较新的 fentry 事件，以及一系列广泛的网络程序类型，如 XDP
    和 cgroup 套接字附加。
- en: 'In this project’s [*examples* directory under *cilium/ebpf*](https://oreil.ly/Vuf9d),
    you’ll see that the C code for in-kernel programs sits in the same directories
    as the corresponding user space code in Go:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目的 [*cilium/ebpf* 目录下的 *examples* 目录中](https://oreil.ly/Vuf9d)，您会看到内核程序的
    C 代码与相应的 Go 用户空间代码位于相同的目录中：
- en: The C files start with `// +build ignore`, which tells the Go compiler to ignore
    them. At the time of this writing there is an [update in progress](https://oreil.ly/ymuyn)
    to change to the newer `//go:build` style of build tag.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 文件以 `// +build ignore` 开头，告诉 Go 编译器忽略它们。在撰写本文时，正在进行一个 [更新](https://oreil.ly/ymuyn)，以改用更新的
    `//go:build` 样式的构建标签。
- en: 'The user space files include a line like the following, which tells the Go
    compiler to invoke the bpf2go tool on the C file(s):'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间文件包括如下一行，告诉Go编译器在C文件上调用bpf2go工具：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running `go:generate` on the package rebuilds the eBPF program and regenerates
    the skeleton in a single step.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行`go:generate`命令对包进行重建，以一步完成eBPF程序的重新生成和骨架的更新。
- en: Much like `bpftool gen skeleton`, which you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    `bpf2go` generates skeleton code for manipulating the eBPF objects, minimizing
    the user space code you need to write yourself (except it’s generating Go code
    rather than C). The output files also include the *.o* object files containing
    the bytecode.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`bpftool gen skeleton`，您在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中看到的，`bpf2go`为操作eBPF对象生成骨架代码，减少了您需要自己编写的用户空间代码（不过它生成的是Go代码而不是C代码）。输出文件还包括包含字节码的*.o*对象文件。
- en: 'In fact, `bpf2go` generates two versions of the bytecode *.o* files, for big-
    and little-endian architectures. There are also two correspondingly generated
    *.go* files, and the correct versions for the target platform get used at compile
    time. As an example, the auto-generated files in the [kprobe example from *cilium/ebpf*](https://oreil.ly/CgwVd)
    are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`bpf2go`生成了字节码的*.o*文件的两个版本，用于大端和小端架构。还有两个相应生成的*.go*文件，在编译时根据目标平台选择正确的版本。例如，在[*cilium/ebpf*中的kprobe示例](https://oreil.ly/CgwVd)中自动生成的文件包括：
- en: The *bpf_bpfeb.o* and *bpf_bpfel.o* ELF files containing eBPF bytecode
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含eBPF字节码的*bpf_bpfeb.o*和*bpf_bpfel.o* ELF文件
- en: The *bpf_bpfeb.go* and *bpf_bpfel.go* files, which define Go structures and
    functions that correspond to the maps, programs, and links defined in that bytecode
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bpf_bpfeb.go*和*bpf_bpfel.go*文件定义了对应于字节码中定义的映射、程序和链接的Go结构和函数。'
- en: 'You can relate the objects defined in the auto-generated Go code to the C code
    from which it was generated. Here are the objects defined in the C code for that
    kprobe example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将自动生成的Go代码中定义的对象与生成它的C代码相关联。以下是为该kprobe示例中的C代码定义的对象：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The auto-generated Go code includes structures representing all the maps and
    programs (in this case, there is only one of each):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的Go代码包括表示所有映射和程序的结构（在本例中只有一个映射和一个程序）：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The names “KprobeMap” and “KprobeExecve” are derived from the map and program
    names used in the C code. These objects are grouped into a `bpfObjects` structure
    representing everything that’s being loaded into the kernel:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 名称“KprobeMap”和“KprobeExecve”源自用于C代码中的映射和程序名称。这些对象被分组到一个`bpfObjects`结构中，代表着加载到内核中的所有内容：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then use these object definitions and related auto-generated functions
    in your user space Go code. To give you an idea of what this might involve, here’s
    an extract based on the main function from the same [kprobe example](https://oreil.ly/YXAjH)
    (omitting error handling for brevity):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在用户空间的Go代码中使用这些对象定义和相关的自动生成函数。为了让您了解可能涉及的内容，这里有一个基于相同[kprobe示例](https://oreil.ly/YXAjH)主函数的摘录（为简洁起见省略了错误处理）：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#code_id_10_7)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_7)'
- en: Load all the BPF objects that were embedded in bytecode form, into the `bpfObjects`
    I just showed you defined by the auto-generated code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有以字节码形式嵌入的BPF对象加载到`bpfObjects`中，刚才我向您展示了由自动生成的代码定义的内容。
- en: '[![2](assets/2.png)](#code_id_10_8)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_8)'
- en: Attach the program to the `sys_execve` kprobe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序附加到`sys_execve` kprobe上。
- en: '[![3](assets/3.png)](#code_id_10_9)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_9)'
- en: Set up a ticker so that the code can poll the map once per second.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个定时器，以便代码每秒钟轮询映射。
- en: '[![4](assets/4.png)](#code_id_10_10)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_10)'
- en: Read an item out of the map.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从映射中读取一个项目。
- en: There are several other examples in the *cilium/ebpf* directory that you can
    use for reference and inspiration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*cilium/ebpf*目录中还有其他几个示例，可以用作参考和灵感。
- en: Libbpfgo
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Libbpfgo
- en: The [*libbpfgo* project](https://oreil.ly/gvbXr) by Aqua Security implements
    a Go wrapper around *libbpf*’s C code, providing utilities for loading and attaching
    programs and using Go-native features like channels for receiving events. Because
    it’s built on *libbpf*, it supports CO-RE.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[*libbpfgo*项目](https://oreil.ly/gvbXr)由Aqua Security实现了围绕*libbpf*的C代码的Go包装器，提供了加载和附加程序的实用工具，并使用Go本地特性（如通道）接收事件。因为它构建在*libbpf*上，所以支持CO-RE。'
- en: 'Here’s an extract from the example from *libbpfgo*’s *README*, which gives
    a good high-level view of what to expect from this library:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从*libbpfgo*的*README*中的示例摘录，它很好地高层次地展示了这个库的预期效果：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#code_id_10_11)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_11)'
- en: Read eBPF bytecode from an object file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象文件中读取eBPF字节码。
- en: '[![2](assets/2.png)](#code_id_10_12)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_12)'
- en: Load that bytecode into the kernel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段字节码加载到内核中。
- en: '[![3](assets/3.png)](#code_id_10_13)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_13)'
- en: Manipulate an entry in an eBPF map.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵eBPF映射中的条目。
- en: '[![4](assets/4.png)](#code_id_10_14)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_14)'
- en: Go programmers will appreciate receiving data from a ring or perf buffer on
    a channel, which is a language feature designed to handle asynchronous events.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序员将喜欢通过通道从环或性能缓冲区接收数据，这是一种处理异步事件的语言特性。
- en: This library was created for Aqua’s [Tracee](https://oreil.ly/A03zd) security
    project, and it’s also being used by other projects such as [Parca](https://oreil.ly/s8JP9)
    from Polar Signals, which provides eBPF-based CPU profiling. The only concern
    about this project’s approach is the CGo boundary between the *libbpf* C code
    and Go, which can cause performance and other issues.^([5](ch10.html#ch10fn5))
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是为Aqua的[Tracee](https://oreil.ly/A03zd)安全项目创建的，也被其他项目如Polar Signals的[Parca](https://oreil.ly/s8JP9)所使用，它提供基于eBPF的CPU性能分析。对于这个项目的一个关注点是*libbpf*
    C代码和Go之间的CGo边界可能会引起性能和其他问题^([5](ch10.html#ch10fn5))。
- en: While Go has been the established language for lots of infrastructure coding
    for around a decade, there has more recently been a growing body of developers
    who prefer to use Rust.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在过去十年中，Go语言一直是许多基础设施编码的首选语言，但最近有越来越多的开发者更倾向于使用Rust。
- en: Rust
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust
- en: Rust is increasingly being used for building infrastructure tools. It allows
    for the low-level access of C, but with the added benefit of memory safety. Indeed,
    Linus Torvalds [confirmed in 2022](https://oreil.ly/7fINA) that the Linux kernel
    itself will start to incorporate Rust code, and the recent [6.1 release has some
    initial Rust support](https://oreil.ly/HrXy2).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Rust在构建基础设施工具方面的使用越来越广泛。它允许像C语言一样进行低级别访问，但又具有内存安全性的附加好处。确实，Linus Torvalds在2022年[确认](https://oreil.ly/7fINA)，Linux内核本身将开始整合Rust代码，最近的[6.1版本已经开始支持Rust](https://oreil.ly/HrXy2)。
- en: As I discussed earlier in this chapter, Rust can be compiled to eBPF bytecode,
    meaning that (with the right library support) it’s possible to write both the
    user space and kernel code for eBPF utilities in Rust.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章前面讨论的那样，Rust可以编译成eBPF字节码，这意味着（通过正确的库支持）可以用Rust编写eBPF实用程序的用户空间和内核代码。
- en: 'There are a few options for Rust eBPF development: *libbpf-rs*, *Redbpf*, and
    Aya.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Rust eBPF开发，有几个选择：*libbpf-rs*，*Redbpf*和Aya。
- en: Libbpf-rs
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Libbpf-rs
- en: '[*Libbpf-rs*](https://oreil.ly/qBagk) is part of the *libbpf* project, and
    provides a Rust wrapper around the *libbpf* C code so that you can write the user
    space parts of eBPF code in Rust. As you can see from the project’s [examples](https://oreil.ly/6wpf8),
    the eBPF programs themselves are written in C.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Libbpf-rs*](https://oreil.ly/qBagk)是*libbpf*项目的一部分，提供了围绕*libbpf* C代码的Rust包装器，使您可以用Rust编写eBPF代码的用户空间部分。正如您可以从该项目的[示例](https://oreil.ly/6wpf8)中看到的那样，eBPF程序本身是用C语言编写的。'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are further examples in Rust in the [*libbpf-bootstrap*](https://oreil.ly/ter6c)
    project, designed to help you get off the ground if you want to try building your
    own code using this crate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*libbpf-bootstrap*](https://oreil.ly/ter6c)项目中还有更多的Rust示例，旨在帮助您开始构建自己的代码。
- en: This crate is helpful for incorporating eBPF programs into a Rust-based project,
    but it doesn’t fulfill the desire that many people have to write the kernel-side
    code in Rust as well. Let’s look at some other projects that enable that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个crate对于将eBPF程序整合到基于Rust的项目中很有帮助，但它不能满足许多人希望在内核端用Rust编写代码的愿望。让我们看看其他一些支持这一功能的项目。
- en: Redbpf
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redbpf
- en: '[*Redbpf*](https://oreil.ly/AtJod) is a set of Rust crates that interface with
    *libbpf*, developed as part of [foniod](https://oreil.ly/dwGNK), an eBPF-based
    security monitoring agent.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Redbpf*](https://oreil.ly/AtJod)是一组与*libbpf*接口的Rust包，作为[eBPF](https://oreil.ly/dwGNK)安全监控代理的一部分进行开发。'
- en: '*Redbpf* predates Rust’s ability to compile to eBPF bytecode, so it uses a
    [multistep compilation process](https://oreil.ly/DuHxE) that involves compiling
    from Rust to LLVM bitcode and then using the LLVM toolchain to generate eBPF bytecode
    in ELF format. *Redbpf* supports a range of program types including tracepoints,
    kprobes and uprobes, XDP, TC, and some socket events.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*Redbpf*在Rust能够编译成eBPF字节码之前就已存在，因此它使用一个[多步编译过程](https://oreil.ly/DuHxE)，包括从Rust编译到LLVM比特码，然后使用LLVM工具链生成eBPF字节码的ELF格式。*Redbpf*支持一系列程序类型，包括跟踪点、kprobes和uprobes、XDP以及一些套接字事件。'
- en: As the Rust compiler rustc gained the ability to generate eBPF bytecode directly,
    this was leveraged by a project called Aya. At the time of this writing, Aya is
    considered “emerging” according to the [community site at ebpf.io](https://oreil.ly/WynV6),
    while *Redbpf* is listed as a major project, but my personal perspective is that
    momentum seems to be moving toward Aya.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Rust 编译器 rustc 直接获得生成 eBPF 字节码的能力，这一能力被一个名为 Aya 的项目所利用。在撰写本文时，根据[ebpf.io
    社区网站](https://oreil.ly/WynV6)，Aya 被认为是“新兴”项目，而*Redbpf*被列为一个主要项目，但我个人认为动力似乎正在向
    Aya 方向发展。
- en: Aya
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aya
- en: '[Aya](https://aya-rs.dev/book) is built in Rust directly to the syscall level,
    so it doesn’t depend on *libbpf* (or indeed on BCC or the LLVM toolchain). But
    it does support the BTF format, the same relocations that *libbpf* does (as described
    in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf)), so it’s providing the
    same CO-RE abilities to compile once and run on other kernels. At the time of
    this writing, it supports a wider range of eBPF program types than *Redbpf*, including
    tracing/perf-related events, XDP and TC, cgroups, and LSM attachments.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[Aya](https://aya-rs.dev/book) 直接在 Rust 中构建到系统调用级别，因此它不依赖于*libbpf*（或者 BCC 或
    LLVM 工具链）。但它支持 BTF 格式，与*libbpf*相同的重定位（如[第 5 章](ch05.html#co_recomma_btfcomma_and_libbpf)中描述的），因此它提供了相同的
    CO-RE 能力，可以编译一次并在其他内核上运行。在撰写本文时，它支持比*Redbpf*更广泛的 eBPF 程序类型，包括跟踪/性能相关事件、XDP 和 TC、cgroups
    以及 LSM 附件。'
- en: As I mentioned, the Rust compiler also supports [compiling to eBPF bytecode](https://oreil.ly/a5q7M),
    so this language can be used for both kernel and user space eBPF programming.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，Rust 编译器也支持[编译为 eBPF 字节码](https://oreil.ly/a5q7M)，因此这种语言可以用于内核和用户空间的
    eBPF 编程。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to write both the kernel side and the user space side natively in
    Rust without the intermediate dependency on LLVM has attracted Rust programmers
    to this option. There’s an interesting [discussion on GitHub](https://oreil.ly/nls4l)
    about why the developers of the [lockc project](https://oreil.ly/_-L6z) (an eBPF-based
    project that enhances the security of container workloads using LSM hooks) decided
    to port their project from *libbpf-rs* to Aya.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 Rust 中原生编写内核端和用户空间端，而无需中间依赖于 LLVM，吸引了 Rust 程序员选择这个选项。关于为什么[lockc 项目](https://oreil.ly/_-L6z)的开发人员决定将他们的项目从
    *libbpf-rs* 迁移到 Aya 的有趣[讨论](https://oreil.ly/nls4l)在 GitHub 上进行。
- en: The project includes [aya-tool](https://oreil.ly/Kd0nf), a utility for generating
    Rust structure definitions that match kernel data structures so that you don’t
    have to write them yourself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包括 [aya-tool](https://oreil.ly/Kd0nf)，一个用于生成与内核数据结构匹配的 Rust 结构定义的实用程序，这样你就不必自己编写它们。
- en: The Aya project strongly emphasizes developer experience and makes it easy for
    newcomers to get started. With that in mind, the [“Aya book”](https://aya-rs.dev/book)
    is a very readable introduction with some good example code, annotated with helpful
    explanations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Aya 项目非常强调开发者体验，并且让新手很容易上手。考虑到这一点，[“Aya 书”](https://aya-rs.dev/book)是一个非常易读的介绍，附有一些很好的示例代码，并附有有用的解释。
- en: 'To give you a brief idea of what eBPF code looks like in Rust, here’s an extract
    from Aya’s basic XDP example that permits all traffic:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你简要了解 Rust 中的 eBPF 代码是什么样子，这里是 Aya 基本 XDP 示例的一部分，允许所有流量通过：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#code_id_10_15)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_15)'
- en: This line is what defines the section name, equivalent to `SEC("xdp/myapp")`
    in C.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行定义了部分名称，相当于 C 中的 `SEC("xdp/myapp")`。
- en: '[![2](assets/2.png)](#code_id_10_16)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_16)'
- en: The eBPF program called `myapp` calls the function `try_myapp` to process a
    network packet received at XDP.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `myapp` 的 eBPF 程序调用函数 `try_myapp` 来处理在 XDP 接收到的网络数据包。
- en: '[![3](assets/3.png)](#code_id_10_17)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_17)'
- en: The `try_myapp` function logs the fact that a packet was received and always
    returns the `XDP_PASS` value that tells the kernel to carry on processing the
    packet as usual.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_myapp` 函数记录了接收到数据包的事实，并始终返回`XDP_PASS`值，告诉内核继续按照通常方式处理数据包。'
- en: Just as we’ve seen in C-based examples throughout this book, the eBPF program
    gets compiled to an ELF object file. The difference is that Aya uses the Rust
    compiler instead of Clang to create that file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中看到的基于 C 的示例一样，eBPF 程序被编译为 ELF 对象文件。不同之处在于 Aya 使用 Rust 编译器而不是 Clang 来创建该文件。
- en: 'Aya also generates code for the user space activities of loading the eBPF program
    into the kernel and attaching it to an event. Here are a few key lines from the
    user space side of that same basic example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Aya 还为将 eBPF 程序加载到内核并将其附加到事件的用户空间活动生成代码。以下是该基本示例的用户空间关键行：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#code_id_10_19)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_19)'
- en: Read the eBPF bytecode from the ELF object file produced by the compiler.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译器生成的 ELF 对象文件中读取 eBPF 字节码。
- en: '[![2](assets/2.png)](#code_id_10_20)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_20)'
- en: Find the program called `myapp` in that bytecode.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查找名为 `myapp` 的程序的字节码。
- en: '[![3](assets/3.png)](#code_id_10_21)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_21)'
- en: Load it into the kernel.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将其加载到内核中。
- en: '[![4](assets/4.png)](#code_id_10_22)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_22)'
- en: Attach it to the XDP event on a specified network interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将其附加到指定网络接口上的 XDP 事件。
- en: If you’re a Rust programmer, I highly recommend you explore the [additional
    examples](https://oreil.ly/bp_Hq) in the “Aya book” in more detail. There’s also
    a nice [blog post from Kong](https://oreil.ly/mUVIk) that walks through writing
    an XDP load balancer using Aya.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Rust 程序员，我强烈建议你更详细地探索“Aya 书籍”中的[其他示例](https://oreil.ly/bp_Hq)。Kong 的[博客文章](https://oreil.ly/mUVIk)也很好地介绍了使用
    Aya 编写 XDP 负载均衡器。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Aya maintainers Dave Tucker and Alessandro Decina joined me for [episode 25
    of the “eBPF and Cilium Office Hours” livestream](https://oreil.ly/U7bRu) where
    they demonstrated and gave an introduction to eBPF programming with Aya.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Aya 的维护者 Dave Tucker 和 Alessandro Decina 在[“eBPF 和 Cilium 办公室时间”直播第 25 集](https://oreil.ly/U7bRu)中加入了我，他们演示并介绍了使用
    Aya 进行 eBPF 编程。
- en: Rust-bcc
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust-bcc
- en: '[Rust-bcc](https://oreil.ly/prP_K) provides Rust bindings that mimic the BCC
    project’s Python bindings, along with some Rust implementations of some of the
    BCC set of tracing [tools](https://oreil.ly/Dd2nO).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rust-bcc](https://oreil.ly/prP_K) 提供了模仿 BCC 项目 Python 绑定的 Rust 绑定，并附带一些 BCC
    跟踪工具的 Rust 实现。'
- en: Testing BPF Programs
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 BPF 程序
- en: There’s a `bpf()` command, [`BPF_PROG_RUN`](https://oreil.ly/Y2xPC), that allows
    for running an eBPF program from user space for test purposes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `bpf()` 命令，[`BPF_PROG_RUN`](https://oreil.ly/Y2xPC)，允许从用户空间运行 eBPF 程序进行测试。
- en: '`BPF_PROG_RUN` (currently) works only with a subset of BPF program types that
    are mostly networking related.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG_RUN`（目前）仅适用于大多数与网络相关的 BPF 程序类型。'
- en: 'You can also get information about eBPF program performance with some built-in
    statistics information. Run the following command to enable it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过一些内置统计信息获取有关 eBPF 程序性能的信息。运行以下命令以启用它：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will show additional information in `bpftool`’s output about programs,
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示`bpftool`的输出中关于程序的额外信息，例如：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The additional statistics are shown in bold, and here they show that the program
    has run four times, taking about 300 microseconds in total.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的统计信息显示为粗体，这里显示该程序已运行四次，总共大约耗时 300 微秒。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Learn more from Quentin Monnet’s FOSDEM 2020 talk titled [“Tools and mechanisms
    to debug BPF programs.”](https://oreil.ly/I5Jhd)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Quentin Monnet 的 FOSDEM 2020 演讲“工具和机制来调试 BPF 程序”中了解更多信息。
- en: Multiple eBPF Programs
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个 eBPF 程序
- en: 'An eBPF program is a function attached to an event in the kernel. Many applications
    need to track more than one event to achieve their goals. A simple example of
    this is opensnoop.^([6](ch10.html#ch10fn6)) I covered the `bpftrace` version of
    this early in this chapter, and you saw that it attaches BPF programs to four
    different syscall tracepoints:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 eBPF 程序是附加到内核中事件的函数。许多应用程序需要跟踪多个事件以实现其目标。这方面的一个简单示例是 opensnoop。^([6](ch10.html#ch10fn6))
    本章早期我介绍了 `bpftrace` 版本，并展示了它如何将 BPF 程序附加到四个不同的系统调用跟踪点上：
- en: '`syscall_enter_open`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_enter_open`'
- en: '`syscall_exit_open`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_exit_open`'
- en: '`syscall_enter_openat`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_enter_openat`'
- en: '`syscall_exit_openat`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_exit_openat`'
- en: These are the entry and exit points to the kernel’s handling of the `open()`
    and `openat()` system calls. These two system calls can be used for opening files,
    and the opensnoop tool tracks both of them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是内核处理 `open()` 和 `openat()` 系统调用的入口和出口点。这两个系统调用可用于打开文件，而 opensnoop 工具会跟踪这两个调用。
- en: But why does it need to track both entry and exit for these system calls? The
    entry points are used because that’s when the system call arguments are available,
    and these include the filename and any flags being passed to the `open[at]` syscall.
    But at that stage it’s too soon to know whether the file will be opened successfully
    or not. That explains why it’s necessary to have eBPF programs attached to the
    exit points too.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么需要同时跟踪这些系统调用的进入和退出呢？使用进入点是因为此时系统调用参数是可用的，这些参数包括要传递给`open[at]`系统调用的文件名和任何标志。但在这个阶段，还不知道文件是否会成功打开。这解释了为什么有必要在退出点也附加eBPF程序。
- en: If you look at the [*libbpf-tools* version of opensnoop](https://oreil.ly/IOty_),
    you’ll see there’s just one user space program, and it loads all four eBPF programs
    into the kernel and attaches them to their events. The eBPF programs themselves
    are essentially independent, but they use eBPF maps to coordinate among themselves.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看[*libbpf-tools*版本的opensnoop](https://oreil.ly/IOty_)，你会看到只有一个用户空间程序，它将所有四个eBPF程序加载到内核并将它们附加到它们的事件上。这些eBPF程序本身基本上是独立的，但它们使用eBPF映射来在彼此之间协调。
- en: A complex application might even need to add and remove eBPF programs dynamically
    throughout a long period of time. There may not even be a fixed number of eBPF
    programs for any given application. For example, Cilium attaches eBPF programs
    to each virtual networking interface, and in a Kubernetes environment these interfaces
    come and go depending on how many pods are running.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的应用程序中，甚至可能需要在很长一段时间内动态地添加和删除eBPF程序。对于任何给定的应用程序，甚至可能没有固定数量的eBPF程序。例如，Cilium将eBPF程序附加到每个虚拟网络接口上，在Kubernetes环境中，这些接口的存在与否取决于运行的Pod数量。
- en: Most of the libraries in this chapter handle this multiplicity of eBPF programs
    automatically. For example, *libbpf* and *ebpf-go* generate skeleton code that
    will load *all* the programs and maps from the bytecode in an object file or buffer
    in one function call. They also generate finer-granularity functions so that you
    can manipulate programs and maps individually.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数库都会自动处理这些eBPF程序的多样性。例如，*libbpf*和*ebpf-go*会生成加载所有程序和映射的骨架代码，这可以通过一个函数调用完成。它们还生成更细粒度的函数，以便你可以单独操作程序和映射。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The vast majority of people who use eBPF-based tooling won’t need to write eBPF
    code themselves, but if you do find yourself wanting to implement something yourself,
    you have a lot of options. This is a changing field, so it’s very possible that
    by the time you read this, new language libraries and frameworks might exist,
    or consensus may have gathered around some of the libraries I’ve highlighted in
    this chapter. You’ll find an up-to-date list of the major language projects around
    eBPF on the [Infrastructure page of ebpf.io’s list of significant projects](https://ebpf.io/infrastructure).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用基于eBPF的工具的人不需要自己编写eBPF代码，但如果你确实希望自己实现一些东西，你有很多选择。这是一个不断变化的领域，所以很可能在你阅读这篇文章时，会有新的语言库和框架存在，或者已经在一些我在本章中强调的库周围形成了共识。你可以在[ebpf.io重要项目列表的基础设施页面](https://ebpf.io/infrastructure)找到关于eBPF主要语言项目的最新列表。
- en: For quickly collecting trace information, `bpftrace` can be a very valuable
    option.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速收集跟踪信息，`bpftrace`可以是一个非常有价值的选择。
- en: For more flexibility and control, BCC is a fast way to build an eBPF tool if
    you’re comfortable with Python, provided that you don’t care about the compilation
    step that takes place at runtime.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更灵活和控制性更强的需求，如果你熟悉Python，并且不介意运行时发生的编译步骤，BCC是构建eBPF工具的快速方式。
- en: If you’re writing eBPF code to be widely distributed and portable across different
    kernel versions, you’ll probably want to take advantage of CO-RE. The user space
    frameworks that support CO-RE at time of this writing are *libbpf* for C, *cilium/ebpf*
    and *libbpfgo* for Go, and Aya for Rust.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写eBPF代码，希望在不同的内核版本间广泛分发和移植，你可能会想要利用CO-RE。目前支持CO-RE的用户空间框架有C语言的*libbpf*，Go语言的*cilium/ebpf*和*libbpfgo*，以及Rust语言的Aya。
- en: For further advice, I highly recommend joining the [eBPF Slack](http://ebpf.io/slack)
    and discussing your questions there. You’ll likely find the maintainers of many
    of these language libraries in that community.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进一步的建议，我强烈建议加入[eBPF Slack](http://ebpf.io/slack)，在那里讨论你的问题。你很可能会在这个社区找到许多这些语言库的维护者。
- en: Exercises
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'If you’d like to try one or more of the libraries discussed in this chapter,
    “Hello World” is always a good place to start:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试本章讨论的一个或多个库，那么“Hello World”总是一个很好的开始：
- en: Using one or more libraries of your choosing, write an example “Hello World”
    program that outputs a simple trace message.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的一个或多个库，编写一个“Hello World”程序，输出一个简单的跟踪消息。
- en: Use `llvm-objdump` to compare the bytecode produced with the “Hello World” example
    from [Chapter 3](ch03.html#anatomy_of_an_ebpf_program). You’ll find lots of similarities!
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`llvm-objdump`比较从[第3章](ch03.html#anatomy_of_an_ebpf_program)的“Hello World”示例生成的字节码。你会发现很多相似之处！
- en: As you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    you can use `strace -e bpf` to see when `bpf()` system calls are made. Try that
    on your “Hello World” program to see if it’s behaving as you expect.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到的那样，您可以使用`strace
    -e bpf`来查看何时进行`bpf()`系统调用。尝试在您的“Hello World”程序上执行此操作，看看它是否按预期行事。
- en: ^([1](ch10.html#ch10fn1-marker)) Being attached to syscall entry points means
    this script has the same Time Of Check To Time Of Use (TOCTOU) vulnerability discussed
    in the previous chapter. That doesn’t stop it from being a useful tool; it’s just
    that you shouldn’t rely on it as your only line of defense for security purposes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#ch10fn1-marker)) 附加到系统调用入口点意味着这个脚本具有与上一章讨论的TOCTOU（时间检查到使用时间）漏洞相同的漏洞。这并不能阻止它成为一个有用的工具；只是你不应该将其作为安全目的的唯一防线。
- en: ^([2](ch10.html#ch10fn2-marker)) For an example of this, check out Cloudflare’s
    blog post [“eBPF, Sockets, Hop Distance and manually writing eBPF assembly”](https://oreil.ly/2GjuK).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#ch10fn2-marker)) 例如，查看Cloudflare的博文[“eBPF，Sockets，Hop Distance
    and manually writing eBPF assembly”](https://oreil.ly/2GjuK)。
- en: ^([3](ch10.html#ch10fn3-marker)) See, for example, Brendan Gregg’s [observation](https://oreil.ly/fz_dQ)
    that the *libbpf*-based version of opensnoop required around 9 MB compared with
    80 MB for the Python-based version.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#ch10fn3-marker)) 例如，Brendan Gregg的[观察](https://oreil.ly/fz_dQ)显示，*libbpf*版本的opensnoop大约需要9
    MB，而基于Python的版本需要80 MB。
- en: ^([4](ch10.html#ch10fn4-marker)) Watch me working through some of the XDP Tutorial
    examples in [episode 13 of the eBPF and Cilium Office Hours” livestream](https://oreil.ly/9SaKn).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.html#ch10fn4-marker)) 在[第13集eBPF和Cilium办公时间的直播](https://oreil.ly/9SaKn)中，看我演示一些XDP教程示例。
- en: ^([5](ch10.html#ch10fn5-marker)) Dave Cheney’s 2016 post “[cgo is not Go](https://oreil.ly/mxThs)”
    remains a good overview of concerns related to the CGo boundary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#ch10fn5-marker)) 戴夫·陈尼在2016年的文章“[cgo is not Go](https://oreil.ly/mxThs)”仍然是对与CGo边界相关问题的很好概述。
- en: ^([6](ch10.html#ch10fn6-marker)) As well as the `bpftrace` version of this tool,
    there are equivalents in BCC and in *libbpf-tools*. They all do very much the
    same thing, generating a line of trace whenever a process opens a file. There’s
    a walkthrough of the eBPF code for BCC’s version of opensnoop in my report [“What
    Is eBPF?”](https://www.oreilly.com/library/view/what-is-ebpf/9781492097266).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch10.html#ch10fn6-marker)) 除了`bpftrace`版本的工具之外，在BCC和*libbpf-tools*中也有等效的工具。它们都做着相同的事情，每当一个进程打开文件时生成一行跟踪。在我的报告[“什么是eBPF？”](https://www.oreilly.com/library/view/what-is-ebpf/9781492097266)中有BCC版本opensnoop的eBPF代码演示。
