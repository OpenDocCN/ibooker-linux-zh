- en: Chapter 9\. eBPF for Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 eBPF 用于安全
- en: You’ve seen how eBPF can be used to observe events across a system and report
    information about those events to user space tools. In this chapter you’ll consider
    how to build on the concept of event detection to create eBPF-based security tools
    that can detect, or even prevent, malicious activity. I’ll start by helping you
    understand what makes security different from other types of observability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到eBPF如何用于观察系统中的事件，并向用户空间工具报告有关这些事件的信息。在本章中，您将考虑如何在事件检测的概念基础上构建基于eBPF的安全工具，以检测甚至预防恶意活动。我将从帮助您理解安全性与其他类型可观察性的不同之处开始。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Example code for this chapter is in the [GitHub repo](http://github.com/lizrice/learning-ebpf)
    in the *chapter9* directory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于[GitHub 仓库](http://github.com/lizrice/learning-ebpf)的 *chapter9* 目录中。
- en: Security Observability Requires Policy and Context
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全可观察性需要政策和上下文
- en: The difference between a security tool and an observability tool that reports
    on events is that a security tool needs to be able to distinguish between events
    that are expected under normal circumstances and events that suggest malicious
    activity might be taking place. For example, suppose you have an application that
    writes data to a local file as part of its normal processing. Let’s say the app
    is expected to write to */home/<username>/<filename>*, so this activity isn’t
    something you’re interested in from a security perspective. However, you would
    want to be notified if the app writes to one of the many sensitive file locations
    in Linux. For example, it is unlikely that it needs to modify the password information
    stored in */etc/passwd*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工具与报告事件的可观察性工具之间的区别在于，安全工具需要能够区分正常情况下预期的事件和表明可能存在恶意活动的事件。例如，假设您有一个应用程序作为正常处理的一部分向本地文件写入数据。假设该应用程序预计会写入
    */home/<用户名>/<文件名>*，因此这种活动从安全角度来看并不重要。然而，如果该应用程序写入Linux中的许多敏感文件位置之一，则您希望收到通知。例如，它不太可能需要修改
    */etc/passwd* 中存储的密码信息。
- en: Policies have to take into account not just normal behavior when systems are
    fully functional, but also the expected error path behavior. For example, if a
    physical disk gets full, the application might start sending network messages
    to alert about this situation. These network messages shouldn’t be seen as security
    events—even though they are unusual, they’re not suspicious. Taking error paths
    into account can make it challenging to create effective policies, and we’ll come
    back to that challenge later in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 政策必须考虑的不仅是系统完全正常运行时的正常行为，还包括预期的错误路径行为。例如，如果物理磁盘变满，应用程序可能会开始发送网络消息以警示此情况。这些网络消息不应被视为安全事件——尽管它们不寻常，但并不可疑。考虑错误路径可能会使创建有效政策变得具有挑战性，我们稍后在本章将回到这个挑战。
- en: Defining what is and isn’t expected behavior is the job of a policy. A security
    tool compares activity to a policy and takes some action when the activity is
    outside the policy, making it suspicious. That action would typically involve
    generating a security event log, which would usually get sent to a Security Information
    Event Management (SIEM) platform. It might also result in an alert to a human
    who will be called on to investigate what happened.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义预期行为与非预期行为是政策的工作。安全工具将活动与政策进行比较，并在活动超出政策范围时采取某些行动，使其具有可疑性。这种行动通常涉及生成安全事件日志，通常会发送到安全信息事件管理（SIEM）平台。这可能还会导致向需要调查发生情况的人员发送警报。
- en: The more contextual information that’s available to the investigator, the more
    likely they will be able to find out the root cause of the event and determine
    whether it was an attack, which components were affected, how and when the attack
    took place, and who was responsible. As illustrated in [Figure 9-1](#contextual_information_is_required_alon),
    being able to answer questions like this takes a tool from mere logging to deserving
    the nomenclature “security observability.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 调查员可用的上下文信息越多，他们就越有可能找出事件的根本原因，并确定它是否是攻击，哪些组件受到影响，攻击是如何进行的，以及谁负有责任。正如在[图 9-1](#contextual_information_is_required_alon)中所说明的那样，能够回答这类问题需要一种工具从仅仅是日志记录升级为应当被称为“安全可观察性”的命名。
- en: '![Contextual information is required alongside out-of-policy event detection
    for security observability](assets/lebp_0901.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Contextual information is required alongside out-of-policy event detection
    for security observability](assets/lebp_0901.png)'
- en: Figure 9-1\. Contextual information is required alongside out-of-policy event
    detection for security observability
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 安全可观察性的异常事件检测需要上下文信息
- en: Let’s explore some of the ways eBPF programs are being used to detect and enforce
    security events. As you know, eBPF programs can be attached to a variety of events,
    and one set of events that have been commonly used for security for many years
    are syscalls. We’ll start our discussion with syscalls, but as you’ll see, syscalls
    might not be the most effective way to implement security tooling with eBPF. We’ll
    see some newer and more sophisticated approaches later in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一些使用 eBPF 程序检测和执行安全事件的方法。如你所知，eBPF 程序可以附加到各种事件，多年来用于安全的一组事件之一是系统调用。我们将从系统调用开始讨论，但正如你将看到的，系统调用可能不是用
    eBPF 实现安全工具的最有效方式。稍后在本章中我们将看到一些更新和更复杂的方法。
- en: Using System Calls for Security Events
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统调用进行安全事件
- en: 'System calls (or syscalls) are the interface between user space applications
    and the kernel. If you can restrict the set of syscalls an app can make, that
    will limit what it is able to do. For example, if you stop an app from making
    syscalls in the `open*()` family, it won’t be able to open files. If you have
    an application that you never expect to open files, you might want to create this
    limitation so that even if the app gets compromised, it won’t be able to open
    files maliciously. If you’ve been using Docker or Kubernetes over the past few
    years, there is a very good chance you have already come across a security tool
    that uses BPF to limit syscalls: seccomp*.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用（或 syscalls）是用户空间应用程序与内核之间的接口。如果可以限制应用程序可以进行的系统调用集合，那将限制其能力。例如，如果阻止应用程序进行
    `open*()` 系列的系统调用，它将无法打开文件。如果有一个应用程序你从不希望打开文件，你可能希望创建这种限制，以便即使应用程序被入侵，它也无法恶意打开文件。如果你在过去几年中使用
    Docker 或 Kubernetes，那么你很有可能已经接触过使用 BPF 来限制系统调用的安全工具：seccomp*.*
- en: Seccomp
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Seccomp
- en: 'The name *seccomp* is a contraction of “SECure COMPuting.” In its original,
    or “strict,” form, seccomp is used to limit the set of syscalls a process can
    use to a very small subset: `read()`, `write()`, `_exit()`, and `sigreturn()`.
    The intention of this strict mode was to allow users to run untrusted code (perhaps
    a program downloaded from the internet) without any possibility of that code doing
    malicious things.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*seccomp* 的名称缩写自“SECure COMPuting”。在其原始或“严格”形式中，seccomp 用于将进程可以使用的系统调用集限制为非常小的子集：`read()`、`write()`、`_exit()`
    和 `sigreturn()`。这种严格模式的目的是允许用户运行不受信任的代码（也许是从互联网下载的程序），而不可能使该代码执行恶意操作。'
- en: Strict mode is very restrictive, and many applications need to use a much larger
    set of syscalls—but that doesn’t mean they need all 400 and more of them. It makes
    sense to allow a more flexible method for restricting the set that any given application
    can use. This is the reasoning behind the flavor of seccomp that most of us from
    the container world have encountered, which is more properly known as seccomp-bpf.
    Instead of having a fixed subset of syscalls that it permits, this mode of seccomp
    uses BPF code to filter the syscalls that are and aren’t allowed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式非常限制，许多应用程序需要使用更大的系统调用集，但这并不意味着它们需要全部 400 多个系统调用。允许更灵活的方法来限制任何给定应用程序可以使用的系统调用集是有道理的。这就是我们从容器世界大多数人遇到的
    seccomp 变种背后的推理，更确切地说是称为 seccomp-bpf 的形式。与允许一组固定系统调用不同，这种 seccomp 模式使用 BPF 代码来过滤允许和禁止的系统调用。
- en: 'In seccomp-bpf, a set of BPF instructions are loaded that act as a filter.
    Each time a syscall is called, the filter is triggered. The filter code has access
    to the arguments that are passed to the syscall so that it can make decisions
    based on both the syscall itself and the arguments that have been passed to it.
    The outcome is one of a set of possible actions that include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 seccomp-bpf 中，加载一组作为过滤器的 BPF 指令。每次调用系统调用时，都会触发过滤器。过滤器代码可以访问传递给系统调用的参数，以便根据系统调用本身和传递给它的参数做出决策。结果是可能的一组操作之一，包括：
- en: Allowing the syscall to go ahead
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许系统调用继续执行
- en: Returning an error code to the user space application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误代码返回给用户空间应用程序
- en: Killing the thread
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止线程
- en: Notifying a user space application (seccomp-unotify*)* (as of kernel version
    5.0)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户空间应用程序（seccomp-unotify*）*（截至内核版本5.0）
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to explore writing your own BPF filter code, Michael Kerrisk has
    some good examples at [*https://oreil.ly/cJ6HL*](https://oreil.ly/cJ6HL).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索编写自己的 BPF 过滤器代码，Michael Kerrisk 在 [*https://oreil.ly/cJ6HL*](https://oreil.ly/cJ6HL)
    上有一些很好的示例。
- en: Some of the arguments passed to syscalls are pointers, and the BPF code in seccomp-bpf
    is not able to dereference these pointers. This limits the flexibility of a seccomp
    profile, as it can only use value arguments in its decision-making process. Also,
    it has to be applied to the process when it starts—you can’t modify the profile
    that is being applied to a given application process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些传递给系统调用的参数是指针，而 seccomp-bpf 中的 BPF 代码不能解引用这些指针。这限制了 seccomp 配置文件的灵活性，因为它只能在决策过程中使用值参数。此外，它必须在进程启动时应用——你不能修改正在应用于给定应用程序进程的配置文件。
- en: You may well have used seccomp-bpf without writing BPF code, as the code is
    often derived from a human-readable seccomp profile. [Docker’s default profile](https://oreil.ly/IT_Bf)
    is a good example. This is a general-purpose profile intended to be usable with
    pretty much any normal, containerized application. That inevitably means it allows
    most syscalls and disallows only a few that are unlikely to be appropriate in
    any application, `reboot()` being a great example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能已经在不编写 BPF 代码的情况下使用了 seccomp-bpf，因为该代码通常是从可读的 seccomp 配置文件派生出来的。[Docker
    的默认配置文件](https://oreil.ly/IT_Bf) 就是一个很好的例子。这是一个通用的配置文件，旨在与几乎任何常规的容器化应用程序兼容。这意味着它允许大多数系统调用，并仅禁止一些在任何应用程序中不太可能合适的调用，`reboot()`
    就是一个很好的例子。
- en: '[According to Aqua Security](https://oreil.ly/1xWmn), most containerized apps
    use somewhere in the range of 40 to 70 syscalls. For better security, it would
    be preferable to use a more constrained profile that is targeted at each specific
    application and only allows the syscalls it actually uses.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Aqua Security 的说法（https://oreil.ly/1xWmn），大多数容器化应用程序使用了大约 40 到 70 个系统调用。为了更好的安全性，最好使用一个更加限制性的配置文件，针对每个具体应用程序，只允许实际使用的系统调用。
- en: Generating Seccomp Profiles
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 Seccomp 配置文件
- en: If you ask the average app developer to tell you what syscalls one of their
    programs makes, you’re likely to get a blank look. That’s not intended to be insulting.
    It’s just that most developers write in programming languages that give them higher-level
    abstractions far removed from the details of syscalls. For example, they might
    know what files their application opens, but it’s less likely that they could
    tell you whether they are opened using `open()` or `openat()`*.* This makes it
    unlikely that you’ll get a positive response if you ask the developer to handcraft
    an appropriate seccomp profile along with their application code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求普通应用开发人员告诉你他们的某个程序调用了哪些系统调用，你可能会看到一脸茫然的表情。这并不是有意冒犯。只是因为大多数开发人员使用的编程语言为他们提供了远离系统调用细节的高级抽象。例如，他们可能知道他们的应用程序打开了哪些文件，但他们不太可能告诉你它们是使用
    `open()` 还是 `openat()`。这使得如果你要求开发人员在他们的应用程序代码中手工制作一个合适的 seccomp 配置文件，你可能得不到积极的回应。
- en: 'Automation is the way forward: the idea is to use a tool to record the set
    of syscalls an application makes. In the early days, seccomp profiles were generally
    compiled using `strace` to gather the set of syscalls an application calls.^([1](ch09.html#ch09fn2))
    This isn’t a wonderful solution in the cloud native age, as there’s no easy way
    to point `strace` at a specific container or Kubernetes pod. It would also be
    more helpful to generate the profile not just as a list of syscalls, but in the
    JSON format that Kubernetes and OCI-compatible container runtimes can take as
    input. There are a couple of tools that do this, using eBPF to gather information
    about all the syscalls being called:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是未来的趋势：使用工具记录应用程序调用的系统调用集合。在早期，seccomp 配置文件通常使用 `strace` 编译，以收集应用程序调用的系统调用集合。^([1](ch09.html#ch09fn2))
    在云原生时代，这不是一个理想的解决方案，因为没有简单的方法来指定 `strace` 对特定的容器或 Kubernetes Pod 进行跟踪。最好生成配置文件不仅作为系统调用列表，而是采用
    Kubernetes 和 OCI 兼容容器运行时可以接受的 JSON 格式。有一些工具可以做到这一点，使用 eBPF 收集所有调用的系统调用信息：
- en: '[Inspektor Gadget](https://www.inspektor-gadget.io) includes a seccomp profiler
    that allows you to generate a custom seccomp profile for the containers in a Kubernetes
    pod.^([2](ch09.html#ch09fn3))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Inspektor Gadget](https://www.inspektor-gadget.io) 包括一个 seccomp 分析器，允许你为 Kubernetes
    Pod 中的容器生成自定义 seccomp 配置文件。^([2](ch09.html#ch09fn3))'
- en: Red Hat created a seccomp profiler in the form of an [OCI runtime hook](https://oreil.ly/nC8vM).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat 创建了一个 seccomp 分析器，采用了 [OCI 运行时钩子](https://oreil.ly/nC8vM) 的形式。
- en: With these profilers, you need to run the application for some arbitrary amount
    of time to generate a profile that includes the full list of the syscalls it might
    legitimately call. As discussed earlier in this chapter, this list needs to include
    error paths. If your application can’t behave correctly under error conditions
    because the syscalls it needs to call are blocked, this might cause a bigger problem.
    And since seccomp profiles deal with a lower abstraction level than most developers
    are familiar with, it’s hard to review them manually to see if they cover all
    the right cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些分析工具，您需要运行应用程序一段任意时间，以生成包括其可能合法调用的完整系统调用列表的性能分析。如本章前述，此列表需要包括错误路径。如果您的应用程序在错误条件下无法正确执行因为需要调用的系统调用被阻止，这可能会引起更大的问题。由于seccomp配置文件处理比大多数开发者熟悉的抽象层次更低，手动审查它们以确认是否覆盖了所有正确的情况是困难的。
- en: Taking the OCI runtime hook as an example, an eBPF program is [attached to the
    `syscall_enter` raw tracepoint](https://oreil.ly/sbWSc) and maintains an eBPF
    map that keeps track of [which syscalls have been seen](https://oreil.ly/czUM7).
    The user space parts of this tool are written in Go and use the [*iovisor/gobpf*
    library](https://oreil.ly/sYCT3). (I’ll discuss this and other Golang libraries
    for eBPF in [Chapter 10](ch10.html#ebpf_programming).)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以OCI运行时挂钩为例，eBPF程序会附加到`syscall_enter`原始跟踪点，并维护一个eBPF映射，跟踪已见过的系统调用。此工具的用户空间部分使用Go编写，并使用[*iovisor/gobpf*库](https://oreil.ly/sYCT3)。（我将在[第10章](ch10.html#ebpf_programming)中讨论此及其他用于eBPF的Golang库。）
- en: 'The following are the [lines of code](https://oreil.ly/DOShA) from the OCI
    runtime hook that load the eBPF program into the kernel and attach it to the tracepoint
    (a few lines have been omitted for brevity):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是来自OCI运行时挂钩的代码行，加载eBPF程序到内核并将其附加到跟踪点（为了简洁起见，省略了几行）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#code_id_9_1)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_9_1)'
- en: 'This line does something quite interesting: it replaces a variable named `$PARENT_PID`
    in the eBPF source code with a numeric process ID. This is a common pattern, and
    it indicates that this tool will load individual eBPF programs for each process
    being instrumented.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行有非常有趣的作用：它用eBPF源代码中名为`$PARENT_PID`的变量替换了一个数值进程ID。这是一个常见的模式，表明此工具将为每个被检测的进程加载单独的eBPF程序。
- en: '[![2](assets/2.png)](#code_id_9_2)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_9_2)'
- en: Here, an eBPF program called `enter_trace` gets loaded into the kernel.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个名为`enter_trace`的eBPF程序被加载到内核中。
- en: '[![3](assets/3.png)](#code_id_9_3)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_9_3)'
- en: The `enter_trace` program gets attached to the tracepoint `raw_syscalls:sys_enter`.
    This is the tracepoint at the point of entry to any syscall, which you’ve encountered
    in earlier examples. Whenever any user space code makes a syscall, this tracepoint
    will be hit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`enter_trace`程序附加到`raw_syscalls:sys_enter`跟踪点。这是任何系统调用入口点的跟踪点，在先前的示例中已经遇到过。每当用户空间代码进行系统调用时，将触发此跟踪点。'
- en: These profilers use eBPF code attached to `sys_enter` to keep track of the set
    of syscalls that have been used, and they generate a seccomp profile to be used
    with seccomp, which does the actual job of enforcing the profile. The next class
    of eBPF tools we’ll consider also attach to `sys_enter`, but they use syscalls
    to track the behavior of an application and compare it against security policies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分析工具使用eBPF代码附加到`sys_enter`以跟踪已使用的系统调用集，并生成一个seccomp配置文件，该配置文件将用于实施配置。接下来我们将考虑的eBPF工具类别也会附加到`sys_enter`，但它们使用系统调用来跟踪应用程序的行为并将其与安全策略进行比较。
- en: Syscall-Tracking Security Tools
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用跟踪安全工具
- en: The best-known tool that falls into this category of syscall-tracking security
    tools is the CNCF project [Falco](https://falco.org), which provides security
    alerts. By default, Falco is installed as a kernel module, but there is also an
    eBPF version. Users can define [rules](https://oreil.ly/enufu) to determine what
    events are security relevant, and Falco can generate alerts in a variety of formats
    when events happen that don’t match the policies defined in these rules.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这类众所周知的工具中，属于系统调用跟踪安全工具的最佳项目是CNCF项目[Falco](https://falco.org)，它提供安全警报。默认情况下，Falco作为内核模块安装，但也有一个eBPF版本。用户可以定义[规则](https://oreil.ly/enufu)来确定哪些事件与安全相关，并且当发生不符合这些规则定义的事件时，Falco可以以各种格式生成警报。
- en: 'Both the kernel module driver and the eBPF-based driver attach to system calls.
    If you examine the [Falco eBPF programs on GitHub](https://oreil.ly/Q_cBD) you’ll
    see lines like the following that attach probes to raw syscall entry and exit
    points (plus a few other events, such as page faults):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块驱动程序和基于 eBPF 的驱动程序都会附加到系统调用。如果您检查 [GitHub 上的 Falco eBPF 程序](https://oreil.ly/Q_cBD)，您会看到像以下这样的行，它们会附加探测器到原始系统调用的入口和退出点（以及一些其他事件，如页面错误）：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since eBPF programs can be loaded dynamically and can detect events triggered
    by preexisting processes, tools like Falco can apply policies to application workloads
    that are already running. Users can modify the set of rules being applied without
    having to modify the applications or their configuration. This is in contrast
    to seccomp profiles, which have to be applied to the application process when
    it is launched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 eBPF 程序可以动态加载并可以检测由预先存在的进程触发的事件，像 Falco 这样的工具可以对已运行的应用工作负载应用策略。用户可以修改正在应用的规则集，而无需修改应用程序或其配置。这与必须在应用程序启动时应用的
    seccomp 配置文件形成对比。
- en: 'Unfortunately there is a problem with this approach of using syscall entry
    points for security tooling: there is a Time Of Check to Time Of Use (TOCTOU)
    issue.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用系统调用入口点作为安全工具的方法存在问题：存在时间检查到使用时间（TOCTOU）问题。
- en: When an eBPF program is triggered at the entry point to a system call, it can
    access the arguments that user space has passed to that system call. If those
    arguments are pointers, the kernel will need to copy the pointed-to data into
    its own data structures before acting on that data. As illustrated in [Figure 9-2](#an_attacker_can_change_syscall_argument),
    there is a window of opportunity for an attacker to modify this data, after it
    has been inspected by the eBPF program but before the kernel copies it. Thus,
    the data being acted on might not be the same as what was captured by the eBPF
    program.^([3](ch09.html#ch09fn4))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当 eBPF 程序在系统调用入口点触发时，它可以访问用户空间传递给该系统调用的参数。如果这些参数是指针，则内核将需要将指向的数据复制到自己的数据结构中，然后再对数据进行操作。正如在
    [图 9-2](#an_attacker_can_change_syscall_argument) 中所示，攻击者有机会在 eBPF 程序检查完数据后但内核复制之前修改这些数据。因此，正在处理的数据可能与
    eBPF 程序捕获的数据不同。^([3](ch09.html#ch09fn4))
- en: '![An attacker can change syscall arguments before they are accessed by the
    kernel](assets/lebp_0902.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![攻击者可以在内核访问系统调用参数之前更改它们](assets/lebp_0902.png)'
- en: Figure 9-2\. An attacker can change syscall arguments before they are accessed
    by the kernel
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 攻击者可以在内核访问系统调用参数之前更改它们。
- en: The same window would apply for seccomp-bpf, were it not for the fact that in
    seccomp-bpf the program is not allowed to dereference the user space pointer,
    so it’s not possible to examine the data at all.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 seccomp-bpf，同样的问题将适用，除非事实上在 seccomp-bpf 中不允许程序解引用用户空间指针，因此根本无法检查数据。
- en: The TOCTOU issue does apply for seccomp_unotify, a recently added mode of seccomp
    where a violation can be reported to user space. The [manpage for seccomp_unotify](https://oreil.ly/cwpki)
    explicitly notes that “It should thus be absolutely clear that the seccomp user-space
    notification mechanism *cannot* be used to implement a security policy!”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: TOCTOU 问题确实适用于 seccomp_unotify，这是 seccomp 的最新添加模式，其中违规操作可以报告给用户空间。[seccomp_unotify
    手册](https://oreil.ly/cwpki) 明确指出：“因此应该完全清楚，seccomp 用户空间通知机制 *不能* 用于实施安全策略！”
- en: The syscall entry point might be very convenient for observability purposes,
    but for a serious security tool it’s really not sufficient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用入口点可能非常方便用于可观察性目的，但对于严肃的安全工具来说确实不够。
- en: The [Sysmon for Linux tool](https://oreil.ly/pbtF3) addresses the TOCTOU window
    by attaching to both the entry and exit points for syscalls. Once the call has
    completed, it looks at the kernel’s data structures to get an accurate view. For
    example, if the syscall returns a file descriptor, the eBPF program attached to
    the exit can retrieve correct information about the object that the file descriptor
    represents by looking into the related process’s file descriptor table. While
    this approach can result in an accurate record of security-related activity, it
    can’t prevent an action from taking place, since the syscall has already completed
    by the time a check is made.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[Linux 的 Sysmon 工具](https://oreil.ly/pbtF3)通过附加到系统调用的入口和退出点来解决 TOCTOU 窗口问题。一旦调用完成，它会查看内核的数据结构以获取准确的视图。例如，如果系统调用返回一个文件描述符，附加到退出点的
    eBPF 程序可以通过查看相关进程的文件描述符表获取关于该文件描述符表示的对象的正确信息。虽然这种方法可以生成安全相关活动的准确记录，但它无法阻止操作的执行，因为在进行检查时系统调用已经完成。'
- en: 'To be certain that it is inspecting the same information the kernel will act
    on, the eBPF program should be attached to an event that occurs after the parameters
    have been copied into kernel memory. Unfortunately, there is no single common
    place in the kernel to do this, as the data is handled differently in syscall-specific
    code. However, there is a well-defined interface where eBPF programs can be safely
    attached: the Linux Security Module (LSM) API. This requires a relatively new
    eBPF feature: BPF LSM.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保检查的是内核将要操作的相同信息，eBPF 程序应附加到参数已复制到内核内存之后发生的事件上。不幸的是，在内核中没有单一通用的地方可以这样做，因为数据在特定于系统调用的代码中处理方式不同。然而，存在一个明确定义的接口，eBPF
    程序可以安全地附加到其中：Linux 安全模块（LSM）API。这需要一个相对较新的 eBPF 特性：BPF LSM。
- en: BPF LSM
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF LSM
- en: The LSM interface provides a set of hooks that each occur just before the kernel
    is about to act on a kernel data structure. The function called by a hook can
    make a decision about whether to allow the action to go ahead. This interface
    was originally provided to allow security tools to be implemented in the form
    of [kernel modules](https://oreil.ly/mF_OD); [BPF LSM](https://oreil.ly/KzaMT)
    extends this so that eBPF programs can be attached to the same hook points, as
    shown in [Figure 9-3](#with_lsm_bpfcomma_ebpf_programs_can_be_).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: LSM（Linux 安全模块）接口提供了一组钩子，每个钩子都在内核即将操作内核数据结构之前触发。由钩子调用的函数可以决定是否允许操作继续进行。最初提供此接口是为了允许以[内核模块](https://oreil.ly/mF_OD)形式实现安全工具；[BPF
    LSM](https://oreil.ly/KzaMT)将其扩展，使得 eBPF 程序可以附加到相同的钩子点上，如[图 9-3](#with_lsm_bpfcomma_ebpf_programs_can_be_)所示。
- en: '![With LSM BPF, eBPF programs can be triggered by LSM hook events](assets/lebp_0903.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用 LSM BPF，eBPF 程序可以通过 LSM 钩子事件触发](assets/lebp_0903.png)'
- en: Figure 9-3\. With LSM BPF, eBPF programs can be triggered by LSM hook events
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. 使用 LSM BPF，eBPF 程序可以通过 LSM 钩子事件触发
- en: There are hundreds of LSM hooks, and they’re pretty nicely [documented in the
    kernel source code](https://oreil.ly/dO8jT). To be clear, there isn’t a one-to-one
    mapping between syscalls and LSM hooks, but if a syscall has the potential to
    do something interesting from a security perspective, processing that syscall
    will trigger one or more of the hooks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百个 LSM 钩子，并且它们在内核源代码中有相当不错的[文档记录](https://oreil.ly/dO8jT)。需要明确的是，系统调用与 LSM
    钩子之间并没有一对一的映射，但如果系统调用从安全角度看有趣的潜力，则处理该系统调用将触发一个或多个钩子。
- en: 'Here’s a trivial example of an eBPF program attached to an LSM hook. This example
    is called during the processing of a `chmod` command (“chmod” stands for “change
    modes” and is mostly used to change the access permissions on a file):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 eBPF 程序附加到 LSM 钩子的简单示例。此示例在处理`chmod`命令（“chmod”代表“改变模式”，主要用于更改文件的访问权限）期间被调用：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example simply traces out the name of the file and always returns `0`,
    but you can imagine a real implementation that would make use of the arguments
    to decide whether to allow this change of mode. Returning a nonzero value would
    deny permission to make this change, so the kernel wouldn’t go ahead with it.
    It’s worth noting that making policy checks entirely within the kernel like this
    is highly performant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例简单地跟踪文件名并始终返回`0`，但您可以想象一个真实的实现会利用参数来决定是否允许此模式更改。返回非零值将拒绝此更改的权限，因此内核不会继续执行它。值得注意的是，完全在内核中进行此类策略检查非常高效。
- en: The `path` argument to `BPF_PROG()` is the kernel data structure representing
    the file, and the `mode` argument is the desired new mode value. You can see the
    name of the file being accessed from the field `path->dentry->d_iname`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG()`函数的`path`参数是表示文件的内核数据结构，`mode`参数是所需的新模式值。你可以从`path->dentry->d_iname`字段看到正在访问的文件名称。'
- en: LSM BPF was added in kernel version 5.7, which means that (at least at the time
    of this writing) it’s not yet available on many supported Linux distributions,
    but I expect that over the next couple of years many vendors will develop security
    tooling that makes use of this interface. Before LSM BPF is made widely available,
    there is another possible approach, as used by the developers of Cilium Tetragon.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: LSM BPF是在内核版本5.7中添加的，这意味着（至少在撰写本文时）它尚未在许多支持的Linux发行版上可用，但我预计在接下来的几年里，许多供应商将开发利用此接口的安全工具。在LSM
    BPF广泛可用之前，还有另一种可能的方法，正如Cilium Tetragon的开发人员所使用的。
- en: Cilium Tetragon
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cilium Tetragon
- en: '[Tetragon](https://oreil.ly/p-bdc) is part of the Cilium project (also part
    of the CNCF). Rather than attaching to LSM API hooks, Tetragon’s approach is to
    build a framework for attaching eBPF programs to arbitrary functions in the Linux
    kernel.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[四边形](https://oreil.ly/p-bdc)是Cilium项目的一部分（也是CNCF的一部分）。与附加到LSM API挂钩不同，四边形的方法是构建一个框架，将eBPF程序附加到Linux内核中任意函数。'
- en: 'Tetragon is designed for use in a Kubernetes environment, and the project defines
    a custom Kubernetes resource type called a *TracingPolicy*. This is used to define
    a set of events to which eBPF programs should be attached, conditions that need
    to be checked by eBPF code, and actions to take if the conditions are met. The
    following is an extract from a sample TracingPolicy:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 四边形专为在Kubernetes环境中使用设计，并且该项目定义了一个名为*TracingPolicy*的自定义Kubernetes资源类型。用于定义应将eBPF程序附加到的一组事件、由eBPF代码需要检查的条件以及条件满足时要执行的操作。以下是样本TracingPolicy的摘录：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This policy defines a set of kprobes to attach programs to, the first of which
    is the kernel function `fd_install`. This is an internal function in the kernel.
    Let’s explore why you might choose to attach to a function like that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略定义了一组kprobes以附加程序，其中第一个是内核函数`fd_install`。这是内核中的内部函数。让我们探讨为什么你可能选择附加到这样一个函数。
- en: Attaching to Internal Kernel Functions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加到内部内核函数
- en: The system call interface and the LSM interface are defined as stable interfaces
    in the Linux kernel; that is to say, they won’t change in a backward-incompatible
    way. If you write code today that uses the functions in those interfaces, they
    will continue to work in future versions of the kernel. These interfaces represent
    just a tiny fraction of the 30 million lines of code that make up the Linux kernel.
    Parts of that codebase are de facto stable, even if they are not officially declared
    as such; they haven’t changed for a long time and are unlikely to do so in the
    future.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用接口和LSM接口被定义为Linux内核中的稳定接口；也就是说，它们不会以不向后兼容的方式进行更改。如果您今天编写使用这些接口中的函数的代码，它们将继续在将来的内核版本中工作。这些接口仅代表构成Linux内核的3000万行代码的一小部分。即使它们尚未正式声明为稳定，这些代码库的部分长期没有更改，并且未来也不太可能更改。
- en: It’s perfectly reasonable to write eBPF programs that attach to kernel functions
    that aren’t officially stable, with the expectation that they are likely to work
    for some considerable time to come. Also, given that it typically takes several
    years for a new kernel version to be widely deployed, it’s a safe bet that there
    will be plenty of time to address any incompatibility issues that might arise.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以编写eBPF程序，将其附加到官方未稳定的内核函数，预计它们将在相当长的时间内继续工作。此外，考虑到新内核版本通常需要几年时间才能被广泛部署，可以放心地认为将有足够的时间来解决可能出现的任何不兼容性问题。
- en: The Tetragon contributors include a number of kernel developers who have used
    their knowledge of kernel internals to identify some good, safe places where eBPF
    programs can be attached for useful security purposes. There are several [example
    TracingPolicy definitions](https://oreil.ly/51yRN) that make use of this knowledge.
    These examples monitor security events covering file operations, network activity,
    program executions, and changes to privileges—all the kinds of things a malicious
    actor would do as part of an attack.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Tetragon 的贡献者包括许多内核开发人员，他们利用对内核内部的知识，识别出一些适合用于有用安全目的的 eBPF 程序的安全位置。有几个[示例 TracingPolicy
    定义](https://oreil.ly/51yRN)利用了这些知识。这些示例监控涵盖文件操作、网络活动、程序执行以及权限更改等安全事件，这些都是恶意行为者在攻击中可能会做的事情。
- en: Let’s come back to that example policy definition that attaches to `fd_install`.
    The “fd” stands for “file descriptor,” and the [comment in the source code for
    this function](https://oreil.ly/Tm6MN) tells us this function “Install[s] a file
    pointer in the fd array.” This happens when a file is opened, and it’s called
    after the file’s data structure has been populated in the kernel. It’s a safe
    place to check the name of the file—and in the earlier TracingPolicy example,
    it’s only of interest if the filename starts with “/etc/”.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到附加到`fd_install`的示例策略定义。这里的“fd”代表“文件描述符”，而[该函数源代码的注释](https://oreil.ly/Tm6MN)告诉我们该函数“在
    fd 数组中安装一个文件指针”。这发生在文件被打开时，并且在文件的数据结构在内核中被填充之后调用。这是一个安全检查文件名的地方——在早期的 TracingPolicy
    示例中，只有当文件名以“/etc/”开头时才有兴趣。
- en: Just as in LSM BPF programs, Tetragon eBPF programs have access to contextual
    information to allow them to make security decisions entirely within the kernel.
    Rather than reporting all events of a given type to user space, security-relevant
    events can be filtered within the kernel so that only the out-of-policy events
    get reported to user space.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 LSM BPF 程序一样，Tetragon 的 eBPF 程序可以访问上下文信息，使它们能够完全在内核内做出安全决策。与其将给定类型的所有事件报告给用户空间，安全相关事件可以在内核内被过滤，以便只有超出策略的事件才报告给用户空间。
- en: Preventative Security
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防安全措施
- en: Most eBPF-based security tools have used eBPF programs to detect malicious events,
    which notify a user space application that can then take action. As you can see
    in [Figure 9-4](#an_asynchronous_notification_from_kerne), any action the user
    space app takes happens asynchronously, by which time it might be too late—perhaps
    data could have been exfiltrated, or the attacker could have persisted malicious
    code onto disk.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于 eBPF 的安全工具使用 eBPF 程序来检测恶意事件，然后通知一个用户空间应用程序来采取行动。正如你可以在[图 9-4](#an_asynchronous_notification_from_kerne)中看到的，用户空间应用程序采取的任何操作都是异步进行的，可能会来不及——也许数据已经外泄，或者攻击者已经将恶意代码持久化到磁盘上。
- en: '![An asynchronous notification from kernel to user space allows some time for
    an attack to continue](assets/lebp_0904.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![An asynchronous notification from kernel to user space allows some time for
    an attack to continue](assets/lebp_0904.png)'
- en: Figure 9-4\. An asynchronous notification from kernel to user space allows some
    time for an attack to continue
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-4\. 内核到用户空间的异步通知允许攻击继续一段时间
- en: In kernel versions 5.3 and up, there is a BPF helper function called `b⁠p⁠f⁠_⁠s⁠e⁠n⁠d⁠_​s⁠i⁠g⁠n⁠a⁠l⁠(⁠)`.
    Tetragon uses this function to implement preventative security. If a policy defines
    a Sigkill action, any matching events will cause Tetragon eBPF code to generate
    a SIGKILL signal that terminates the process that was attempting the out-of-policy
    action. As shown in [Figure 9-5](#tetragon_kills_malicious_processes_sync), this
    happens synchronously; that is, the activity the kernel was performing that the
    eBPF code determined to be out of policy is prevented from completing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核版本 5.3 及更高版本中，有一个名为`b⁠p⁠f⁠_⁠s⁠e⁠n⁠d⁠_​s⁠i⁠g⁠n⁠a⁠l⁠(⁠)`的 BPF 辅助函数。Tetragon
    使用此函数来实现预防安全措施。如果策略定义了 Sigkill 动作，任何匹配的事件都会导致 Tetragon 的 eBPF 代码生成一个 SIGKILL 信号，终止试图执行超出策略动作的进程。正如在[图 9-5](#tetragon_kills_malicious_processes_sync)中所示，这是同步进行的；也就是说，内核正在执行的活动被
    eBPF 代码确定为超出策略的活动将被阻止完成。
- en: '![Tetragon kills malicious processes synchronously by sending a SIGKILL signal
    from the kernel](assets/lebp_0905.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Tetragon kills malicious processes synchronously by sending a SIGKILL signal
    from the kernel](assets/lebp_0905.png)'
- en: Figure 9-5\. Tetragon kills malicious processes synchronously by sending a SIGKILL
    signal from the kernel
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-5\. Tetragon 通过内核发送 SIGKILL 信号同步终止恶意进程
- en: Sigkill policies need to be used with care, because an incorrectly configured
    policy could result in terminating applications unnecessarily, but it’s an incredibly
    powerful use of eBPF for security purposes. You can start by running in an “audit”
    mode that generates security events but doesn’t apply the SIGKILL enforcement,
    until you’re confident that the policy won’t break anything.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sigkill策略**需要谨慎使用，因为配置不正确的策略可能会不必要地终止应用程序，但这对于安全目的来说是非常强大的eBPF使用。您可以通过运行“审计”模式来开始，生成安全事件，但不应用SIGKILL执行，直到您确信该策略不会出问题。'
- en: If you’re interested in learning more about using Cilium Tetragon for detecting
    security events, there is a report titled “[Security Observability with eBPF](https://www.oreilly.com/library/view/security-observability-with/9781492096719/)”
    by Natália Réka Ivánkó and Jed Salazar that digs into much more detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣了解如何使用Cilium Tetragon来检测安全事件的更多信息，有一份名为“[使用eBPF进行安全可观察性](https://www.oreilly.com/library/view/security-observability-with/9781492096719/)”的报告，由Natália
    Réka Ivánkó和Jed Salazar详细介绍。
- en: Network Security
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络安全
- en: '[Chapter 8](ch08.html#ebpf_for_networking) discussed how eBPF can be used very
    effectively to implement network security mechanisms. To summarize:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html#ebpf_for_networking)讨论了如何利用eBPF非常有效地实现网络安全机制。总结一下：'
- en: Firewalling and DDoS protection are a natural fit for eBPF programs attached
    early in the ingress path for network packets. And with the possibility of XDP
    programs offloaded to hardware, malicious packets may never even reach the CPU!
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙和DDoS保护是早期附加在网络数据包入口路径的eBPF程序的自然选择。而且随着XDP程序被卸载到硬件的可能性，恶意数据包甚至可能根本不会到达CPU！
- en: For implementing more sophisticated network policies, such as Kubernetes policies
    determining which services are allowed to communicate with one another, eBPF programs
    that attach to points in the network stack can drop packets if they are determined
    to be out of policy.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于实施更复杂的网络策略，例如Kubernetes策略确定哪些服务允许彼此通信，如果判断数据包违反策略，附加到网络堆栈中的eBPF程序可以丢弃这些数据包。
- en: Network security tools are very often used in a preventative mode, dropping
    packets rather than just auditing malicious activity. This is because it’s so
    easy for bad actors to mount network-related attacks; if you give a device a public
    IP address exposed to the internet, it won’t be long before you start seeing suspicious
    traffic, so organizations are forced to use preventative measures.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全工具往往以预防模式使用，而不仅仅是审核恶意活动。这是因为对于恶意行为者来说很容易发动与网络相关的攻击；如果您给一个设备一个暴露在互联网上的公共IP地址，那么不久之后您就会开始看到可疑的流量，因此组织被迫采取预防措施。
- en: In contrast, lots of organizations use intrusion detection tools in an audit
    mode, and they rely on forensics to determine whether a suspicious event was really
    malicious and what remedial action needs to be taken. If a given security tool
    is too blunt an instrument and is prone to detecting false-positives, it’s not
    surprising that it needs to be run in audit mode rather than preventative mode.
    It’s my belief that eBPF is enabling more sophisticated security tools with finer-grained,
    accurate controls. Just as we consider firewalls today to be sufficiently accurate
    to use in preventative mode, we’ll see increased use of preventative tooling that
    acts on other, non-networking events. This could even include eBPF-based controls
    being packaged as part of an application product so that it can provide its own
    runtime security.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，许多组织在审计模式下使用入侵检测工具，并依靠取证确定可疑事件是否真的恶意以及需要采取什么补救措施。如果某个安全工具过于粗糙且容易产生误报，那么它需要在审计模式而不是预防模式下运行并不奇怪。我相信eBPF正在实现更复杂的安全工具，具有更精细的、准确的控制。正如我们今天认为防火墙足够准确以在预防模式下使用一样，我们将看到更多使用预防性工具的情况，这些工具针对其他非网络事件采取行动。这甚至可能包括作为应用产品的一部分打包的基于eBPF的控制，以便提供自己的运行时安全性。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you saw how eBPF’s use in security has evolved from low-level
    checks on system calls to much more sophisticated use of eBPF programs for security
    policy checks, in-kernel event filtering, and runtime enforcement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到eBPF在安全领域的使用已经从系统调用的低级检查发展到更复杂的用途，如安全策略检查、内核事件过滤和运行时强制执行。
- en: There’s still much active development in the area of using eBPF for security
    purposes. I believe we will see tools in this area evolving and becoming widely
    adopted over the coming years.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 eBPF 用于安全目的的领域仍然有很多积极的发展。我相信在未来几年内，我们将看到这一领域的工具不断发展，并被广泛采纳。
- en: '^([1](ch09.html#ch09fn2-marker)) See, for example, this post from Jess Frazelle,
    who developed the default seccomp profile for Docker: [“How to Use the New Docker
    Seccomp Profiles”](https://oreil.ly/EcpnM).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#ch09fn2-marker)) 例如，可以参考 Jess Frazelle 的这篇文章，她为 Docker 开发了默认的
    seccomp 配置文件：“[如何使用新的 Docker Seccomp 配置文件](https://oreil.ly/EcpnM)”。
- en: ^([2](ch09.html#ch09fn3-marker)) The documentation for Inspektor Gadget’s seccomp
    profiler is quite dry, but [this video overview from Jose Blanquicet](https://oreil.ly/0bYaa)
    is more accessible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#ch09fn3-marker)) Inspektor Gadget 的 seccomp 分析工具的文档相当枯燥，但[Jose
    Blanquicet 的这段视频概述](https://oreil.ly/0bYaa)更易于理解。
- en: '^([3](ch09.html#ch09fn4-marker)) Exploiting this window was discussed in a
    DEFCON 29 talk titled “[Phantom Attack: Evading System Call Monitoring](https://oreil.ly/WguKq)”
    by Rex Guo and Junyuan Zeng, and its impact on Falco was covered in more detail
    in the talk “[LSM BPF Change Everything](https://oreil.ly/17c-3)” by Leo Di Donato
    and KP Singh.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch09.html#ch09fn4-marker)) 这个窗口的利用在 DEFCON 29 的讲座中有所讨论，题为“[Phantom Attack:
    Evading System Call Monitoring](https://oreil.ly/WguKq)”由 Rex Guo 和 Junyuan Zeng
    主讲，以及在“[LSM BPF Change Everything](https://oreil.ly/17c-3)”由 Leo Di Donato 和 KP
    Singh 更详细地讨论了其对 Falco 的影响。'
