- en: Chapter 2\. Introducing the Shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 介绍 Shell
- en: So, you can run commands at a prompt. But what *is* that prompt? Where does
    it come from, how are your commands run, and why does it matter?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可以在提示符下运行命令。但是那个提示符*到底是什么*？它从哪里来，你的命令是如何运行的，这又为什么重要呢？
- en: That little prompt is produced by a program called a *shell*. It’s a user interface
    that sits between you and the Linux operating system. Linux supplies several shells,
    and the most common (and the standard for this book) is called `bash`. (See [Appendix B](app02.xhtml#appendix_shells)
    for notes about other shells.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那个小提示符是一个叫做 *shell* 的程序产生的。它是一个用户界面，位于你和 Linux 操作系统之间。Linux 提供了几种 shell，最常见的（也是本书的标准）叫做
    `bash`。（有关其他 shell 的说明，请参见[附录 B](app02.xhtml#appendix_shells)。）
- en: '`bash` and other shells do much more than simply run commands. For example,
    when a command includes a wildcard (`*`) to refer to multiple files at once:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash` 和其他 shell 做的远不止运行命令这么简单。例如，当一个命令包含通配符 (`*`) 来一次引用多个文件时：'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'the wildcard is handled entirely by the shell, not by the program `ls`. The
    shell evaluates the expression `*.py` and invisibly replaces it with a list of
    matching filenames *before* `ls` runs. In other words, `ls` *never sees the wildcard*.
    From the perspective of `ls`, you typed the following command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符完全由 shell 处理，而不是由程序 `ls` 处理。Shell 评估表达式 `*.py` 并在 `ls` 运行之前*隐式地替换它为匹配的文件列表*。换句话说，`ls`
    *从不看到通配符*。从 `ls` 的角度来看，你输入了以下命令：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The shell also handles the pipes you saw in [Chapter 1](ch01.xhtml#ch_combining_commands).
    It redirects stdin and stdout transparently so the programs involved have no idea
    they are communicating with each other.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 还处理你在[第 1 章](ch01.xhtml#ch_combining_commands)中看到的管道。它透明地重定向 stdin 和 stdout，这样涉及的程序并不知道它们正在相互通信。
- en: Every time a command runs, some steps are the responsibility of the invoked
    program, such as `ls`, and some are the responsibility of the shell. Expert users
    understand which is which. That’s one reason they can create long, complex commands
    off the top of their head and run them successfully. They *already know what the
    command will do* before they press Enter, in part because they understand the
    separation between the shell and the programs it invokes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行命令时，一些步骤是被调用程序的责任，比如 `ls`，而另一些则是 shell 的责任。专家用户明白哪个是哪个。这就是他们能够头脑风暴出长而复杂命令并成功运行的一个原因。他们在按下
    Enter 键之前就*已经知道命令会做什么*，部分原因是他们理解了 shell 与其调用的程序之间的分离。
- en: 'In this chapter, we’ll launch your understanding of the Linux shell. I’ll take
    the same minimalist approach I used for commands and pipes in [Chapter 1](ch01.xhtml#ch_combining_commands).
    Rather than cover dozens of shell features, I’ll hand you just enough information
    to carry you to the next step of your learning journey:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将启动你对 Linux shell 的理解。我将采用与第一章命令和管道相同的最简方法。与其涵盖数十种 shell 功能，不如仅提供足够的信息来带你迈向学习之路的下一步：
- en: Pattern matching for filenames
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于文件名的模式匹配
- en: Variables to store values
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储值的变量
- en: Redirection of input and output
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出的重定向
- en: Quoting and escaping to disable certain shell features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引号和转义字符禁用某些 shell 功能
- en: The search path for locating programs to run
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于查找要运行程序的搜索路径
- en: Saving changes to your shell environment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存对你的 shell 环境的更改
- en: Shell Vocabulary
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 词汇
- en: The word *shell* has two meanings. Sometimes it means the *concept* of the Linux
    shell in general, as in “The shell is a powerful tool” or “`bash` is a shell.”
    Other times it means a specific *instance* of a shell running on a given Linux
    computer, awaiting your next command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单词*shell*有两个含义。有时它指的是 Linux shell 的*概念*，如“shell 是一个强大的工具”或“`bash` 是一个 shell”。其他时候它指的是在给定的
    Linux 计算机上运行的特定*实例*，等待你下一个命令。
- en: In this book, the meaning of *shell* should be clear from the context most of
    the time. When necessary, I’ll refer to the second meaning as a *shell instance*,
    a *running shell*, or your *current shell*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，“shell”的含义大部分时间应该根据上下文清楚。必要时，我会提到第二个含义，即“shell 实例”、“运行中的 shell”或者你的“当前
    shell”。
- en: Some shell instances, but not all, present a prompt so you can interact with
    them. I’ll use the term *interactive shell* to refer to these instances. Other
    shell instances are noninteractive—they run a sequence of commands and exit.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 shell 实例具有提示符，这样你可以与它们交互。我将使用术语*交互式 shell*来指代这些实例。其他 shell 实例是非交互式的—它们运行一系列命令然后退出。
- en: Pattern Matching for Filenames
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于文件名的模式匹配
- en: 'In [Chapter 1](ch01.xhtml#ch_combining_commands), you worked with several commands
    that accept filenames as arguments, such as `cut`, `sort`, and `grep`. These commands
    (and many others) accept multiple filenames as arguments. For example, you can
    search for the word *Linux* in one hundred files at once, named *chapter1* through
    *chapter100*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch_combining_commands)中，你使用了几个接受文件名作为参数的命令，如 `cut`、`sort`
    和 `grep`。这些命令（及许多其他命令）接受多个文件名作为参数。例如，你可以一次在一百个文件中搜索*Linux*一词，文件名从*chapter1*到*chapter100*：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing multiple files by name is a tedious time-waster, so the shell provides
    special characters as a shorthand to refer to files or directories with similar
    names. Many folks call these characters wildcards, but the more general concept
    is called *pattern matching* or *globbing*. Pattern matching is one of the two
    most common techniques for speed that Linux users learn. (The other is pressing
    the up arrow key to recall the shell’s previous command, which I describe in [Chapter 3](ch03.xhtml#ch_history).)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按名称列出多个文件是一种繁琐且浪费时间的做法，因此 shell 提供了特殊字符作为文件或目录的简写。许多人称这些字符为通配符，但更普遍的概念称为*模式匹配*或*通配符展开*。模式匹配是
    Linux 用户学习的两种最常见的加速技术之一（另一种是按上箭头键来回忆 shell 的先前命令，我在[第3章](ch03.xhtml#ch_history)中描述了这个技巧）。
- en: 'Most Linux users are familiar with the star or asterisk character (`*`), which
    matches any sequence of zero or more characters (except for a leading dot)^([1](ch02.xhtml#idm46586652391888))
    in file or directory paths:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 用户熟悉星号或星号字符（`*`），它匹配文件或目录路径中的任意长度的零个或多个字符（不包括前导点）^([1](ch02.xhtml#idm46586652391888))：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Behind the scenes, the shell (not `grep`!) expands the pattern `chapter*` into
    a list of 100 matching filenames. Then the shell runs `grep`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，shell（而不是 `grep`！）展开模式 `chapter*` 为一系列匹配的文件名。然后 shell 运行 `grep`。
- en: 'Many users have also seen the question mark (`?`) special character, which
    matches any single character (except a leading dot). For example, you could search
    for the word *Linux* in chapters 1 through 9 only, by providing a single question
    mark to make the shell match single digits:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户还看到了问号（`?`）特殊字符，它匹配任意单个字符（除了前导点）。例如，通过提供一个问号来使 shell 匹配单个数字，你可以仅在第1至第9章中搜索*Linux*一词：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or in chapters 10 through 99, with two question marks to match two digits:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在第10至第99章中使用两个问号来匹配两位数：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Fewer users are familiar with square brackets (`[]`), which request the shell
    to match a single character from a set. For example, you could search only the
    first five chapters:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 较少的用户熟悉方括号（`[]`），它请求 shell 从集合中匹配单个字符。例如，你可以仅搜索前五章：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Equivalently, you could supply a range of characters with a dash:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用连字符提供字符范围：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You could also search even-numbered chapters, combining the asterisk and the
    square brackets to make the shell match filenames ending in an even digit:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以结合星号和方括号来匹配以偶数数字结尾的文件名，以搜索偶数章节：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Any characters, not just digits, may appear within the square brackets for
    matching. For example, filenames that begin with a capital letter, contain an
    underscore, and end with an `@` symbol would be matched by the shell in this command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中可以出现任何字符，而不仅仅是数字。例如，以大写字母开头，包含下划线，并以`@`符号结尾的文件名将被 shell 匹配到：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Terminology: Evaluating Expressions and Expanding Patterns'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语：评估表达式和展开模式
- en: Strings that you enter on the command line, such as `chapter*` or `Efficient
    Linux`, are called *expressions*. An entire command like `ls -l chapter*` is an
    expression too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上输入的字符串，如 `chapter*` 或 `Efficient Linux`，称为*表达式*。像 `ls -l chapter*` 这样的整个命令也是一个表达式。
- en: When the shell interprets and handles special characters in an expression, such
    as asterisks and pipe symbols, we say that the shell *evaluates* the expression.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当 shell 解释和处理表达式中的特殊字符（如星号和管道符号）时，我们称 shell *评估*该表达式。
- en: Pattern matching is one kind of evaluation. When the shell evaluates an expression
    that contains pattern-matching symbols, such as `chapter*`, and replaces it with
    filenames that match the pattern, we say that the shell *expands* the pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种评估方式。当 shell 评估包含模式匹配符号（例如 `chapter*`）的表达式，并用匹配该模式的文件名替换时，我们称 shell *展开*了该模式。
- en: 'Patterns are valid almost anywhere that you’d supply file or directory paths
    on the command line. For example, you can list all files in the directory */etc*
    with names ending in *.conf* using a pattern:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模式几乎可以应用于您在命令行上提供文件或目录路径的任何地方。例如，您可以使用模式列出目录*/etc*中以*.conf*结尾的所有文件：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Be careful using a pattern with a command that accepts just one file or directory
    argument, such as `cd`. You might not get the behavior you expect:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用仅接受一个文件或目录参数的命令与模式一起使用，例如`cd`。您可能得不到您期望的行为：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If a pattern doesn’t match any files, the shell leaves it unchanged to be passed
    literally as a command argument. In the following command, the pattern `*.doc`
    matches nothing in the current directory, so `ls` looks for a filename literally
    named `*.doc` and fails:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模式不匹配任何文件，shell将其保留为未更改的命令参数文字传递。在以下命令中，模式`*.doc`在当前目录中找不到任何匹配项，因此`ls`寻找一个名为`*.doc`的文件名并失败：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When working with file patterns, two points are vitally important to remember.
    The first, as I’ve already emphasized, is that the shell, not the invoked program,
    performs the pattern matching. I know I keep repeating this, but I’m frequently
    surprised by how many Linux users don’t know it and develop superstitions about
    why certain commands succeed or fail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文件模式时，有两个非常重要的要点需要记住。首先，正如我已经强调的，模式匹配由shell执行，而不是调用的程序。我知道我一直在重复这一点，但我经常对多少Linux用户不知道它并且会对某些命令成功或失败发展出迷信感到惊讶。
- en: The second important point is that shell pattern matching applies only to file
    and directory paths. It doesn’t work for usernames, hostnames, and other types
    of arguments that certain commands accept. You also cannot type (say) `s?rt` at
    the beginning of the command line and expect the shell to run the `sort` program.
    (Some Linux commands such as `grep`, `sed`, and `awk` perform their own brands
    of pattern matching, which we’ll explore in [Chapter 5](ch05.xhtml#ch_toolbox).)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要点是shell模式匹配仅适用于文件和目录路径。它不适用于用户名、主机名和某些命令接受的其他类型的参数。您也不能在命令行开头键入（例如）`s?rt`并期望shell运行`sort`程序。（某些Linux命令如`grep`、`sed`和`awk`执行它们自己的模式匹配，我们将在[第5章](ch05.xhtml#ch_toolbox)中探讨。）
- en: Filename Pattern Matching and Your Own Programs
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件名模式匹配和您自己的程序
- en: 'All programs that accept filenames as arguments automatically “work” with pattern
    matching, because the shell evaluates the patterns before the program runs. This
    is true even for programs and scripts you write yourself. For example, if you
    wrote a program `english2swedish` that translated files from English to Swedish
    and accepted multiple filenames on the command line, you could instantly run it
    with pattern matching:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接受文件名作为参数的程序都自动“使用”模式匹配，因为shell在程序运行之前评估模式。即使是您自己编写的程序和脚本也是如此。例如，如果您编写了一个程序`english2swedish`，它将文件从英语翻译成瑞典语并接受命令行上的多个文件名，您可以立即使用模式匹配运行它：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Evaluating Variables
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量评估
- en: A running shell can define variables and store values in them. A shell variable
    is a lot like a variable in algebra—it has a name and a value. An example is the
    shell variable `HOME`. Its value is the path to your Linux home directory, such
    as */home/smith*. Another example is `USER`, whose value is your Linux username,
    which I’ll assume is `smith` throughout this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的shell可以定义变量并将值存储在其中。shell变量与代数中的变量很像——它有一个名称和一个值。一个例子是shell变量`HOME`。它的值是您的Linux主目录路径，例如*/home/smith*。另一个例子是`USER`，其值是您的Linux用户名，我将在本书中假设为`smith`。
- en: 'To print the values of `HOME` and `USER` on stdout, run the command `printenv`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在stdout上打印`HOME`和`USER`的值，请运行`printenv`命令：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the shell evaluates a variable, it replaces the variable name with its
    value. Simply place a dollar sign in front of the name to evaluate the variable.
    For example, `$HOME` evaluates to the string `/home/smith`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当shell评估一个变量时，它将变量名替换为其值。只需在名称前面放置一个美元符号来评估变量。例如，`$HOME`评估为字符串`/home/smith`。
- en: 'The easiest way to watch the shell evaluate a command line is to run the `echo`
    command, which simply prints its arguments (after the shell is finished evaluating
    them):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 观察shell评估命令行最简单的方法是运行`echo`命令，该命令简单地打印其参数（在shell完成评估后）：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Where Variables Come From
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的来源
- en: Variables like `USER` and `HOME` are predefined by the shell. Their values are
    set automatically when you log in. (More on this process later.) Traditionally,
    such predefined variables have uppercase names.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`和`HOME`等变量由shell预定义。它们的值在你登录时自动设置。（稍后详细介绍这个过程。）传统上，这些预定义变量使用大写名称。'
- en: 'You also may define or modify a variable anytime by assigning it a value using
    this syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以随时通过使用以下语法为变量分配一个值来定义或修改变量：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, if you work frequently in the directory */home/smith/Projects*,
    you could assign its name to a variable:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你经常在目录*/home/smith/Projects*中工作，你可以将其名称分配给一个变量：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and use it as a handy shortcut with `cd`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其用作`cd`的便捷快捷方式：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You may supply `$work` to any command that expects a directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`$work`提供给任何期望一个目录的命令：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When defining a variable, no spaces are permitted around the equals sign. If
    you forget, the shell will assume (wrongly) that the first word on the command
    line is a program to run, and the equals sign and value are its arguments, and
    you’ll see an error message:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量时，等号周围不允许有空格。如果你忘记了，shell会错误地假设命令行上的第一个单词是要运行的程序，等号和值则是其参数，你会看到一个错误消息：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A user-defined variable like `work` is just as legitimate and usable as a system-defined
    variable like `HOME`. The only practical difference is that some Linux programs
    change their behavior internally based on the values of `HOME`, `USER`, and other
    system-defined variables. For example, a Linux program with a graphical interface
    might retrieve your username from the shell and display it. Such programs don’t
    pay attention to an invented variable like `work` because they weren’t programmed
    to do so.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似`work`这样的用户定义变量与`HOME`这样的系统定义变量一样合法且可用。唯一的实际区别是，一些Linux程序会根据`HOME`、`USER`和其他系统定义变量的值内部改变其行为。例如，具有图形界面的Linux程序可能会从shell中检索你的用户名并显示它。这些程序不会关注像`work`这样的虚构变量，因为它们没有被编程来这么做。
- en: Variables and Superstition
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量与迷信
- en: 'When you print the value of a variable with `echo`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`echo`打印变量值时：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'you might think that the `echo` command examines the `HOME` variable and prints
    its value. That is *not* the case. `echo` knows nothing about variables. It just
    prints whatever arguments you hand it. What’s really happening is that the shell
    evaluates `$HOME` before running `echo`. From `echo`’s perspective, you typed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为`echo`命令会检查`HOME`变量并打印其值。实际情况并*不*是这样的。`echo`对变量一无所知。它只会打印你传递给它的参数。真正发生的是，在运行`echo`之前，shell会评估`$HOME`。从`echo`的角度来看，你输入的是：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This behavior is extremely important to understand, especially as we delve into
    more complicated commands. The shell evaluates the variables in a command—as well
    as patterns and other shell constructs—before executing the command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为非常重要，特别是在我们深入了解更复杂的命令时。shell在执行命令前会评估命令中的变量，以及模式和其他shell结构。
- en: Patterns Versus Variables
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式与变量
- en: 'Let’s test your understanding of pattern and variable evaluation. Suppose you’re
    in a directory with two subdirectories, *mammals* and *reptiles*, and oddly, the
    *mammals* subdirectory contains files named *lizard.txt* and *snake.txt*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下你对模式和变量评估的理解。假设你在一个包含两个子目录*mammals*和*reptiles*的目录中，奇怪的是*mammals*子目录包含名为*lizard.txt*和*snake.txt*的文件：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the real world, lizards and snakes are not mammals, so the two files should
    be moved to the *reptiles* subdirectory. Here are two proposed ways to do it.
    One works, and one does not:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，蜥蜴和蛇不是哺乳动物，所以这两个文件应该移动到*reptiles*子目录中。以下是两种提议的方法。一种有效，一种无效：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Method 1 works because patterns match an entire file path. See how the directory
    name *mammals* is part of both matches for `mammals/*.txt`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法1有效，因为模式匹配整个文件路径。看看目录名*mammals*如何成为`mammals/*.txt`两个匹配的一部分：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, method 1 operates as if you’d typed the following correct command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方法1操作就像你输入以下正确的命令一样：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Method 2 uses variables, which evaluate to their literal value only. They have
    no special handling for file paths:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 方法2使用的是变量，它们只评估为它们的字面值。它们对文件路径没有特殊处理：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, method 2 operates as if you’d typed the following problematic command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方法2操作就像你输入以下有问题的命令一样：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command looks for the file *snake.txt* in the current directory, not in
    the *mammals* subdirectory, and fails:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在当前目录中查找*snake.txt*文件，而不是*mammals*子目录中，所以失败了：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make a variable work in this situation, use a `for` loop that prepends the
    directory name *mammals* to each filename:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要使变量在这种情况下起作用，请使用 `for` 循环，在每个文件名之前添加目录名 *mammals*：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Shortening Commands with Aliases
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化命令使用别名
- en: 'A variable is a name that stands in for a value. The shell also has names that
    stand in for commands. They’re called *aliases*. Define an alias by inventing
    a name and following it with a equals sign and a command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是代表值的名称。Shell 还有一种代表命令的名称，它们称为*别名*。通过发明一个名称，并在名称后跟等号和一个命令来定义别名：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run an alias by typing its name as a command. When aliases are shorter than
    the commands they invoke, you save typing time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入其名称作为命令来运行别名。当别名比调用的命令更短时，你可以节省打字时间：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Always define an alias on its own line, not as part of a combined command. (See
    `man bash` for the technical details.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将别名定义在单独的行上，而不是作为组合命令的一部分。（有关技术细节，请参阅 `man bash`。）
- en: You can define an alias that has the same name as an existing command, effectively
    replacing that command in your shell. This practice is called *shadowing* the
    command. Suppose you like the `less` command for reading files, but you want it
    to clear the screen before displaying each page. This feature is enabled with
    the `-c` option, so define an alias called “less” that runs `less -c`:^([2](ch02.xhtml#idm46586653823824))
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个与现有命令同名的别名，从而在你的 shell 中有效地替换该命令。这种做法称为*屏蔽*命令。假设你喜欢 `less` 命令用于阅读文件，但你希望它在显示每一页之前清除屏幕。这可以通过
    `-c` 选项启用，因此定义一个名为 “less” 的别名，运行 `less -c`：^([2](ch02.xhtml#idm46586653823824))
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Aliases take precedence over commands of the same name, so you have now shadowed
    the `less` command in the current shell. I’ll explain what *precedence* means
    in [“Search Path and Aliases”](#search_path_aliases).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 别名优先于具有相同名称的命令，因此你现在在当前 shell 中已经屏蔽了 `less` 命令。我将在[“搜索路径和别名”](#search_path_aliases)中解释*优先级*的含义。
- en: 'To list a shell’s aliases and their values, run `alias` with no arguments:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出 shell 的别名及其值，请无参数运行 `alias`：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To see the value of a single alias, run `alias` followed by its name:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看单个别名的值，请运行 `alias`，然后跟随其名称：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To delete an alias from a shell, run `unalias`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 shell 中删除别名，请运行 `unalias`：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Redirecting Input and Output
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向输入和输出
- en: 'The shell controls the input and output of the commands it runs. You’ve already
    seen one example: pipes, which direct the stdout of one command to the stdin of
    another. The pipe syntax, `|`, is a feature of the shell.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 控制其运行的命令的输入和输出。你已经见过一个例子：管道，它将一个命令的 stdout 重定向到另一个命令的 stdin。管道语法 `|` 是
    shell 的一个特性。
- en: 'Another shell feature is redirecting stdout to a file. For example, if you
    use `grep` to print matching lines from the *animals.txt* file from [Example 1-1](ch01.xhtml#example_animals.txt),
    the command writes to stdout by default:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 shell 特性是将 stdout 重定向到文件。例如，如果你使用 `grep` 从 [Example 1-1](ch01.xhtml#example_animals.txt)
    中的 *animals.txt* 文件中打印匹配行，则该命令默认将输出写入 stdout：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can send that output to a file instead, using a shell feature called *output
    redirection*. Simply add the symbol `>` followed by the name of a file to receive
    the output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用称为*输出重定向*的 shell 功能将该输出发送到文件中。只需添加符号 `>`，然后是接收输出的文件名即可：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have just redirected stdout to the file *outfile* instead of the display.
    If the file *outfile* doesn’t exist, it’s created. If it does exist, redirection
    overwrites its contents. If you’d rather append to the output file rather than
    overwrite it, use the symbol `>>` instead:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚将 stdout 重定向到 *outfile* 文件而不是显示器。如果文件 *outfile* 不存在，则会创建它。如果存在，则重定向会覆盖其内容。如果你想要追加而不是覆盖输出文件，请使用
    `>>` 符号：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Output redirection has a partner, *input redirection*, that redirects stdin
    to come from a file instead of the keyboard. Use the symbol `<` followed by a
    filename to redirect stdin.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出重定向还有一个伙伴，*输入重定向*，它将 stdin 重定向到来自文件而不是键盘。使用符号 `<`，然后是文件名来重定向 stdin。
- en: 'Many Linux commands that accept filenames as arguments, and read from those
    files, also read from stdin when run with no arguments. An example is `wc` for
    counting lines, words, and characters in a file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Linux 命令在没有参数运行时，接受文件名作为参数，并从这些文件中读取，同时也可以从 stdin 中读取。例如，用于统计文件中行数、单词数和字符数的
    `wc` 命令就是一个例子：
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It’s *very important* to understand how these two `wc` commands differ in behavior:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这两个 `wc` 命令在行为上的差异*非常重要*：
- en: In the first command, `wc` receives the filename *animals.txt* as an argument,
    so `wc` is aware that the file exists. `wc` deliberately opens the file on disk
    and reads its contents.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个命令中，`wc`接收到文件名*animals.txt*作为参数，所以`wc`知道文件的存在。`wc`会在磁盘上打开文件并读取其内容。
- en: In the second command, `wc` is invoked with no arguments, so it reads from stdin,
    which is usually the keyboard. The shell, however, sneakily redirects stdin to
    come from *animals.txt* instead. `wc` has no idea that the file *animals.txt*
    exists.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个命令中，`wc`被调用时没有参数，所以它从标准输入读取数据，通常是键盘输入。然而，Shell 却巧妙地将标准输入重定向到*animals.txt*文件。`wc`并不知道文件*animals.txt*的存在。
- en: 'The shell can redirect input and output in the same command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 可以在同一条命令中重定向输入和输出：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and can even use pipes at the same time. Here, `grep` reads from redirected
    stdin and pipes the results to `wc`, which writes to redirected stdout, producing
    the file *count*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以同时使用管道。在这里，`grep`从重定向的标准输入读取数据，并将结果通过管道传递给`wc`，后者将结果写入重定向的标准输出，生成文件*count*：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll dive deeper into such combined commands in [Chapter 8](ch08.xhtml#ch_one_liner)
    and see many other examples of redirection throughout the book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第8章](ch08.xhtml#ch_one_liner)深入探讨这类组合命令，并在整本书中看到许多其他重定向的示例。
- en: Disabling Evaluation with Quotes and Escapes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用引号和转义字符禁用评估
- en: 'Normally the shell uses whitespace as a separator between words. The following
    command has four words—a program name followed by three arguments:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Shell 使用空格作为单词之间的分隔符。以下命令包含四个单词——一个程序名称后面跟着三个参数：
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sometimes, however, you need the shell to treat whitespace as significant,
    not as a separator. A common example is whitespace in a filename such as *Efficient
    Linux Tips.txt*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而有时候，你需要Shell将空格视为显著的字符，而不是分隔符。一个常见的例子是文件名中的空格，比如*Efficient Linux Tips.txt*：
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you refer to such a filename on the command line, your command may fail
    because the shell treats the space characters as separators:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在命令行中引用此类文件名，你的命令可能会失败，因为Shell会将空格字符视为分隔符：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To force the shell to treat spaces as part of a filename, you have three options—single
    quotes, double quotes, and backslashes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 强制Shell将空格视为文件名的一部分，你有三种选择——单引号、双引号和反斜杠：
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Single quotes tell the shell to treat every character in a string literally,
    even if the character ordinarily has special meaning to the shell, such as spaces
    and dollar signs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号告诉Shell将字符串中的每个字符都视为文字，即使该字符通常对Shell具有特殊含义，例如空格和美元符号：
- en: '[PRE47]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Double quotes tell the shell to treat all characters literally except for certain
    dollar signs and a few others you’ll learn later:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号告诉Shell将所有字符都视为文字，除了某些美元符号和其他几个你稍后会了解的字符：
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A backslash, also called the *escape character*, tells the shell to treat the
    next character literally. The following command includes an escaped dollar sign:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠，也称为*转义字符*，告诉Shell按照字面意义处理下一个字符。以下命令包含了一个转义的美元符号：
- en: '[PRE49]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Backslashes act as escape characters even within double quotes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在双引号内，反斜杠也作为转义字符：
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'but not within single quotes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但不适用于单引号内：
- en: '[PRE51]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the backslash to escape a double quote character within double quotes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反斜杠转义双引号字符在双引号内部：
- en: '[PRE52]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A backslash at the end of a line disables the special nature of the invisible
    newline character, allowing shell commands to span multiple lines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾的反斜杠可以禁用不可见的换行符的特殊性质，使Shell命令可以跨越多行：
- en: '[PRE53]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Final backslashes are great for making pipelines more readable, like this one
    from [“Command #6: uniq”](ch01.xhtml#section_uniq):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '最后的反斜杠非常适合使管道更易读，就像从[“Command #6: uniq”](ch01.xhtml#section_uniq)中的这个一样：'
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When used this way, the backslash is sometimes called a *line continuation character*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用时，反斜杠有时被称为*行继续字符*。
- en: 'A leading backslash before an alias escapes the alias, causing the shell to
    look for a command of the same name, ignoring any shadowing:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 别名前面的反斜杠会使别名无效，Shell会查找同名命令，忽略任何遮蔽：
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Locating Programs to Be Run
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找要运行的程序
- en: When the shell first encounters a simple command, such as `ls *.py`, it’s just
    a string of meaningless characters. Quick as a flash, the shell splits the string
    into two words, “ls” and “*.py”. In this case, the first word is the name of a
    program on disk, and the shell must locate the program to run it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当Shell首次遇到一个简单命令，比如`ls *.py`时，它只是一串毫无意义的字符。Shell立即将字符串分成两个单词，“ls”和“*.py”。在这种情况下，第一个单词是磁盘上的程序名称，Shell必须找到该程序才能运行它。
- en: 'The program `ls`, it turns out, is an executable file in the directory */bin*.
    You can verify its location with this command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 `ls` 实际上是目录 */bin* 中的可执行文件。您可以使用此命令验证其位置：
- en: '[PRE56]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'or you can change directories with `cd /bin` and run this lovely, cryptic-looking
    command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用 `cd /bin` 更改目录并运行这个可爱的，看起来神秘的命令：
- en: '[PRE57]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: which uses the command `ls` to list the executable file *ls*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ls` 命令列出可执行文件 *ls*。
- en: 'How does the shell locate `ls` in the */bin* directory? Behind the scenes,
    the shell consults a prearranged list of directories that it holds in memory,
    called a *search path*. The list is stored as the value of the shell variable
    `PATH`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: shell 如何在 */bin* 目录中定位 `ls`？在幕后，shell 会咨询一个预先安排好的目录列表，称为*搜索路径*，这个列表存储为 shell
    变量 `PATH` 的值：
- en: '[PRE58]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Directories in a search path are separated by colons (`:`). For a clearer view,
    convert the colons to newline characters by piping the output to the `tr` command,
    which translates one character into another (more details in [Chapter 5](ch05.xhtml#ch_toolbox)):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索路径中的目录由冒号 (`:`) 分隔。为了更清晰的视角，通过管道将输出传输到 `tr` 命令，将冒号转换为换行符，`tr` 命令能够将一个字符翻译成另一个字符（更多细节参见[第五章](ch05.xhtml#ch_toolbox)）：
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The shell consults directories in your search path from first to last when locating
    a program like `ls`. “Does */home/smith/bin/ls* exist? No. Does */usr/local/bin/ls*
    exist? Nope. How about */usr/bin/ls*? No again! Maybe */bin/ls*? Yes, there it
    is! I’ll run */bin/ls*.” This search happens too quickly to notice.^([3](ch02.xhtml#idm46586642464768))
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 shell 定位像 `ls` 这样的程序时，它按顺序从搜索路径中的目录进行查询。“*/home/smith/bin/ls* 存在吗？不。*/usr/local/bin/ls*
    存在吗？也不。那 */usr/bin/ls* 呢？还是不。或许 */bin/ls* 呢？是的，找到了！我将运行 */bin/ls*。” 这个搜索过程非常迅速，几乎察觉不到。^([3](ch02.xhtml#idm46586642464768))
- en: 'To locate a program in your search path, use the `which` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在搜索路径中定位程序，请使用 `which` 命令：
- en: '[PRE60]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: or the more powerful (and verbose) `type` command, a shell builtin that also
    locates aliases, functions, and shell builtins:^([4](ch02.xhtml#idm46586642454096))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更强大（和冗长的）`type` 命令，这是一个 shell 内建命令，也可以定位别名，函数和 shell 内建命令：^([4](ch02.xhtml#idm46586642454096))
- en: '[PRE61]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Your search path may contain the same-named command in different directories,
    such as */usr/bin/less* and */bin/less*. The shell runs whichever command appears
    in the earlier directory in the path. By leveraging this behavior, you can override
    a Linux command by placing a same-named command in an earlier directory in your
    search path, such as your personal *$HOME/bin* directory.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您的搜索路径可能在不同目录中包含相同命名的命令，例如 */usr/bin/less* 和 */bin/less*。Shell 将运行出现在路径中较早目录的命令。通过利用这种行为，您可以在搜索路径中较早的目录（例如个人
    *$HOME/bin* 目录）中放置相同命名的命令来覆盖 Linux 命令。
- en: Search Path and Aliases
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索路径和别名
- en: When the shell searches for a command by name, it checks if that name is an
    alias before checking the search path. That’s why an alias can shadow (take precedence
    over) a command of the same name.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当 shell 按名称搜索命令时，在检查搜索路径之前会先检查该名称是否为别名。这就是为什么别名可以覆盖同名命令的原因。
- en: The search path is a great example of taking something mysterious about Linux
    and showing it has an ordinary explanation. The shell doesn’t pull commands out
    of thin air or locate them by magic. It methodically examines directories in a
    list until it finds the requested executable file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索路径是一个很好的例子，展示了 Linux 中某些神秘事物其实有普通的解释。Shell 不会凭空提取命令或通过魔法定位它们。它会有条不紊地检查列表中的目录，直到找到所请求的可执行文件。
- en: Environments and Initialization Files, the Short Version
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境和初始化文件，简要版
- en: 'A running shell holds a bunch of important information in variables: the search
    path, the current directory, your preferred text editor, your customized shell
    prompt, and more. The variables of a running shell are collectively called the
    shell’s *environment*. When the shell exits, its environment is destroyed.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的 shell 中保存了许多重要信息在变量中：搜索路径，当前目录，首选文本编辑器，定制的 shell 提示符等等。运行中的 shell 中的变量总称为
    shell 的*环境*。当 shell 退出时，它的环境被销毁。
- en: It would be extremely tedious to define every shell’s environment by hand. The
    solution is to define the environment once, in shell scripts called *startup files*
    and *initialization files*, and have every shell execute these scripts on startup.
    The effect is that certain information appears to be “global” or “known” to all
    of your running shells.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个手动定义每个 shell 的环境将非常乏味。解决方案是在称为*启动文件*和*初始化文件*的 shell 脚本中定义环境，并让每个 shell 在启动时执行这些脚本。效果是某些信息似乎“全局”或“已知”于您的所有运行中的
    shell。
- en: 'I’ll dive into the gory details in [“Configuring Your Environment”](ch06.xhtml#section_bash_configs).
    For now, I’ll teach you about one initialization file so you can get through the
    next few chapters. It’s located in your home directory and named *.bashrc* (pronounced
    “dot bash R C”). Because its name begins with a dot, `ls` doesn’t list it by default:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我将深入讲解[“配置你的环境”](ch06.xhtml#section_bash_configs)的细节。现在，我将教你一个初始化文件，让你能够顺利通过接下来的几章。它位于你的主目录中，名为
    *.bashrc*（读作“点 bash R C”）。因为它的名字以点开头，`ls` 默认不会列出它：
- en: '[PRE62]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If *$HOME/.bashrc* doesn’t exist, create it with a text editor. Commands you
    place in this file will execute automatically when a shell starts up,^([5](ch02.xhtml#idm46586642420864))
    so it’s a great place to define variables for the shell’s environment, and other
    things important to the shell, such as aliases. Here is a sample *.bashrc* file.
    Lines beginning with `#` are comments:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *$HOME/.bashrc* 不存在，请使用文本编辑器创建它。你放置在这个文件中的命令将在 shell 启动时自动执行，^([5](ch02.xhtml#idm46586642420864))
    因此这是定义 shell 环境变量和其他对 shell 重要的事物（如别名）的好地方。这是一个示例 *.bashrc* 文件。以 `#` 开头的行是注释：
- en: '[PRE63]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Any changes you make to *$HOME/.bashrc* do not affect any running shells, only
    future shells. You can force a running shell to reread and execute *$HOME/.bashrc*
    with either of the following commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你对 *$HOME/.bashrc* 的任何更改都不会影响任何正在运行的 shell，只会影响未来的 shell。你可以使用以下任何一个命令强制运行中的
    shell 重新读取和执行 *$HOME/.bashrc*：
- en: '[PRE64]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This process is known as *sourcing* the initialization file. If someone tells
    you to “source your dot-bash-R-C file,” they mean run one of the preceding commands.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程称为“源化”初始化文件。如果有人告诉你“源化你的点-bash-R-C 文件”，他们的意思是运行上述命令之一。
- en: Warning
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: In real life, do not put all of your shell configuration in *$HOME/.bashrc*.
    Once you’ve read the details in [“Configuring Your Environment”](ch06.xhtml#section_bash_configs),
    examine your *$HOME/.bashrc* and move commands to their proper files as needed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，不要将所有 shell 配置放在 *$HOME/.bashrc* 中。一旦你阅读了[“配置你的环境”](ch06.xhtml#section_bash_configs)的详细信息，请检查你的
    *$HOME/.bashrc* 并根据需要将命令移到适当的文件中。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'I’ve covered only a tiny number of `bash` features and their most basic uses.
    You’ll see many more in the chapters that follow, particularly in [Chapter 6](ch06.xhtml#ch_parent_child).
    For right now, your most important job is to understand the following concepts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我只涵盖了一小部分 `bash` 的功能及其最基本的用法。在接下来的章节中，特别是[第 6 章](ch06.xhtml#ch_parent_child)，你会看到更多。现在，你最重要的任务是理解以下概念：
- en: The shell exists and has important responsibilities.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shell 存在并且承担着重要责任。
- en: The shell evaluates the command line before running any commands.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shell 在运行任何命令之前评估命令行。
- en: Commands can redirect stdin, stdout, and stderr.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令可以重定向标准输入、标准输出和标准错误。
- en: Quoting and escaping prevent special shell characters from being evaluated.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用和转义可以防止特殊的 shell 字符被评估。
- en: The shell locates programs using a search path of directories.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shell 使用目录搜索路径来定位程序。
- en: You can change a shell’s default behavior by adding commands to the file *$HOME/.bashrc*.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在文件 *$HOME/.bashrc* 中添加命令，你可以更改 shell 的默认行为。
- en: The better you understand the division between the shell and the programs it
    invokes, the more that the command line will make sense, and the better you can
    predict what will happen before you press Enter to run a command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你越了解 shell 与它调用的程序之间的分隔，命令行就会更加合理，你按下 Enter 运行命令前能预测发生的情况也越好。
- en: ^([1](ch02.xhtml#idm46586652391888-marker)) That’s why the command `ls *` doesn’t
    list filenames beginning with a dot, a.k.a. dot files.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm46586652391888-marker)) 这就是为什么命令 `ls *` 不会列出以点开头的文件名（即点文件）。
- en: ^([2](ch02.xhtml#idm46586653823824-marker)) `bash` prevents infinite recursion
    by not expanding the second `less` as an alias.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm46586653823824-marker)) `bash` 通过不将第二个 `less` 扩展为别名来防止无限递归。
- en: ^([3](ch02.xhtml#idm46586642464768-marker)) Some shells memorize (cache) the
    paths to programs as they’re located, cutting down on future searches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm46586642464768-marker)) 一些 shell 会记住（缓存）程序的路径，这样可以减少未来的搜索。
- en: ^([4](ch02.xhtml#idm46586642454096-marker)) Notice that the command `type which`
    produces output, but the command `which type` does not.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm46586642454096-marker)) 请注意，命令 `type which` 会产生输出，但命令 `which
    type` 不会。
- en: ^([5](ch02.xhtml#idm46586642420864-marker)) This statement is oversimplified;
    more details are in [Table 6-1](ch06.xhtml#table_config).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm46586642420864-marker)) 这个声明过于简化；更多细节见[表 6-1](ch06.xhtml#table_config)。
