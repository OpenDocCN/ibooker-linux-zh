- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 介绍
- en: Over the past few decades computing systems have only grown in complexity. Reasoning
    about how software behaves has created multiple business categories, all of them
    trying solve the challenges of gaining insight into complex systems. One approach
    to get this visibility is to analyze the logs of data generated by all applications
    running in a computing system. Logs are a great source of information. They can
    give you precise data about how an application is behaving. However, they constrain
    you because you get only the information that the engineers who built the application
    exposed in those logs. Gathering any additional information in log format from
    any system can be as challenging as decompiling the program and looking at the
    execution flow. Another popular approach is to use metrics to reason why a program
    behaves the way it does. Metrics differ from logs in the data format; whereas
    logs give you explicit data, metrics aggregate data to measure how a program behaves
    at a specific point in time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年里，计算系统的复杂性不断增长。理解软件行为的推理已经创造了多个业务类别，所有这些类别都试图解决获得复杂系统洞察的挑战。获取这种可见性的一种方法是分析计算系统中所有应用程序生成的数据日志。日志是信息的重要来源。它们可以为您提供关于应用程序行为的精确数据。但是，它们也限制您，因为您只能获取应用程序构建工程师在这些日志中公开的信息。以日志格式收集任何额外信息可能与反编译程序并查看执行流程一样具有挑战性。另一种流行的方法是使用指标来推理程序行为的原因。指标在数据格式上与日志不同；日志提供显式数据，而指标聚合数据以衡量程序在特定时间点的行为方式。
- en: '*Observability* is an emergent practice that approaches this problem from an
    different angle. People define observability as the capacity that we have to ask
    arbitrary questions and receive complex answers from any given system. A key difference
    between observability, logs, and metrics aggregation is the data that you collect.
    Given that by practicing observability you need to answer any arbitrary question
    at any point in time, the only way to reason about data is by collecting all of
    the data that your system can generate and aggregating it only when it’s necessary
    to answer your questions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*可观察性* 是一种从不同角度解决此问题的新兴实践。人们定义可观察性为我们能够从任何给定系统中提出任意问题并获得复杂答案的能力。可观察性、日志和指标聚合之间的一个关键区别在于您收集的数据。通过实践可观察性，您需要在任何时间点回答任意问题，因此推理数据的唯一方式是收集系统可以生成的所有数据，并在必要时进行聚合以回答您的问题。'
- en: 'Nassim Nicholas Taleb, the author of best-seller books like *Antifragile: Things
    That Gain From Disorder* (Penguin Random House), popularized the term *Black Swan*
    for unexpected events, with major consequences, that could have been expected
    if they had been observed before they happened. In his book *The Black Swan* (Penguin
    Random House), he rationalizes how having relevant data could help in risk mitigation
    for these rare events. Black Swan events are more common than we think in software
    engineering, and they are inevitable. Because we can assume that we cannot prevent
    these kinds of events, our only option is to have as much information as possible
    about them to address them without affecting business systems in a critical way.
    Observability helps us build robust systems and mitigate future Black Swan events
    because it’s based on the premise that you’re collecting any data that can answer
    any future question. The study of Black Swan events and practicing observability
    converges in one central point, which is in the data that you gather from your
    systems.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 纳西姆·尼古拉斯·塔勒布（Nassim Nicholas Taleb），畅销书作者，如《反脆弱：从混乱中获益的事物》（Penguin Random House），他为意外事件，具有重大后果，如果在其发生之前观察到它们则可以预料到的术语*黑天鹅*提出了流行。在他的书《黑天鹅》（Penguin
    Random House）中，他理性地阐述了如何通过拥有相关数据来帮助减少这些罕见事件的风险。黑天鹅事件在软件工程中比我们想象的更常见，并且是不可避免的。因为我们可以假设无法防止这些事件，我们唯一的选择就是尽可能多地获取关于它们的信息，以在不影响业务系统的情况下解决它们。可观察性帮助我们构建强大的系统并减少未来的黑天鹅事件，因为它基于这样一个前提：您正在收集可以回答任何未来问题的任何数据。研究黑天鹅事件和实践可观察性在一个中心点汇聚，即您从系统中收集的数据。
- en: Linux containers are an abstraction on top of a set of features on the Linux
    kernel to isolate and manage computer processes. The kernel, traditionally in
    charge of resource management, also provides task isolation and security. In Linux,
    the main features that containers are based on are namespaces and cgroups. Namespaces
    are the components that isolate tasks from one another. In a sense, when you’re
    inside a namespace, you experience the operating system like there were no other
    tasks running on the computer. Cgroups are the components that provide resource
    management. From an operational point of view, they give you fine-grained control
    over any resource usage, such as CPU, disk I/O, network, and so on. In the past
    decade, with the raise in popularity of Linux containers, there has been a shift
    in the way software engineers design large distributed systems and compute platforms.
    Multitenant computing has grown completely reliant on these features in the kernel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器是Linux内核上一组功能的抽象，用于隔离和管理计算机进程。传统上负责资源管理的内核还提供了任务隔离和安全性。在Linux中，容器基于的主要功能是命名空间和控制组（cgroups）。命名空间是将任务彼此隔离的组件。从某种意义上说，当您在命名空间内部时，就像在计算机上没有其他任务在运行。控制组是提供资源管理的组件。从操作角度来看，它们为您提供了对CPU、磁盘I/O、网络等任何资源使用的精细控制。在过去的十年中，随着Linux容器的流行，软件工程师设计大型分布式系统和计算平台的方式发生了变化。多租户计算已完全依赖于内核中的这些特性。
- en: By relying so much on the low-level capabilities of the Linux kernel, we’ve
    tapped into a new source of complexity and information that we need to consider
    when we design observable systems. The kernel is an evented system, which means
    that all work is described and executed based on events. Opening files is a kind
    of event, executing an arbitrary instruction by a CPU is an event, receiving a
    network packet is an event, and so on. Berkeley Packet Filter (BPF) is a subsystem
    in the kernel that can inspect those new sources of information. BPF allows you
    to write programs that are safely executed when the kernel triggers any event.
    BPF gives you strong safety guarantees to prevent you from injecting system crashes
    and malicious behavior in those programs. BPF is enabling a new wave of tools
    to help system developers observe and work with these new platforms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如此依赖于Linux内核的低级能力，我们已经利用了一个新的复杂性和信息来源，这些都是我们在设计可观测系统时需要考虑的。内核是一个事件驱动系统，这意味着所有的工作都是基于事件描述和执行的。打开文件是一种事件，CPU执行任意指令是一个事件，接收网络数据包也是一个事件，等等。伯克利数据包过滤器（BPF）是内核中可以检查这些新信息来源的子系统。BPF允许你编写程序，在内核触发任何事件时安全执行。BPF提供强大的安全保证，防止你在这些程序中引入系统崩溃和恶意行为。BPF正在推动一批新工具的出现，帮助系统开发人员观察和处理这些新平台。
- en: In this book, we show you the power that BPF offers you to make any computing
    system more observable. We also show you how to write BPF programs with the help
    of multiple programming languages. We’ve put the code for your programs on GitHub,
    so you don’t need to copy and paste it. You can find it in a Git repository [companion
    to this book](https://oreil.ly/lbpf-repo).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们展示了BPF为您提供的能力，使任何计算系统更易于观察。我们还展示了如何利用多种编程语言编写BPF程序。我们已经将程序代码放在GitHub上，所以您无需复制粘贴。您可以在Git仓库中找到它，[本书的伴随资源](https://oreil.ly/lbpf-repo)。
- en: But before we begin to focus on the technical aspects of BPF, let’s look at
    how everything began.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始专注于BPF的技术方面之前，让我们看看一切是如何开始的。
- en: BPF’s History
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF的历史
- en: 'In 1992, Steven McCanne and Van Jacobson wrote the paper “The BSD Packet Filter:
    A New Architecture for User-Level Packet Capture.” In this paper, the authors
    described how they implemented a network packet filter for the Unix kernel that
    was 20 times faster than the state of the art in packet filtering at the time.
    Packet filters have a specific purpose: to provide applications that monitor the
    system’s network with direct information from the kernel. With this information,
    applications could decide what to do with those packets. BPF introduced two big
    innovations in packet filtering:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 1992年，Steven McCanne和Van Jacobson撰写了论文《BSD数据包过滤器：用于用户级数据包捕获的新架构》。在这篇论文中，作者描述了如何为Unix内核实现一个网络数据包过滤器，其速度比当时的最新技术快20倍。数据包过滤器有一个特定的目的：为监视系统网络的应用程序提供来自内核的直接信息。有了这些信息，应用程序可以决定如何处理这些数据包。BPF在数据包过滤中引入了两个重要的创新：
- en: A new virtual machine (VM) designed to work efficiently with register-based
    CPUs.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于与基于寄存器的CPU高效工作的新虚拟机（VM）。
- en: The usage of per-application buffers that could filter packets without copying
    all the packet information. This minimized the amount of data BPF required to
    make decisions.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用每个应用程序缓冲区来过滤数据包，而无需复制所有数据包信息。这最小化了BPF需要进行决策的数据量。
- en: These drastic improvements made all Unix systems adopt BPF as the technology
    of choice for network packet filtering, abandoning old implementations that consumed
    more memory and were less performant. This implementation is still present in
    many derivatives of that Unix kernel, including the Linux kernel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显著改进使得所有Unix系统都采用了BPF作为网络数据包过滤的首选技术，放弃了消耗更多内存且性能较差的旧实现。这种实现仍然存在于包括Linux内核在内的许多Unix内核衍生系统中。
- en: In early 2014, Alexei Starovoitov introduced the extended BPF implementation.
    This new design was optimized for modern hardware, making its resulting instruction
    set faster than the machine code generated by the old BPF interpreter. This extended
    version also increased the number of registers in the BPF VM from two 32-bit registers
    to ten 64-bit registers. The increase in the number of registers, and in their
    width, opened the possibility to write more complex programs, because developers
    were free to exchange more information using function parameters. These changes,
    among other improvements, made the extended BPF version up to four times faster
    than the original BPF implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年初，Alexei Starovoitov引入了扩展BPF实现。这种新设计针对现代硬件进行了优化，使其生成的指令集比旧BPF解释器生成的机器码更快。扩展版本还将BPF虚拟机中的寄存器数量从两个32位寄存器增加到十个64位寄存器。寄存器数量的增加以及它们的宽度打开了编写更复杂程序的可能性，因为开发人员可以通过函数参数交换更多信息。这些变化及其他改进使扩展BPF版本比原始BPF实现快了多达四倍。
- en: The initial goal for this new implementation was to optimize the internal BPF
    instruction set that processed network filters. At this point, BPF was still restricted
    to kernel-space, and only a few programs in user-space could write BPF filters
    for the kernel to process, like Tcpdump and Seccomp, which we talk about in later
    chapters. Today, these programs still generate bytecode for the old BPF interpreter,
    but the kernel translates those instructions to the much improved internal representation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新实现的最初目标是优化处理网络过滤器的内部BPF指令集。在这一点上，BPF仍然局限于内核空间，只有少数用户空间程序可以编写BPF过滤器供内核处理，例如Tcpdump和Seccomp，我们将在后面的章节中讨论。如今，这些程序仍然为旧BPF解释器生成字节码，但内核将这些指令转换为大大改进的内部表示形式。
- en: In June 2014, the extended version of BPF was exposed to user-space. This was
    an inflection point for the future of BPF. As Alexei wrote in the patch that introduced
    these changes, “This patch set demonstrates the potential of eBPF.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年6月，扩展版BPF暴露给了用户空间。这是BPF未来的一个转折点。正如Alexei在引入这些更改的补丁中所写道：“这个补丁集展示了eBPF的潜力。”
- en: BPF became a top-level kernel subsystem, and it stopped being limited to the
    networking stack. BPF programs began to look more like kernel modules, with a
    big emphasis on safety and stability. Unlike kernel modules, BPF programs don’t
    require you to recompile your kernel, and they are guaranteed to complete without
    crashing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BPF成为顶级内核子系统，并不再局限于网络堆栈。BPF程序开始看起来更像内核模块，非常注重安全性和稳定性。与内核模块不同，BPF程序不需要重新编译内核，并且保证在不崩溃的情况下完成执行。
- en: 'The BPF verifier, which we talk about in the next chapter, added these required
    safety guarantees. It ensures that any BPF program will complete without crashing,
    and it ensures that programs don’t try to access memory out of range. These advantages
    come with certain restrictions, though: programs have a maximum size allowed,
    and loops need to be bounded to ensure that the system’s memory is never exhausted
    by a bad BPF program.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下一章中将讨论的BPF验证器添加了这些必需的安全性保证。它确保任何BPF程序都能在不崩溃的情况下完成执行，并确保程序不会尝试访问超出范围的内存。然而，这些优势也带来了一些限制：程序有最大允许的大小，并且循环必须是有界的，以确保系统内存永远不会被糟糕的BPF程序耗尽。
- en: With the changes to make BPF accessible from user-space, the kernel developers
    also added a new system call (syscall), `bpf`. This new syscall will be the central
    piece of communication between user-space and the kernel. We discuss how to use
    this syscall to work with BPF programs and maps in Chapters [2](ch02.html#running_your_first_BPF_programs)
    and [3](ch03.html#bpf_maps) of this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着使 BPF 从用户空间可访问的更改，内核开发人员还添加了一个新的系统调用（syscall），`bpf`。这个新的 syscall 将成为用户空间和内核之间通信的中心组成部分。我们将在本书的第
    [2](ch02.html#running_your_first_BPF_programs) 和 [3](ch03.html#bpf_maps) 章中讨论如何使用这个
    syscall 来处理 BPF 程序和映射。
- en: BPF maps will become the main mechanism to exchange data between the kernel
    and user-space. [Chapter 2](ch02.html#running_your_first_BPF_programs) demonstrates
    how to use these specialized structures to collect information from the kernel
    as well as send information to BPF programs that are already running in the kernel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: BPF 映射将成为内核和用户空间之间交换数据的主要机制。[第 2 章](ch02.html#running_your_first_BPF_programs)
    展示了如何使用这些专门的结构从内核收集信息，以及向已在内核中运行的 BPF 程序发送信息。
- en: The extended BPF version is the starting point for this book. In the past five
    years, BPF has evolved significantly since the introduction of this extended version,
    and we cover in detail the evolution of BPF programs, BPF maps, and kernel subsystems
    that have been affected by this evolution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 BPF 版本是本书的起点。在过去的五年中，自从引入这个扩展版本以来，BPF 已经有了显著的进展，我们详细介绍了 BPF 程序、BPF 映射以及受这一进展影响的内核子系统的演变。
- en: Architecture
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: BPF’s architecture within the kernel is fascinating. We dive into its specific
    details through the entire book, but we want to give you a quick overview about
    how it works in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: BPF 内核中的架构是非常迷人的。我们会在整本书中深入探讨其具体细节，但在本章中，我们想为您快速概述其工作原理。
- en: As we mentioned earlier, BPF is a highly advanced VM, running code instructions
    in an isolated environment. In a sense, you can think of BPF like how you think
    about the Java Virtual Machine (JVM), a specialized program that runs machine
    code compiled from a high-level programming language. Compilers like LLVM, and
    GNU Compiler Collection (GCC) in the near future, provide support for BPF, allowing
    you to compile C code into BPF instructions. After your code is compiled, BPF
    uses a verifier to ensure that the program is safe to run by the kernel. It prevents
    you from running code that might compromise your system by crashing the kernel.
    If your code is safe, the BPF program will be loaded in the kernel. The Linux
    kernel also incorporates a just-in-time (JIT) compiler for BPF instructions. The
    JIT will transform the BPF bytecode into machine code directly after the program
    is verified, avoiding this overhead on execution time. One interesting aspect
    of this architecture is that you don’t need to restart your system to load BPF
    programs; you can load them on demand, and you can also write your own init scripts
    that load BPF programs when your system starts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，BPF 是一个高度先进的虚拟机，在隔离环境中运行代码指令。在某种意义上，您可以将 BPF 看作是 Java 虚拟机（JVM）的工作方式，一个专门运行从高级编程语言编译而成的机器码的程序。编译器如
    LLVM 和 GNU Compiler Collection（GCC）在不久的将来将提供对 BPF 的支持，允许您将 C 代码编译为 BPF 指令。在编译完成后，BPF
    使用验证器确保程序在内核中运行时安全。它通过阻止可能会导致内核崩溃的代码运行来保护您的系统。如果您的代码是安全的，BPF 程序将加载到内核中。Linux 内核还整合了用于
    BPF 指令的即时编译器（JIT）。JIT 将在程序验证后直接将 BPF 字节码转换为机器码，避免执行时间上的额外开销。这种架构的一个有趣之处在于，您不需要重新启动系统来加载
    BPF 程序；您可以按需加载它们，并且您还可以编写自己的 init 脚本，在系统启动时加载 BPF 程序。
- en: Before the kernel runs any BPF program, it needs to know which execution point
    the program is attached to. There are multiple attachment points in the kernel,
    and the list is growing. The execution points are defined by the BPF program types;
    we discuss them in the next chapter. When you choose an execution point, the kernel
    also makes available specific function helpers that you can use to work with the
    data that your program receives, making execution points and BPF programs tightly
    coupled.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核运行任何 BPF 程序之前，它需要知道程序连接到哪个执行点。内核中有多个连接点，并且该列表正在增长。执行点由 BPF 程序类型定义；我们将在下一章中讨论它们。当您选择一个执行点时，内核还会提供特定的函数助手，您可以使用这些助手来处理程序接收到的数据，从而使执行点和
    BPF 程序紧密耦合。
- en: The final component in BPF’s architecture is responsible for sharing data between
    the kernel and user-space. This component is called a BPF *map*, and we talk about
    maps in [Chapter 3](ch03.html#bpf_maps). BPF maps are bidirectional structures
    to share data. This means that you can write and read them from both sides, the
    kernel and user-space. There are several types of structures, from simple arrays
    and hash maps to specialized maps, that allow you to save entire BPF programs
    in them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: BPF 架构中的最后一个组件负责在内核和用户空间之间共享数据。这个组件称为 BPF *map*，我们在[第三章](ch03.html#bpf_maps)中讨论了关于地图的内容。BPF
    地图是双向结构，用于共享数据。这意味着你可以从内核和用户空间两方面写入和读取它们。有几种类型的结构，从简单的数组和哈希映射到专门的映射，允许你在其中保存整个
    BPF 程序。
- en: We cover every component in BPF’s architecture in more detail as the book progresses.
    You’ll also learn to take advantage of BPF’s extensibility and data sharing, with
    specific examples covering topics ranging from stack trace analysis to network
    filtering and runtime isolation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的进展，我们将更详细地介绍 BPF 架构中的每个组件。您还将学习如何利用 BPF 的可扩展性和数据共享，具体示例涵盖从堆栈跟踪分析到网络过滤和运行时隔离的主题。
- en: Conclusion
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We wrote this book to help you become familar with the basic BPF concepts that
    you’re going to need in your day-to-day work with this Linux subsystem. BPF is
    still a technology in development, and new concepts and paradigms are growing
    as we are writing this book. Ideally, this book will help you expand your knowledge
    easily by giving you a solid base of BPF’s foundational components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写这本书是为了帮助你熟悉与 Linux 子系统 BPF 日常工作中需要的基本概念。BPF 仍然是一项发展中的技术，随着我们写作本书，新的概念和范式也在不断增长。理想情况下，这本书将通过为你提供
    BPF 基础组件的坚实基础来轻松扩展你的知识。
- en: The next chapter dives directly into the structure of BPF programs and how the
    kernel runs them. It also covers the points in the kernel where you can attach
    those programs. This will help you become familiar with all the data that your
    programs can consume and how to use it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章直接深入探讨了 BPF 程序的结构以及内核如何运行它们。它还涵盖了你可以附加这些程序的内核中的各个点。这将帮助你熟悉你的程序可以消耗的所有数据及其使用方法。
