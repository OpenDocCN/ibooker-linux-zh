- en: Chapter 5\. CO-RE, BTF, and Libbpf
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。CO-RE、BTF和Libbpf
- en: In the previous chapter you encountered BTF (BPF Type Format) for the first
    time. This chapter discusses why it exists and how it’s used to make eBPF programs
    portable across different versions of the kernel. It’s a key part of BPF’s compile
    once, run everywhere (CO-RE) approach, which solves the problem of making eBPF
    programs portable across different kernel versions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您首次遇到了BTF（BPF类型格式）。本章讨论了它存在的原因以及如何使用它使eBPF程序在不同内核版本间可移植。这是BPF“编译一次，到处运行”（CO-RE）方法的关键部分，解决了在不同内核版本间实现eBPF程序可移植性的问题。
- en: Many eBPF programs access kernel data structures, and an eBPF programmer would
    need to include relevant Linux header files so that their eBPF code can correctly
    locate fields within those data structures. However, the Linux kernel is under
    continuous development, which means internal data structures can change between
    different kernel versions. If you were to take an eBPF object file compiled on
    one machine^([1](ch05.html#ch05fn1)) and load it onto a machine with a different
    kernel version, there would be no guarantee that the data structures would be
    the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多eBPF程序访问内核数据结构，eBPF程序员需要包含相关的Linux头文件，以便他们的eBPF代码可以正确地定位这些数据结构中的字段。然而，Linux内核在持续开发中，这意味着内部数据结构在不同内核版本间可能会发生变化。如果您将在一台机器上编译的eBPF对象文件加载到具有不同内核版本的机器上，不能保证数据结构会保持一致。
- en: The CO-RE approach is a huge step forward in addressing this portability issue
    in an efficient way. It allows eBPF programs to include information about the
    data structure layouts they were compiled with, and it provides a mechanism for
    adjusting how fields are accessed if the data structure layout is different on
    the target machine where they run. Provided the program doesn’t want to access
    a field or data structure that simply doesn’t exist in the target machine’s kernel,
    the program is portable across different kernel versions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE方法在有效解决这一可移植性问题方面迈出了重要的一步。它允许eBPF程序包含有关它们编译时所用数据结构布局的信息，并提供了一种机制，用于调整在目标机器上运行时数据结构布局不同情况下字段访问的方式。只要程序不需要访问目标机器内核中根本不存在的字段或数据结构，程序就能在不同内核版本间实现可移植性。
- en: But before we dive into the details of how CO-RE works, let’s discuss why it
    was so desirable, by looking at the previous approach to kernel portability as
    originally implemented in the BCC project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入讨论CO-RE如何工作之前，让我们看看为什么它是如此令人向往的，通过观察最初在BCC项目中实现的内核可移植性的先前方法。
- en: BCC’s Approach to Portability
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BCC对可移植性的方法
- en: 'In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor) I used [BCC](https://oreil.ly/ReUtn)
    to show a basic “Hello World” example of an eBPF program. The BCC project was
    the first popular project for implementing eBPF programs, providing a framework
    for both the user space and kernel aspects that’s relatively accessible to programmers
    without much kernel experience. To address portability across kernels, BCC took
    the approach of compiling eBPF code at runtime, in situ on the destination machine.
    There are a number of issues with this approach:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中，我使用[BCC](https://oreil.ly/ReUtn)展示了eBPF程序的基本“Hello
    World”示例。BCC项目是第一个流行的用于实现eBPF程序的项目，为没有太多内核经验的程序员提供了一个相对易于使用的用户空间和内核方面的框架。为了解决跨内核的可移植性问题，BCC采用了在目标机器上即时编译eBPF代码的方法。然而，这种方法存在一些问题：
- en: The compilation toolchain needs to be installed on every destination machine
    where you want the code to run, as well as the kernel header files (which aren’t
    always present by default).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译工具链需要安装在每台希望运行代码的目标机器上，还需要内核头文件（这些文件通常不会默认存在）。
- en: You have to wait for the compilation to complete before the tool starts, which
    could mean a delay of several seconds, every time the tool is launched.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工具启动之前，您必须等待编译完成，这可能意味着每次启动工具都会有几秒钟的延迟。
- en: If you’re running the tool on a large fleet of identical machines, repeating
    the compilation on each machine is a waste of compute resources.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在大量相同的机器群上运行工具，每台机器上都重复编译是一种计算资源的浪费。
- en: Some BCC-based projects package their eBPF source code and the toolchain into
    a container image, which makes distribution to each machine easier. But it doesn’t
    solve the problem of ensuring that the kernel headers are present, and it can
    even mean more duplication if several of these BCC containers are installed on
    each machine.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些基于BCC的项目将它们的eBPF源代码和工具链打包到一个容器映像中，这使得将其分发到每台机器更加容易。但这并不能解决确保内核头文件存在的问题，甚至可能意味着如果安装了多个这些BCC容器，则会有更多的重复。
- en: Embedded devices might not have sufficient memory resources to run the compilation
    step.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式设备可能没有足够的内存资源来运行编译步骤。
- en: Because of these issues, if you’re planning to embark on developing a significant
    new eBPF project, I would not recommend using this legacy BCC approach for it,
    especially if you’re planning to distribute it for others to use. In this book
    I’ve given some examples based on BCC because it’s a good approach for learning
    about the basic concepts of eBPF, particularly because the Python user space code
    is so compact and easy to read. It’s also a perfectly good choice if you’re more
    comfortable with it and you want to put something together quickly. But it’s not
    the best approach for serious modern eBPF development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些问题，如果你计划开始开发一个重要的新eBPF项目，我不建议使用这种传统的BCC方法，尤其是如果你计划将其分发给其他人使用。在本书中，我给出了一些基于BCC的示例，因为它是了解eBPF基本概念的好方法，特别是因为Python用户空间代码如此紧凑且易于阅读。如果你更喜欢使用它，并且想要快速组装一些东西，那么它也是一个完全不错的选择。但是对于严肃的现代eBPF开发来说，它并不是最佳选择。
- en: The CO-RE approach offers a much better solution to the problem of cross-kernel
    portability for eBPF programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE方法为eBPF程序的跨内核可移植性问题提供了一个更好的解决方案。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The BCC project at [*github.com/iovisor/bcc*](https://oreil.ly/ReUtn) includes
    a wide range of command-line tools for observing all sorts of information about
    how a Linux machine is behaving. The original versions located in the [*tools*](https://oreil.ly/fI4w_)
    directory are mostly implemented in Python using this legacy approach to portability
    that I have described in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: BCC项目位于[*github.com/iovisor/bcc*](https://oreil.ly/ReUtn)，包含广泛的命令行工具，用于观察Linux机器行为的各种信息。位于[*tools*](https://oreil.ly/fI4w_)目录中的原始版本大多使用Python实现，使用了我在本节中描述的传统可移植性方法。
- en: In BCC’s [*libbpf-tools*](https://oreil.ly/ke7yq) directory, you’ll find updated
    versions of these tools written in C that take advantage of *libbpf* and CO-RE
    and that don’t suffer from the problems I’ve just listed. They are an incredibly
    useful set of utilities!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在BCC的[*libbpf-tools*](https://oreil.ly/ke7yq)目录中，你会找到使用C编写的更新版本的这些工具，利用了*libbpf*和CO-RE，并且不会遇到我刚刚列出的问题。它们是一套非常有用的实用工具集！
- en: CO-RE Overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO-RE概述
- en: The CO-RE approach consists of a few elements:^([2](ch05.html#ch05fn2))^,^([3](ch05.html#ch05fn3))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE方法由几个元素组成：^([2](ch05.html#ch05fn2))^,^([3](ch05.html#ch05fn3))
- en: BTF
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: BTF
- en: '[BTF](https://oreil.ly/iRCuI) is a format for expressing the layout of data
    structures and function signatures. In CO-RE it’s used to determine any differences
    between the structures used at compilation time and at runtime. BTF is also used
    by tools like `bpftool` to dump data structures in human-readable formats. Linux
    kernels from 5.4 onward support BTF.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[BTF](https://oreil.ly/iRCuI) 是用于表示数据结构布局和函数签名的格式。在CO-RE中，它用于确定编译时和运行时使用的结构之间的任何差异。像`bpftool`这样的工具也使用BTF来以人类可读的格式转储数据结构。从Linux内核5.4版本开始支持BTF。'
- en: Kernel headers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核头文件
- en: The Linux kernel source code includes header files that describe the data structures
    it uses, and these headers can change between versions of Linux. eBPF programmers
    can choose to include individual header files, or, as you’ll see in this chapter,
    you can use `bpftool` to generate a header file called *vmlinux.h* from a running
    system, containing all the data structure information about a kernel that a BPF
    program might need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核源代码包括描述其使用的数据结构的头文件，这些头文件在不同版本的Linux之间可能会发生变化。eBPF程序员可以选择包含单独的头文件，或者如本章所示，可以使用`bpftool`从运行中的系统生成一个名为*vmlinux.h*的头文件，其中包含BPF程序可能需要的有关内核的所有数据结构信息。
- en: Compiler support
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器支持
- en: The [Clang compiler was enhanced](https://oreil.ly/6xFJm) so that when it compiles
    eBPF programs with the `-g` flag, it includes what are known as *CO-RE relocations*,
    derived from the BTF information describing the kernel data structures. The GCC
    compiler also added CO-RE support for BPF targets in [version 12](https://oreil.ly/_6PEE).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Clang 编译器使用 `-g` 标志编译带有 *CO-RE 重定位* 的 eBPF 程序时，它包含了从描述内核数据结构的 BTF 信息中导出的内容。GCC
    编译器也在版本 12 中为 BPF 目标添加了 CO-RE 支持。
- en: Library support for data structure relocations
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数据结构重定位的库支持
- en: 'At the point where a user space program loads an eBPF program into the kernel,
    the CO-RE approach requires the bytecode to be adjusted to compensate for any
    differences between the data structures present when it was compiled, and what’s
    on the destination machine where it’s about to run, based on the CO-RE relocation
    information compiled into the object. There are a few libraries that will take
    care of this: [*libbpf*](https://oreil.ly/E742u) was the original C library that
    includes this relocation capability, the Cilium eBPF library provides the same
    capability for Go programmers, and Aya does it for Rust.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间程序将 eBPF 程序加载到内核时，CO-RE 方法要求调整字节码以补偿编译时存在的数据结构与目标机器上实际运行时的差异，这是基于编译到对象中的
    CO-RE 重定位信息。有几个库可以处理这个问题：*libbpf* 是最初的 C 库，包含这种重定位能力；Cilium 的 eBPF 库为 Go 程序员提供了同样的功能；Aya
    则为 Rust 提供了支持。
- en: Optionally, a BPF skeleton
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，BPF 骨架
- en: A skeleton can be auto-generated from a compiled BPF object file, containing
    handy functions that user space code can call to manage the lifecycle of BPF programs—loading
    them into the kernel, attaching them to events, and so on. If you’re writing the
    user space code in C, you can generate the skeleton with `bpftool gen skeleton`.
    These functions are higher-level abstractions that can be more convenient for
    the developer than using the underlying library (*libbpf*, *cilium/ebpf*, etc.)
    directly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架可以从编译后的 BPF 对象文件自动生成，其中包含了方便用户空间代码调用的实用函数，用于管理 BPF 程序的生命周期——将它们加载到内核中，将它们附加到事件上等。如果您使用
    C 编写用户空间代码，可以使用 `bpftool gen skeleton` 生成这些骨架。这些函数是比直接使用底层库（*libbpf*、*cilium/ebpf*
    等）更方便的高级抽象。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Andrii Nakryiko wrote an [excellent blog post](https://oreil.ly/aeQJo) that
    describes the background of CO-RE, as well as laying out how it works and how
    to use it. He also wrote the canonical [BPF CO-RE Reference Guide](https://oreil.ly/lbW_T),
    so please do read that if you’re embarking on writing code yourself. His [*libbpf-bootstrap*
    guide](https://oreil.ly/_jet-) to building an eBPF app from scratch with CO-RE
    + *libbpf* + skeletons is another must-read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Andrii Nakryiko 写了一篇关于 CO-RE 背景的[卓越博客文章](https://oreil.ly/aeQJo)，并详细介绍了其工作原理及如何使用。他还撰写了权威的[BPF
    CO-RE 参考指南](https://oreil.ly/lbW_T)，如果您准备自行编写代码，请务必阅读。他的 *libbpf-bootstrap* 指南则介绍了使用
    CO-RE + *libbpf* + 骨架从头开始构建 eBPF 应用的方法，也是另一个必读资源。
- en: Now that you have an overview of the elements of CO-RE, let’s dig in to see
    how they work, starting with an exploration of BTF.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对 CO-RE 的元素有了概述，让我们深入了解它们的工作原理，从探索 BTF 开始。
- en: BPF Type Format
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF 类型格式
- en: BTF information describes how data structures and code are laid out in memory.
    This information can be put to a variety of different uses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: BTF 信息描述了数据结构和代码在内存中的布局方式。这些信息可以用于各种不同的用途。
- en: BTF Use Cases
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BTF 使用案例
- en: The main reason for discussing BTF in this chapter on CO-RE is that knowing
    the differences between a structure’s layout where an eBPF program was compiled
    and where it is about to run allows for the appropriate adjustments to be made
    as the program is loaded into the kernel. I’ll discuss the relocation process
    later in this chapter, but for now, let’s also consider some of the other uses
    to which BTF information can be put.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论 BTF 在本章关于 CO-RE 中的主要原因是，了解在编译 eBPF 程序的结构布局与将要运行的结构布局之间的差异，允许在程序加载到内核时进行适当的调整。我将在本章后面讨论重定位过程，但现在，让我们也考虑一些
    BTF 信息可以用于的其他用途。
- en: Knowing how a structure is laid out, and the type of every field in that structure,
    makes it possible to pretty-print a structure’s contents in human-readable form.
    For example, a string is just a series of bytes from the computer’s point of view,
    but converting those bytes into characters makes the string much easier for humans
    to understand. You already saw an example of this in the previous chapter, where
    `bpftool` used BTF information to format the output of map dumps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 知道结构体的布局方式及其每个字段的类型，可以使结构体的内容以人类可读的形式进行漂亮打印。例如，从计算机的角度来看，字符串只是一系列字节，但将这些字节转换为字符可以使字符串更易于人类理解。您在前一章已经看到了一个例子，其中
    `bpftool` 使用 BTF 信息来格式化映射转储的输出。
- en: BTF information also includes the line and function information that enables
    `bpftool` to interleave source code within the output from translated or JITed
    program dumps, as you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    When you come to [Chapter 6](ch06.html#the_ebpf_verifier), you’ll also see the
    source code information interleaved with the verifier log output, and again this
    comes from the BTF information.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: BTF 信息还包括行和函数信息，使 `bpftool` 能够在从翻译或 JIT 编译的程序转储的输出中插入源代码，正如您在 [第 3 章](ch03.html#anatomy_of_an_ebpf_program)
    中看到的那样。当您阅读 [第 6 章](ch06.html#the_ebpf_verifier) 时，您还将看到源代码信息与验证器日志输出交错，这同样来自于
    BTF 信息。
- en: 'BTF information is also required for BPF spin locks. *Spin locks* are used
    to stop two CPU cores from simultaneously accessing the same map values. The lock
    has to be part of the map’s value structure, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: BTF 信息还需要用于 BPF 自旋锁。*自旋锁* 用于阻止两个 CPU 核同时访问相同的映射值。锁必须是映射值结构体的一部分，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Within the kernel, eBPF programs use `bpf_spin_lock()` and `bpf_spin_unlock()`
    helper functions to acquire and release a lock. These helpers can be used only
    if BTF information is available to describe where the lock field is within the
    structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核内部，eBPF 程序使用 `bpf_spin_lock()` 和 `bpf_spin_unlock()` 辅助函数来获取和释放锁。只有在有可用的
    BTF 信息描述锁字段所在位置时，才能使用这些辅助函数。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Spin lock support was added in kernel version 5.1\. There are lots of restrictions
    on the use of spin locks: they can only be used on hash or array map types, and
    they can’t be used in tracing or socket filter type eBPF programs. Read more about
    spin locks in the [lwn.net article on concurrency management in BPF](https://oreil.ly/kAyAU).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自旋锁支持是在内核版本 5.1 中添加的。对于自旋锁的使用有很多限制：它们只能用于哈希或数组映射类型，并且不能在跟踪或套接字过滤类型的 eBPF 程序中使用。更多关于自旋锁的信息，请参阅
    [lwn.net 上有关 BPF 并发管理的文章](https://oreil.ly/kAyAU)。
- en: Now that you know why BTF information is useful, let’s make it more concrete
    by looking at some examples.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道 BTF 信息的用处，让我们通过查看一些示例来更具体化。
- en: Listing BTF Information with bpftool
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `bpftool` 列出 BTF 信息
- en: 'As with programs and maps, you can use the `bpftool` utility to show BTF information.
    The following command lists all the BTF data loaded into the kernel:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序和地图一样，您可以使用 `bpftool` 实用程序显示 BTF 信息。以下命令列出加载到内核中的所有 BTF 数据：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (I’ve omitted many entries from the results for brevity.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: （为了简洁起见，我省略了结果中的许多条目。）
- en: The first entry in the list is `vmlinux`, and it corresponds to the *vmlinux*
    file I mentioned earlier that holds the BTF information about the currently running
    kernel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一项是 `vmlinux`，它对应我之前提到的 *vmlinux* 文件，其中包含有关当前运行内核的 BTF 信息。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the examples early in this chapter reuse the programs from [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    and then later in this chapter you’ll find new examples for which the source is
    in the *chapter5* directory at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早期的一些示例重用了 [第 4 章](ch04.html#the_bpfleft_parenthesisright_parenthesi) 的程序，然后在本章后期，您将找到新的示例，这些示例的源代码位于
    [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    的 *chapter5* 目录中。
- en: 'To obtain this example output I ran this command while the `hello-buffer-config`
    example from [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) was
    running. You can see the entry describing the BTF information that this process
    is using, on the line that starts with `149:`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取此示例输出，我在运行 [第 4 章](ch04.html#the_bpfleft_parenthesisright_parenthesi) 的 `hello-buffer-config`
    示例时运行了此命令。您可以在以 `149:` 开头的行上看到描述此过程正在使用的 BTF 信息的条目：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s what that line is telling us:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉我们以下内容：
- en: This chunk of BTF information has ID 149.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此 BTF 信息块的 ID 是 149。
- en: It’s an anonymous blob of around 4 KB of BTF information.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个大约 4 KB 的匿名 BTF 信息块。
- en: It’s used by the BPF program with `prog_id 319` and the BPF map with `map_id
    103`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被具有 `prog_id 319` 的 BPF 程序和具有 `map_id 103` 的 BPF 映射使用。
- en: It’s also used by the process with ID 7660 (shown within parentheses) running
    the `hello-buffer-config` executable (whose name has been truncated to 15 characters).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还被进程 ID 7660（括号内显示）运行的 `hello-buffer-config` 可执行文件使用（其名称已截断为 15 个字符）。
- en: 'These program, map, and BTF identifiers match with the following output that
    `bpftool` shows about `hello-buffer-config`’s program called `hello`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序、映射和 BTF 标识符与 `bpftool` 显示的有关 `hello-buffer-config` 的名为 `hello` 的程序的输出匹配：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only thing that doesn’t appear to match completely between these two sets
    of information is that the program refers to an extra `map_id`, `104`. That’s
    the perf event buffer map, and it doesn’t use BTF information; hence, it doesn’t
    appear in the BTF-related output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一似乎完全不匹配的是程序引用了额外的 `map_id`，`104`。这是性能事件缓冲区映射，并且不使用 BTF 信息；因此，它不会出现在与 BTF 相关的输出中。
- en: Much like `bpftool` can dump the contents of programs and maps, it can also
    be used to view the BTF type information contained in a blob of data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `bpftool` 可以转储程序和映射的内容一样，它也可以用来查看数据块中包含的 BTF 类型信息。
- en: BTF Types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BTF 类型
- en: 'Knowing the ID of the BTF information, you can inspect its contents with the
    command `bpftool btf dump id <id>`. When I ran this using the ID 149 that I obtained
    earlier, I got 69 lines of output, each of which is a type definition. I’ll just
    describe the first few lines, which should give you a good idea of how to interpret
    the rest. The BTF information from these first few lines relates to the `config`
    hash map, which was defined in the source code like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 知道 BTF 信息的 ID 后，您可以使用命令 `bpftool btf dump id <id>` 检查其内容。当我使用之前获取的 ID 149 运行这个命令时，我得到了
    69 行输出，每行都是一个类型定义。我将描述前几行，这应该能让您了解如何解释其余部分。这些首几行的 BTF 信息与在源代码中如此定义的 `config` 哈希映射相关：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This hash table has keys of type `u32` and values of type `struct user_msg_t`.
    That structure holds a 12-byte `message` field. Let’s see how these types are
    defined in the corresponding BTF information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此哈希表的键类型为 `u32`，值类型为 `struct user_msg_t`。该结构包含一个 12 字节的 `message` 字段。让我们看看这些类型在对应的
    BTF 信息中是如何定义的。
- en: 'The first three lines of the BTF output are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: BTF 输出的前三行如下：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The number in square brackets at the start of each line is the type ID (so
    the first line, starting with `[1]`, defines `type_id 1`, etc.). Let’s dive into
    these three types in more detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每行开头的方括号中的数字是类型 ID（因此第一行，以 `[1]` 开头的行定义了 `type_id 1`，依此类推）。让我们更详细地探讨这三种类型：
- en: Type 1 defines a type named `u32` and its type, defined by `type_id 2`, that
    is, the type defined in the line that starts with `[2]`. As you know, the keys
    in the hash table have this type `u32`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 1 定义了名为 `u32` 的类型及其类型，由以 `[2]` 开头的行定义，即哈希表中键的类型为 `u32`。
- en: Type 2 has the name `__u32` and the type defined by `type_id 3`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 2 的名称为 `__u32`，类型由 `type_id 3` 定义。
- en: Type 3 is an integer type with the name `unsigned int`, which is 4 bytes long.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 3 是一个名为 `unsigned int` 的整数类型，长度为 4 字节。
- en: All three of these types are synonyms for a 32-bit unsigned integer type. In
    C, the lengths of integers are platform dependent, so Linux defines types like
    `u32` to explicitly define integers of specific lengths. On this machine, `u32`
    corresponds to an unsigned integer. User space code that refers to these should
    use the synonym prefixed with underscores, as in `__u32`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型都是指 32 位无符号整数类型的同义词。在 C 中，整数的长度取决于平台，因此 Linux 定义了诸如 `u32` 这样的类型，明确地定义了特定长度的整数。在此机器上，`u32`
    对应于无符号整数。引用这些的用户空间代码应该使用前缀带下划线的同义词，如 `__u32`。
- en: 'The next few types in the BTF output look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: BTF 输出的接下来几个类型如下：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These relate to the `user_msg_t` structure used for values in the `config`
    map:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关联到 `config` 映射中值为 `user_msg_t` 结构的类型：
- en: Type 4 is the `user_msg_t` structure itself, and in total it is 12 bytes long.
    It contains one field named `message`, which is defined by type 6\. The `vlen`
    field indicates how many fields there are in this definition.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 4 是 `user_msg_t` 结构本身，总长度为 12 字节。它包含一个名为 `message` 的字段，由类型 6 定义。`vlen` 字段指示这个定义中有多少个字段。
- en: Type 5 is named `char` and is a 1-byte integer—exactly the definition a C programmer
    would expect for a type called “char.”
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 5 名为 `char`，是一个 1 字节的整数——这正是 C 程序员对名为“char”类型的定义期望的内容。
- en: Type 6 defines the type for that `message` field as an array with 12 elements.
    Each element has type 5 (it’s a `char`), and the array is indexed by type 7.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型6将`message`字段的类型定义为具有12个元素的数组。每个元素的类型为5（它是一个`char`），并且数组由类型7索引。
- en: Type 7 is a 4-byte integer.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型7是一个4字节整数。
- en: With these definitions, you can build a complete picture of how the `user_msg_t`
    structure is laid out in memory, as illustrated in [Figure 5-1](#a_user_msg_t_structure_takes_onetwo_byt).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些定义，你可以完整地了解`user_msg_t`结构在内存中的布局，如[图 5-1](#a_user_msg_t_structure_takes_onetwo_byt)所示。
- en: '![A user_msg_t structure takes 12 bytes of memory](assets/lebp_0501.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![一个`user_msg_t`结构占用12字节内存](assets/lebp_0501.png)'
- en: Figure 5-1\. A `user_msg_t` structure takes 12 bytes of memory
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 一个`user_msg_t`结构占用12字节内存
- en: 'So far, all the entries have `bits_offset` set to `0`, but the next line of
    output has a structure with more than one field:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的条目都将`bits_offset`设置为`0`，但是下一行输出的结构具有多个字段：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a structure definition for the key–value pairs stored in the map called
    `config`. I didn’t define this `____btf_map_config` type myself in the source
    code, but it has been generated by BCC. The key is of type `u32`, and the value
    is the `user_msg_t` structure. These correspond to the types 1 and 4 that you
    saw earlier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是存储在名为`config`的映射中的键值对的结构定义。我没有在源代码中定义这种`____btf_map_config`类型，但它是由BCC生成的。键的类型是`u32`，值是`user_msg_t`结构。这对应于您之前看到的类型1和类型4。
- en: The other important part of the BTF information about this structure is that
    the `value` field starts 32 bits after the start of the structure. That completely
    makes sense because the first 32 bits are needed to hold the `key` field.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个结构的BTF信息的另一个重要部分是，`value`字段从结构的起始位置后32位开始。这完全是有道理的，因为前32位用于保存`key`字段。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In C, structure fields get automatically aligned to boundaries, so you can’t
    simply assume that one field always follows directly after the previous one in
    memory. For example, consider a structure like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，结构字段会自动对齐到边界，因此不能简单地假设一个字段总是紧跟在前一个字段的后面。例如，考虑这样一个结构：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There would be 7 bytes of unused memory after the field called `letter` before
    the `number` field so that the 64-bit number can be aligned to a memory location
    divisible by 8.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段称为`letter`之后，在`number`字段之前有7字节的未使用内存，以便64位数字可以对齐到可以被8整除的内存位置。
- en: It’s possible in some circumstances to turn on compiler packing to avoid this
    unused space, but it generally results in lower performance and—at least in my
    experience—it’s unusual to do so. More often, C programmers will design structures
    by hand to make efficient use of space.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可以启用编译器的紧凑排列来避免这些未使用的空间，但通常会导致性能下降，并且——至少在我的经验中——很少这样做。更常见的是，C程序员会手动设计结构以有效利用空间。
- en: Maps with BTF Information
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有BTF信息的映射
- en: You’ve just seen the BTF information associated with a map. Now let’s see how
    this BTF data is passed to the kernel when the map is created.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到了与映射关联的BTF信息。现在让我们看看在创建映射时，这些BTF数据如何传递给内核。
- en: 'You saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) that
    maps are created using the `bpf(BPF_MAP_CREATE)` syscall. This takes a `bpf_attr`
    structure as a parameter, [defined in the kernel](https://oreil.ly/PLrYG) like
    this (some details omitted):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到，映射是使用`bpf(BPF_MAP_CREATE)`系统调用创建的。这需要一个`bpf_attr`结构作为参数，[在内核中定义](https://oreil.ly/PLrYG)如下（省略了一些细节）：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before the introduction of BTF, the `btf_*` fields weren’t present in this `bpf_attr`
    structure, and the kernel had no knowledge of the structure of keys or values.
    The `key_size` and `value_size` fields defined how much memory was required for
    them, but they were just treated as so many bytes. By additionally passing in
    the BTF information defining the types of the keys and values, the kernel can
    introspect them, and utilities like `bpftool` can retrieve the type information
    for pretty-printing, as discussed earlier. However, it’s interesting to note that
    separate BTF `type _id`s are passed in for the key and the value. The `____btf_map_config`
    structure that you just saw defined isn’t used by the kernel for the map definition;
    it’s just used by BCC on the user space side.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入BTF之前，`btf_*`字段不存在于`bpf_attr`结构中，内核不了解键或值的结构。`key_size`和`value_size`字段定义了它们所需的内存量，但它们只是被视为一些字节。通过额外传入定义键和值类型的BTF信息，内核可以内省它们，像`bpftool`这样的工具可以检索用于漂亮打印的类型信息，正如前面讨论的那样。但是有趣的是，为键和值分别传入了单独的BTF
    `type _id`。刚才看到的`____btf_map_config`结构并不被内核用于映射定义；它只是由用户空间的BCC使用。
- en: BTF Data for Functions and Function Prototypes
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和函数原型的BTF数据
- en: 'So far the BTF data in this example output has related to data types, but the
    BTF data also contains information about functions and function prototypes. Here’s
    the information from the same BTF data blob that describes the `hello` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个示例输出中，BTF数据与数据类型有关，但BTF数据还包含有关函数和函数原型的信息。以下是描述`hello`函数的同一BTF数据块中的信息：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In type 32 you can see the function named `hello` is defined as having the
    type defined in the previous line. That’s a *function prototype*, which returns
    a value of type ID `23` and takes a single parameter (`vlen=1`) called `ctx` with
    type ID `10`. For completeness, here are the definitions of those types from earlier
    in the output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型32中，您可以看到名为`hello`的函数被定义为具有前一行中定义的类型。这是一个*函数原型*，它返回类型ID `23`，并采用单个参数(`vlen=1`)称为`ctx`，其类型ID为`10`。为了完整起见，这里是前面输出中那些类型的定义：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Type 10 is an anonymous pointer with the default type of `0`, which isn’t explicitly
    included in the BTF output but is defined as a void pointer.^([4](ch05.html#ch05fn4))
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类型10是一个匿名指针，其默认类型为`0`，在BTF输出中没有明确包含，但定义为void指针。^([4](ch05.html#ch05fn4))
- en: 'The return value with type 23 is a 4-byte integer, and `encoding=SIGNED` indicates
    that it’s a signed integer; that is, it can have either a positive or negative
    value. This corresponds to the function definition in the source code of *hello-buffer-config.py*,
    which looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值类型为23，是一个4字节整数，`encoding=SIGNED`表示它是一个有符号整数；也就是说，它可以是正数或负数。这对应于源代码中*hello-buffer-config.py*中的函数定义，如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The example BTF information I’ve shown so far comes from listing the contents
    of a blob of BTF data. Let’s see how to obtain just the BTF information that relates
    to a particular map or program.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示的示例BTF信息来自于列出BTF数据块内容。让我们看看如何获取与特定映射或程序相关的BTF信息。
- en: Inspecting BTF Data for Maps and Programs
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查映射和程序的BTF数据
- en: 'If you want to inspect the BTF types associated with a particular map, `bpftool`
    makes that easy. For example, here’s the output for the `config` map:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查与特定映射相关的BTF类型，`bpftool`使这变得容易。例如，这是`config`映射的输出：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similarly, you can inspect the BTF information related to a particular program
    with `bpftool btf dump prog <prog identity>`. I’ll leave you to check out the
    [manpage](https://oreil.ly/lCoV5) for additional details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以使用`bpftool btf dump prog <prog identity>`检查与特定程序相关的BTF信息。我会让您查看[manpage](https://oreil.ly/lCoV5)以获取更多详细信息。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’d like to better understand how the BTF type data is generated and de-duplicated,
    there is another [excellent blog post from Andrii Nakryiko](https://oreil.ly/0-a9g)
    on the subject.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地理解如何生成和去重BTF类型数据，请参阅Andrii Nakryiko的另一篇[优秀博客文章](https://oreil.ly/0-a9g)。
- en: By this stage you should have an understanding of how BTF describes the format
    of data structures and functions. An eBPF program written in C needs header files
    that define the types and structures. Let’s see how easy it is to generate a header
    file for any kernel data types that an eBPF program might need.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您应该已经了解了BTF如何描述数据结构和函数的格式。一个用C编写的eBPF程序需要定义类型和结构的头文件。让我们看看为eBPF程序可能需要的任何内核数据类型生成头文件是多么简单。
- en: Generating a Kernel Header File
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成内核头文件
- en: 'If you run `bpftool btf list` on a BTF-enabled kernel, you’ll see lots of preexisting
    blobs of BTF data that look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在启用了BTF的内核上运行`bpftool btf list`，您将看到许多类似以下的预存在BTF数据块：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first item in this list, with ID 1 and named `vmlinux`, is the BTF information
    about all the data types, structures, and function definitions used by the kernel
    that’s running on this (virtual) machine.^([5](ch05.html#ch05fn5))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的第一项，ID为1，名称为`vmlinux`，是关于所有数据类型、结构和函数定义的BTF信息，这些定义由运行在此（虚拟）机器上的内核使用。^([5](ch05.html#ch05fn5))
- en: An eBPF program needs the definitions of any kernel data structures and types
    that it is going to refer to. Before the days of CO-RE, you’d typically have to
    figure out which of the many individual header files in the Linux kernel source
    held the definition for the structures you were interested in, but now there is
    a much easier way, as BTF-enabled tools can generate an appropriate header file
    from the BTF information included with the kernel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个eBPF程序需要任何它将引用的内核数据结构和类型的定义。在CO-RE出现之前，您通常需要弄清楚Linux内核源代码中的许多单独头文件中哪些包含您感兴趣的结构的定义，但现在有了一个更简单的方法，因为启用BTF的工具可以从内核中包含的BTF信息生成一个适当的头文件。
- en: 'This header file is conventionally called *vmlinux.h*, and you can generate
    it with `bpftool` like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件通常称为*vmlinux.h*，您可以像这样使用`bpftool`生成它：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This file defines all the kernel’s data types, so including this generated *vmlinux.h*
    file in your eBPF program source supplies the definitions of any Linux data structures
    you might need. When you compile the source into an eBPF object file, that object
    will include BTF information that matches the definitions used in this header
    file. Later, when the program is run on a target machine, the user space program
    that loads it into the kernel will make adjustments to account for differences
    between this build-time BTF information and the BTF information for the kernel
    that’s running on that target machine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了所有内核的数据类型，因此，在您的eBPF程序源代码中包含此生成的*vmlinux.h*文件将提供您可能需要的任何Linux数据结构的定义。当您将源代码编译为eBPF对象文件时，该对象将包含与此头文件中使用的定义匹配的BTF信息。稍后，在目标机器上运行程序时，将加载它到内核中的用户空间程序将调整以解决此构建时BTF信息与运行在目标机器上的内核的BTF信息之间的差异。
- en: BTF information in the form of the */sys/kernel/btf/vmlinux* file has been included
    in the Linux kernel since version 5.4,^([6](ch05.html#ch05fn6)) but raw BTF data
    that *libbpf* can make use of can also be generated for older kernels. In other
    words, if you want to run a CO-RE–enabled eBPF program on a target machine that
    doesn’t have BTF information already, you might be able to provide the BTF data
    for that target yourself. There’s information on how to generate BTF files, and
    an archive of files for a variety of Linux distributions, on the [BTFHub](https://oreil.ly/mPSO0).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux内核版本5.4以来，以*/sys/kernel/btf/vmlinux*文件形式的BTF信息已被包含在Linux内核中。^([6](ch05.html#ch05fn6))但是，libbpf可以利用的原始BTF数据也可以为旧内核生成。换句话说，如果您希望在目标机器上运行支持CO-RE的eBPF程序，而该目标机器没有BTF信息，您可能可以自己提供该目标机器的BTF数据。关于如何生成BTF文件以及各种Linux发行版的文件存档，请访问[BTFHub](https://oreil.ly/mPSO0)获取更多信息。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The BTFHub repo also includes further reading about [BTF internals](https://oreil.ly/CfyQh)
    should you want to dive deeper into this topic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: BTFHub仓库还包括有关[BTF internals](https://oreil.ly/CfyQh)的进一步阅读，如果您希望深入了解此主题。
- en: Next, let’s look at how this and other tactics are used to write eBPF programs
    to be portable across kernels using CO-RE.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用这些策略以及其他策略来编写可通过CO-RE在各种内核间移植的eBPF程序。
- en: CO-RE eBPF Programs
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO-RE eBPF程序
- en: You’ll recall that eBPF programs run in the kernel. Later in this chapter I’ll
    show some user space code that will interact with the code running in the kernel,
    but in this section I’m concentrating on the kernel side.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您将回忆起eBPF程序在内核中运行。本章稍后将展示一些与内核中运行代码进行交互的用户空间代码，但本节集中在内核端。
- en: As you’ve already seen, eBPF programs are compiled to eBPF bytecode, and (at
    least at the time of this writing) the compilers that support this are Clang or
    gcc for compiling C code, and the Rust compiler. I’ll discuss some of your options
    for using Rust in [Chapter 10](ch10.html#ebpf_programming), but for the purposes
    of this chapter I’ll assume you’re writing in C and using Clang, along with the
    *libbpf* library.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的那样，eBPF程序被编译成eBPF字节码，（至少在撰写本文时）支持此功能的编译器有Clang或gcc用于编译C代码，以及Rust编译器。在[第10章](ch10.html#ebpf_programming)中，我将讨论一些使用Rust的选项，但在本章的目的上，我将假设你是在C中编写并使用Clang，以及*libbpf*库。
- en: For the remainder of this chapter, let’s consider an example application called
    *hello-buffer-config*. It’s very similar to the *hello-buffer-config.py* example
    from the previous chapter that used the BCC framework, but this version is written
    in C to use *libbpf* and CO-RE.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，让我们考虑一个名为*hello-buffer-config*的示例应用程序。它与前一章中使用BCC框架的*hello-buffer-config.py*示例非常相似，但此版本是用C编写的，以使用*libbpf*和CO-RE。
- en: If you have BCC-based eBPF code that you want to migrate to *libbpf*, check
    out the excellent and comprehensive [guide by Andrii Nakryiko on his website](https://oreil.ly/iWDcv).
    BCC provides some convenient shortcuts that aren’t handled in quite the same way
    using *libbpf*; conversely, *libbpf* provides its own set of macros and library
    functions to make life easier for the eBPF programmer. As I walk through the example,
    I will point out a few differences between the BCC and *libbpf* approaches.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有基于BCC的eBPF代码想要迁移到*libbpf*，请查看Andrii Nakryiko在他的网站上提供的出色且全面的[指南](https://oreil.ly/iWDcv)。BCC提供了一些便捷的快捷方式，而使用*libbpf*并不完全相同；反之，*libbpf*提供了一套宏和库函数，使eBPF程序员的生活更加轻松。当我讲解示例时，我将指出BCC和*libbpf*方法之间的一些区别。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the example C eBPF program to accompany this section in the *chapter5*
    directory of the [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    repo.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    repo的*chapter5*目录中找到本节的示例C eBPF程序。
- en: First let’s look at *hello-buffer-config.bpf.c*, which implements the eBPF program
    that runs in the kernel. Later in the chapter I’ll show you the user space code
    in *hello-buffer-config.c* that loads the program and displays output, much as
    the Python code did in the BCC implementation of this example in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看*hello-buffer-config.bpf.c*，它实现了在内核中运行的eBPF程序。本章后面我会展示用户空间代码*hello-buffer-config.c*，它加载程序并显示输出，类似于Python代码在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中BCC实现的例子。
- en: Like any C program, an eBPF program will need to include some header files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何C程序一样，eBPF程序也需要包含一些头文件。
- en: Header Files
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'The first few lines of *hello-buffer-config.bpf.c* specify the header files
    that it needs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello-buffer-config.bpf.c*的前几行指定了它所需要的头文件：'
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These five files are the *vmlinux.h* file, a few headers from *libbpf*, and
    an application-specific header file that I wrote myself. Let’s see why this is
    a typical pattern for the header files needed for a *libbpf* program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些五个文件是*vmlinux.h*文件，来自*libbpf*的几个头文件，以及我自己编写的一个应用程序特定的头文件。让我们看看为*libbpf*程序所需的头文件为什么是一个典型模式。
- en: Kernel header information
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核头信息
- en: If you’re writing an eBPF program that refers to any kernel data structures
    or types, the easiest option is to include the *vmlinux.h* file described earlier
    in this chapter. Alternatively, it’s possible to include individual header files
    from the Linux source, or to define the types by hand in your own code if you
    really want to go to that trouble. If you’re going to use any BPF helper functions
    from *libbpf*, you’ll need to include either *vmlinux.h* or *linux/types.h* to
    get the definitions for types like `u32`, `u64`, and so on, that the BPF helper
    source refers to.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的eBPF程序涉及任何内核数据结构或类型，最简单的选择是在本章前面描述的*vmliux.h*文件中包含它。或者，可以从Linux源中包含单独的头文件，或者如果你真的愿意的话，可以在自己的代码中手动定义类型。如果你将使用*libbpf*中的任何BPF助手函数，你需要包含*vmlinux.h*或*linux/types.h*以获取BPF助手源引用的`u32`、`u64`等类型的定义。
- en: The *vmlinux.h* file is derived from the kernel source headers, but it doesn’t
    include `#define`’d values from them. For example, if your eBPF program parses
    Ethernet packets, you’ll probably need the constant definitions that tell you
    what protocol the packet contains (such as `0x0800` to indicate that it’s an IP
    packet, or `0x0806` for an ARP packet). There is a series of constant values that
    you’ll need to duplicate in your own code, if you don’t include the [*if_ether.h*
    file](https://oreil.ly/hoZzP) that defines these values for the kernel. I didn’t
    need any of these value definitions for *hello-buffer-config*, but you’ll see
    another example in [Chapter 8](ch08.html#ebpf_for_networking) where this is relevant.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*vmlinux.h*文件源自内核源码头文件，但不包括来自它们的`#define`值。例如，如果你的eBPF程序解析以太网数据包，你可能需要常量定义来确定数据包的协议（比如`0x0800`表示IP数据包，或者`0x0806`表示ARP数据包）。有一系列常量值需要在你自己的代码中复制，如果你没有包含定义这些值的[*if_ether.h*文件](https://oreil.ly/hoZzP)。我在*hello-buffer-config*中不需要任何这些值定义，但在[第8章](ch08.html#ebpf_for_networking)中你会看到另一个例子，这里是相关的。'
- en: Headers from libbpf
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自libbpf的头文件
- en: To use any BPF helper functions in your eBPF code, you’ll need to include the
    header files from *libbpf* that give you their definitions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的eBPF代码中使用任何BPF辅助函数，你需要包含*libbpf*提供的头文件，这些头文件给出了它们的定义。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One thing that can be slightly confusing about *libbpf* is that it’s not just
    a user space library. You’ll find yourself including header files from *libbpf*
    in both user space and eBPF C code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*可能会让人稍感困惑的一点是，它不仅仅是一个用户空间库。你会发现自己在用户空间和eBPF C代码中都包含*libbpf*的头文件。'
- en: At the time of this writing, it is common to see eBPF projects including *libbpf*
    as a submodule and building/installing from source—this is what I have done in
    the example repository for this book. If you include it as a submodule, you’ll
    simply need to run `make install` from the *libbpf/src* directory. I don’t think
    it will be long before it’s more common to see *libbpf* widely available as a
    package on common Linux distributions, particularly since *libbpf* has now passed
    the milestone of a [version 1.0 release](https://oreil.ly/8BFq6).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，看到将*libbpf*作为子模块包含并从源代码构建/安装是很常见的——这是我在本书示例库中所做的。如果你将其作为子模块包含，你只需从*libbpf/src*目录运行`make
    install`即可。我认为不久之后，*libbpf*将更普遍地作为常见Linux发行版上的一个包提供，特别是因为*libbpf*现在已经发布了1.0版本的里程碑。
- en: Application-specific headers
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于应用程序的头文件
- en: 'It’s very common to have an application-specific header file that defines any
    structures that are used by both the user space and eBPF parts of your app. In
    my example, the *hello-buffer-config.h* header file defines the `data_t` structure
    that I’m using to pass event data from the eBPF program to user space. It’s almost
    the same structure you saw in the BCC version of this code, and it looks like
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个特定于应用程序的头文件是非常常见的，该头文件定义了用户空间和eBPF应用程序部分都使用的任何结构。在我的示例中，*hello-buffer-config.h*头文件定义了我用来从eBPF程序传递事件数据到用户空间的`data_t`结构。它几乎与这段代码的BCC版本中看到的结构相同，如下所示：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only difference from the version you saw before is that I have added a field
    called `path`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前版本唯一的区别是我添加了一个名为`path`的字段。
- en: The reason to pull this structure definition into a separate header file is
    that I will also refer to it from the user space code in *hello-buffer-config.c*.
    In the BCC version, the kernel and user space code were both defined in a single
    file, and BCC did some work behind the scenes to make the structure available
    to the Python user space code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个结构定义拉入一个单独的头文件的原因是，我将在*hello-buffer-config.c*用户空间代码中引用它。在BCC版本中，内核和用户空间代码都定义在一个文件中，BCC在幕后做了一些工作，使得这个结构对Python用户空间代码可用。
- en: Defining Maps
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义映射
- en: 'After including the header files, the next few lines of the source code in
    *hello-buffer-config.bpf.c* define the structures used for maps, like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含头文件之后，源代码*hello-buffer-config.bpf.c*中的接下来几行定义了用于映射的结构，如下所示：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This requires more lines of code than I needed in the equivalent BCC example!
    With BCC, the map called `config` was created with the following macro:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我在等效的BCC示例中所需的代码行数更多！在BCC中，称为`config`的映射是用以下宏创建的：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This macro isn’t available when you’re not using BCC, so in C you have to write
    it out longhand. You’ll see that I have used `__uint` and `__type`. These are
    defined in [*bpf/bpf_helpers_def.h*](https://oreil.ly/2FgjB) along with `__array`,
    like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用BCC时，此宏不可用，因此在C语言中，您必须手动编写它。您会看到我使用了`__uint`和`__type`。这些与[*bpf/bpf_helpers_def.h*](https://oreil.ly/2FgjB)中定义的`__array`一起使用，如下所示：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These macros generally seem to be used by convention in *libbpf*-based programs,
    and I think they make the map definitions a little easier to read.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*libbpf*基于程序中通常按惯例使用这些宏，我认为它们使地图定义变得更容易阅读。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The name “config” clashed with a definition in *vmlinux.h*, so I renamed the
    map “my_config” for this example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 名称“config”与*vmlinux.h*中的定义冲突，因此我将地图重命名为“my_config”以供此示例使用。
- en: eBPF Program Sections
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: eBPF程序部分
- en: 'Use of *libbpf* requires each eBPF program to be marked with a `SEC()` macro
    that defines the program type, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*libbpf*需要每个eBPF程序都标记为使用`SEC()`宏定义程序类型，如下所示：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This results in a section called `kprobe` in the compiled ELF object, so *libbpf*
    knows to load this as a `BPF_PROG_TYPE_KPROBE`. We’ll discuss different program
    types further in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在编译后的ELF对象中生成一个名为`kprobe`的部分，因此*libbpf*知道将其加载为`BPF_PROG_TYPE_KPROBE`。我们将在[第7章](ch07.html#ebpf_program_and_attachment_types)中进一步讨论不同的程序类型。
- en: 'Depending on the program type, you can also use the section name to specify
    what event the program will be attached to. The *libbpf* library will use this
    information to set up the attachment automatically, rather than leaving you to
    do it explicitly in your user space code. So, for example, to auto-attach to the
    kprobe for the `execve` syscall on an ARM-based machine, you could specify the
    section like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据程序类型的不同，您还可以使用部分名称来指定程序将附加到的事件。*libbpf*库将使用此信息自动设置附加项，而不是让您在用户空间代码中显式执行。例如，在基于ARM的机器上自动附加到`execve`系统调用的kprobe，您可以像这样指定部分名称：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This requires you to know the function name for the syscall on that architecture
    (or figure it out, perhaps by looking at the */proc/kallsyms* file on your target
    machine, which lists all the kernel symbols, including its function names). But
    *libbpf* can make life even easier for you with the `k(ret)syscall` section name,
    which tells the loader to attach to the kprobe in the architecture-specific function
    automatically:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求您知道该体系结构上该系统调用的函数名（或通过查看目标机器上的*/proc/kallsyms*文件找出，该文件列出所有内核符号，包括其函数名）。但是*libbpf*可以通过`k(ret)syscall`部分名称让您的生活更轻松，该名称告诉加载器自动附加到体系结构特定函数中的kprobe：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The valid section names and formats are listed in the [*libbpf* documentation](https://oreil.ly/FhHrm).
    In the past, the requirements for section names were much looser, so you may come
    across eBPF programs written before *libbpf 1.0* with section names that don’t
    match the valid set. Don’t let them confuse you!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[*libbpf*文档](https://oreil.ly/FhHrm)列出了有效的部分名称和格式。过去，部分名称的要求要宽松得多，因此您可能会遇到在*libbpf
    1.0*之前编写的部分名称不匹配有效集的eBPF程序。不要让它们让您困惑！'
- en: 'The section definition declares where the eBPF program should be attached,
    and then the program itself follows. As before, the eBPF program itself is written
    as a C function. In the example code it’s called `hello()`, and it’s extremely
    similar to the `hello()` function you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
    Let’s consider the differences between that previous version and the version here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 部分定义声明了eBPF程序应附加的位置，然后是程序本身。与以前一样，eBPF程序本身被编写为C函数。在示例代码中，它称为`hello()`，与您在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到的`hello()`函数非常相似。让我们考虑前一个版本与这里版本之间的区别：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#code_id_5_1)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_5_1)'
- en: I’ve taken advantage of a [`BPF_KPROBE_SYSCALL`](https://oreil.ly/pgI1B) macro
    defined in *libbpf* that makes it easy to access the arguments to a syscall by
    name. For `execve()`, the first argument is the pathname for the program that’s
    going to be executed. The eBPF program name is `hello`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我利用了在*libbpf*中定义的[`BPF_KPROBE_SYSCALL`](https://oreil.ly/pgI1B)宏，通过名字轻松访问系统调用的参数。对于`execve()`来说，第一个参数是将要执行的程序的路径名。eBPF程序的名称是`hello`。
- en: '[![2](assets/2.png)](#code_id_5_2)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_5_2)'
- en: Since the macro has made it so easy to access that pathname argument to `execve()`,
    I’m including it in the data sent to the perf buffer output. Notice that copying
    memory requires the use of a BPF helper function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏使得访问`execve()`的路径名参数变得如此容易，我将其包含在发送到性能缓冲区输出的数据中。请注意，复制内存需要使用BPF辅助函数。
- en: '[![3](assets/3.png)](#code_id_5_3)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_5_3)'
- en: Here, `bpf_map_lookup_elem()` is the BPF helper function for looking up values
    in a map, given a key. BCC’s equivalent of this would be `p = my_config.lookup(&data.uid)`.
    BCC rewrites this to use the underlying `bpf_map_lookup_elem()` function before
    it passes the C code to the compiler. When you’re using *libbpf*, there is no
    rewriting of the code before compilation,^([7](ch05.html#ch05fn7)) so you have
    to write directly to the helper functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bpf_map_lookup_elem()`是BPF地图中查找值的辅助函数，给定一个键。BCC的等效操作将是`p = my_config.lookup(&data.uid)`。在将C代码传递给编译器之前，BCC会重写此操作以使用底层的`bpf_map_lookup_elem()`函数。当您使用*libbpf*时，在编译之前不会对代码进行任何重写，^([7](ch05.html#ch05fn7))因此您必须直接写入辅助函数。
- en: '[![4](assets/4.png)](#code_id_5_4)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_5_4)'
- en: Here’s another similar example where I have written directly to the helper function
    `bpf_perf_event_output()`, where BCC gave me the convenient equivalent `output.perf_submit(ctx,
    &data, sizeof(data))`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个类似的例子，我直接向辅助函数`bpf_perf_event_output()`写入了数据，在这里BCC给了我方便的等效操作`output.perf_submit(ctx,
    &data, sizeof(data))`。
- en: 'The only other difference is that in the BCC version, I defined the message
    string as a local variable within the `hello()` function. BCC doesn’t (at least
    at the time of this writing) support global variables. In this version I have
    defined it as a global variable, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的另一个区别是，在BCC版本中，我将消息字符串定义为`hello()`函数内的局部变量。BCC不支持（至少在撰写本文时不支持）全局变量。在此版本中，我将其定义为全局变量，如下所示：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In *chapter4/hello-buffer-config.py* the `hello` function was defined rather
    differently, like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在*chapter4/hello-buffer-config.py*中，`hello`函数的定义方式略有不同，如下所示：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `BPF_KPROBE_SYSCALL` macro is one of the convenient additions from *libbpf*
    that I mentioned. You’re not required to use the macro, but it makes life easier.
    It does all the heavy lifting to provide named arguments for all the parameters
    passed to a syscall. In this case, it supplies a `pathname` argument that points
    to a string holding the path of the executable that is about to be run, which
    is the first argument to the `execve()` syscall.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_KPROBE_SYSCALL`宏是我提到的*libbpf*中的一个方便的新增功能之一。您不必使用该宏，但它会让生活变得更容易。它负责为传递给系统调用的所有参数提供命名参数。在这种情况下，它提供了一个`pathname`参数，该参数指向即将运行的可执行文件的路径字符串，这是传递给`execve()`系统调用的第一个参数。'
- en: 'If you’re paying very close attention you might notice that the `ctx` variable
    isn’t visibly defined in my source code for *hello-buffer-config.bpf.c*, but nevertheless,
    I’ve been able to use it when submitting data to the output perf buffer, like
    this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您非常仔细地注意，您可能会注意到在我的*hello-buffer-config.bpf.c*源代码中，`ctx`变量在可见定义中并不存在，但尽管如此，我仍然能够在向输出性能缓冲区提交数据时使用它：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `ctx` variable does exist, hidden within the `BPF_KPROBE_SYSCALL` macro
    definition inside [*bpf/bpf_tracing.h*](https://oreil.ly/pgI1B), in *libbpf*,
    where you’ll also find some commentary about this. It can be slightly confusing
    to use a variable that’s not visibly defined, but it’s very helpful that it can
    be accessed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctx`变量确实存在，隐藏在*libbpf*中[*bpf/bpf_tracing.h*](https://oreil.ly/pgI1B)内的`BPF_KPROBE_SYSCALL`宏定义中，您也会在其中找到一些关于此的评论。使用一个不明确定义的变量可能会让人感到有些困惑，但它非常有用，因为它可以被访问。'
- en: Memory Access with CO-RE
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CO-RE下的内存访问
- en: eBPF programs for tracing have restricted access to memory, via a BPF helper
    function from the `bpf_probe_read_*()` family.^([8](ch05.html#ch05fn8)) (There
    is also a `bpf_probe_write_user()` helper function, but it’s only [“meant for
    experiments”](https://oreil.ly/ibcy1)). The problem is that, as you’ll see in
    the next chapter, the eBPF verifier generally won’t let you simply read memory
    through a pointer as you usually can in C (e.g., `x = p->y`).^([9](ch05.html#ch05fn9))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跟踪的eBPF程序对内存的访问受到限制，通过`bpf_probe_read_*()`家族的BPF辅助函数。^([8](ch05.html#ch05fn8))（还有一个`bpf_probe_write_user()`辅助函数，但它仅用于[“实验”](https://oreil.ly/ibcy1)）。问题在于，正如您将在下一章看到的，eBPF验证器通常不会允许您像在C中通常可以那样简单地通过指针读取内存（例如，`x
    = p->y`）。^([9](ch05.html#ch05fn9))
- en: 'The *libbpf* library provides CO-RE wrappers around the `bpf_probe_read_*()`
    helpers to take advantage of the BTF information and make memory access calls
    portable across different kernel versions. Here’s an example of one of those wrappers,
    as defined in the [*bpf_core_read.h* header file](https://oreil.ly/XWWyc):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库提供了围绕`bpf_probe_read_*()`助手函数的CO-RE包装器，以利用BTF信息并使内存访问调用跨不同内核版本可移植。以下是其中一个包装器的示例，如[*bpf_core_read.h*头文件](https://oreil.ly/XWWyc)中所定义：'
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, `bpf_core_read()` calls directly to `bpf_probe_read_kernel()`,
    the only difference being that it wraps the `src` field with `__builtin_preserve_access_index()`.
    This tells Clang to emit a CO-RE relocation entry along with the eBPF instruction
    that accesses this address in memory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`bpf_core_read()`直接调用`bpf_probe_read_kernel()`，唯一的区别在于它用`__builtin_preserve_access_index()`包装了`src`字段。这告诉Clang在访问内存中这个地址时同时发出CO-RE重定位条目与eBPF指令。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This `__builtin_preserve_access_index()` instruction is an extension to “regular”
    C code, and adding it to eBPF also required changes to the Clang compiler to support
    it and emit these CO-RE relocation entries. Extensions like these are examples
    of why some C compilers cannot (today, at least) generate eBPF bytecode. Read
    more about the Clang changes required for eBPF CO-RE support on the [LLVM mailing
    list](https://oreil.ly/jHTHE).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此`__builtin_preserve_access_index()`指令是对“常规”C代码的扩展，在eBPF中添加它也需要Clang编译器的更改以支持并发出这些CO-RE重定位条目。这些扩展是为什么一些C编译器（至少目前是这样）不能生成eBPF字节码的示例。有关为eBPF
    CO-RE支持所需的Clang更改的更多信息，请阅读[LLVM邮件列表](https://oreil.ly/jHTHE)。
- en: As you’ll see later in this chapter, the CO-RE relocation entry tells *libbpf*
    to rewrite the address, as it’s loading the eBPF program into the kernel, to take
    account of any BTF differences. If the offset of `src` within its containing structure
    is different on the target kernel, the rewritten instruction will take that into
    account.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您稍后在本章中将看到的那样，CO-RE重定位条目告诉*libbpf*在将eBPF程序加载到内核时重写地址，以考虑任何BTF差异。如果`src`在其包含结构中的偏移在目标内核上不同，重写的指令将考虑这一点。
- en: 'The *libbpf* library provides a `BPF_CORE_READ()` macro so that you can write
    several `bpf_core_read()` calls in a single line rather than needing a separate
    helper function call for every pointer dereference. For example, if you wanted
    to do something like `d = a->b->c->d`, you could write the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库提供了`BPF_CORE_READ()`宏，这样您可以在单行中编写多个`bpf_core_read()`调用，而不需要为每个指针解引用编写单独的辅助函数调用。例如，如果您想要做类似`d
    = a->b->c->d`的操作，可以编写以下代码：'
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But it’s much more compact to use:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用以下方式要紧凑得多：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can then read from point `d` using the `bpf_probe_read_kernel()` helper
    function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`bpf_probe_read_kernel()`助手函数从`d`点读取。
- en: There’s a good description of this in Andrii’s [guide](https://oreil.ly/tU0Gb).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，Andrii的[指南](https://oreil.ly/tU0Gb)有很好的描述。
- en: License Definition
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证定义
- en: 'As you already know from [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    the eBPF program has to declare its license. The example code does it like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从[第三章](ch03.html#anatomy_of_an_ebpf_program)已经了解到的那样，eBPF程序必须声明其许可证。示例代码如下所示：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’ve now seen all the code in the *hello-buffer-config.bpf.c* example. Now
    let’s compile it into an object file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了*hello-buffer-config.bpf.c*示例中的所有代码。现在让我们将其编译成一个对象文件。
- en: Compiling eBPF Programs for CO-RE
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为CO-RE编译eBPF程序
- en: In [Chapter 3](ch03.html#anatomy_of_an_ebpf_program) you saw an extract from
    a Makefile that compiles C to eBPF bytecode. Let’s dig into the options used and
    see why they are necessary for CO-RE/*libbpf* programs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.html#anatomy_of_an_ebpf_program)中，您看到了一个从Makefile中提取出来的内容，用于将C编译为eBPF字节码。让我们深入研究所使用的选项，并了解它们对CO-RE/*libbpf*程序的必要性。
- en: Debug Information
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试信息
- en: 'You have to pass the `-g` flag to Clang so that it includes debug information,
    which is necessary for BTF. However, the `-g` flag also adds DWARF debugging information
    to the output object file, but that’s not needed by eBPF programs, so you can
    reduce the size of the object by running the following command to strip it out:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须向Clang传递`-g`标志，以便包含调试信息，这对于BTF是必要的。然而，`-g`标志也会向输出的对象文件添加DWARF调试信息，但eBPF程序不需要这些，因此您可以通过运行以下命令将其剥离以减少对象文件的大小：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Optimization
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: The `-O2` optimization flag (level 2 or higher) is required for Clang to produce
    BPF bytecode that will pass the verifier. One example of this being necessary
    is that, by default, Clang will output `callx <register>` to call helper functions,
    but eBPF doesn’t support calling addresses from registers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`-O2`优化标志（2级或更高）是Clang生成将通过验证器的BPF字节码所必需的。一个需要这样做的例子是，默认情况下，Clang将输出`callx
    <register>`来调用辅助函数，但eBPF不支持从寄存器调用地址。'
- en: Target Architecture
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标架构
- en: If you’re using certain macros defined by *libbpf*, you’ll need to specify the
    target architecture at compile time. The *libbpf* header file *bpf/bpf_tracing.h*
    defines several macros that are platform specific, such as `BPF_KPROBE` and `BPF_KPROBE_SYSCALL`
    that I’ve used in this example. The `BPF_KPROBE` macro can be used for eBPF programs
    that are being attached to kprobes, and `BPF_KPROBE_SYSCALL` is a variant specifically
    for syscall kprobes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用*libbpf*定义的某些宏，您需要在编译时指定目标架构。*libbpf*头文件*bpf/bpf_tracing.h*定义了几个特定于平台的宏，例如`BPF_KPROBE`和`BPF_KPROBE_SYSCALL`，我在本示例中使用了这些宏。`BPF_KPROBE`宏可用于将eBPF程序附加到kprobes上，而`BPF_KPROBE_SYSCALL`是专门用于系统调用kprobes的变体。
- en: The argument to a kprobe is a `pt_regs` structure that holds a copy of the contents
    of the CPU registers. Since registers are architecture specific, the `pt_regs`
    structure definition depends on the architecture you’re running on. This means
    that if you want to use these macros, you’ll need to also tell the compiler what
    the target architecture is. You can do this by setting `-D __TARGET_ARCH_($ARCH)`
    where `$ARCH` is an architecture name like arm64, amd64, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: kprobe的参数是一个`pt_regs`结构，其中保存了CPU寄存器内容的副本。由于寄存器是与架构相关的，`pt_regs`结构定义取决于您正在运行的架构。这意味着，如果您想要使用这些宏，您还需要告诉编译器目标架构是什么。您可以通过设置`-D
    __TARGET_ARCH_($ARCH)`来实现这一点，其中`$ARCH`是一个架构名称，如arm64、amd64等。
- en: Also note that if you didn’t use the macro, you’d need architecture-specific
    code to access the register information anyway for a kprobe.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果您没有使用该宏，您仍然需要针对kprobe访问寄存器信息的特定于架构的代码。
- en: Perhaps “compile once *per architecture*, run everywhere” would have been a
    bit of a mouthful!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或许“每个架构编译一次，到处运行”会有点啰嗦！
- en: Makefile
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile
- en: 'The following is an example Makefile instruction for compiling CO-RE objects
    (taken from the Makefile in the *chapter5* directory of the GitHub repo for this
    book):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于编译CO-RE对象的示例Makefile指令（取自本书GitHub存储库中*chapter5*目录中的Makefile）：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you’re using the example code, you should be able to build the eBPF object
    file *hello-buffer-config.bpf.o* (and its companion user space executable that
    I’ll describe shortly) by running `make` in the *chapter5* directory. Let’s inspect
    that object file to see that it includes BTF information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用示例代码，您应该能够通过在*chapter5*目录中运行`make`来构建eBPF目标文件*hello-buffer-config.bpf.o*（以及我将很快描述的其伴随的用户空间可执行文件）。让我们检查该目标文件，看看它是否包含BTF信息。
- en: BTF Information in the Object File
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标文件中的BTF信息
- en: 'The [kernel documentation for BTF](https://oreil.ly/5QrBy) describes how BTF
    data is encoded in an ELF object file in two sections: *.BTF*, which contains
    the data and string information, and *.BTF.ext*, which covers function and line
    information. You can use `readelf` to see that these sections have been added
    to the object file, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[BTF的内核文档](https://oreil.ly/5QrBy)描述了BTF数据如何在ELF目标文件中以两个部分进行编码：*.BTF*，其中包含数据和字符串信息，以及*.BTF.ext*，其中包含函数和行信息。您可以使用`readelf`查看这些部分已添加到目标文件中，如下所示：'
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `bpftool` utility lets us examine the BTF data from an object file, like
    this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool`实用程序允许我们检查来自目标文件的BTF数据，如下所示：'
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output looks just like the output you get from dumping BTF info from loaded
    programs and maps, as you saw earlier in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来就像您在本章前面看到的从加载的程序和映射中转储BTF信息时获得的输出。
- en: Let’s see how this BTF information can be used to allow the program to run on
    another machine with a different kernel version and different data structures.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些BTF信息来使程序能够在具有不同内核版本和不同数据结构的另一台机器上运行。
- en: BPF Relocations
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF重定位
- en: The *libbpf* library adapts eBPF programs to work with the data structure layout
    on the target kernel where they run, even if this layout is different from the
    kernel where the code was compiled. To do this, *libbpf* needs the BPF CO-RE relocation
    information generated by Clang as part of the compilation process.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库使eBPF程序适应它们运行的目标内核上的数据结构布局，即使此布局与编译代码的内核不同。为此，*libbpf*需要Clang在编译过程中生成的BPF
    CO-RE重定位信息。'
- en: 'You can learn more about how the relocations work from the definition of `struct
    bpf_core_relo` in the [*linux/bpf.h*](https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711)
    header file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[*linux/bpf.h*](https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711)头文件中`struct
    bpf_core_relo`的定义中了解重定位是如何工作的：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The CO-RE relocation data for an eBPF program consists of one of these structures
    for each instruction that needs relocation. Suppose the instruction is setting
    a register to the value of a field within a structure. The `bpf_core_relo` structure
    for that instruction (identified by the `insn_off` field) encodes the BTF type
    of that structure (the `type_id` field) and also indicates how the field is accessed
    relative to that structure (`access_str_off`).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个eBPF程序的CO-RE重定位数据由每个需要重定位的指令的一个结构体组成。假设指令将寄存器设置为结构体中字段的值，则该指令的`bpf_core_relo`结构体（由`insn_off`字段标识）编码该结构体的BTF类型（`type_id`字段）并指示如何相对于该结构体访问字段（`access_str_off`字段）。
- en: 'As you’ve just seen, the relocation data for the kernel data structures is
    generated automatically by Clang and encoded in the ELF object file. It’s the
    following line, which you’ll find near the start of the *vmlinux.h* file, that
    causes Clang to do this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚才看到的，Clang会自动生成内核数据结构的重定位数据，并编码到ELF对象文件中。是以下代码，您会在*vmlinux.h*文件的开头附近找到，导致Clang执行此操作：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `preserve_access_index` attribute tells Clang to generate BPF CO-RE relocations
    for a type definition. The `clang attribute push` part says that this attribute
    should be applied to all definitions until a `clang attribute pop`, which appears
    at the end of the file. That means Clang generates the relocation information
    for all the types defined in *vmlinux.h*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`preserve_access_index`属性告诉Clang为类型定义生成BPF CO-RE重定位。`clang attribute push`部分表示该属性应用于直到文件末尾的所有定义的情况下，会有`clang
    attribute pop`。这意味着Clang为*vmlinux.h*中定义的所有类型生成重定位信息。'
- en: 'You can see the relocations taking place when you load a BPF program, by using
    `bpftool` and turning on the debug information with the `-d` flag, like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您加载BPF程序时，可以使用`bpftool`并通过`-d`标志打开调试信息，如下所示，查看重定位的发生：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This generates a lot of output, but the parts relating to relocation look like
    this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成大量输出，但与重定位相关的部分如下所示：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example you can see that type ID 24 from the `hello` program’s BTF
    information refers to the structure called `user_pt_regs`. The *libbpf* library
    has matched this against a kernel structure, also called `user_pt_regs`, that
    has type ID 205 in the *vmlinux* BTF data set. In practice, because I compiled
    and loaded the program on the same machine, the type definitions are identical,
    so in this example the offset of 0 from the start of the structure remains unchanged,
    and the “patch” to instruction #1 leaves it unchanged.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到`hello`程序的BTF信息中类型ID为24的结构体称为`user_pt_regs`。*libbpf*库将其与内核结构体匹配，也称为`user_pt_regs`，该结构体在*vmlinux*
    BTF数据集中的类型ID为205。实际上，因为我在同一台机器上编译和加载了程序，类型定义是相同的，所以在这个例子中，从结构体开始的偏移量保持不变，并且对第1条指令的“补丁”也保持不变。
- en: In many applications you won’t want to ask users to run `bpftool` to load an
    eBPF program. Instead, you’ll want to build this functionality into a dedicated
    user space program that you supply as an executable. Let’s consider how to write
    this user space code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，您可能不希望要求用户运行`bpftool`来加载eBPF程序。相反，您希望将此功能构建到您提供的专用用户空间程序中作为可执行文件。让我们考虑如何编写这个用户空间代码。
- en: CO-RE User Space Code
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO-RE用户空间代码
- en: There are a few different frameworks in different programming languages that
    support CO-RE by implementing the relocations as they load eBPF programs into
    the kernel. In this chapter I’ll show C code that uses *libbpf*; other options
    include the Go packages *cilium/ebpf* and *libbpfgo*, and Aya for Rust. I’ll discuss
    those options further in [Chapter 10](ch10.html#ebpf_programming).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 不同编程语言中有几种不同的框架支持CO-RE，通过在加载eBPF程序到内核时实现重定位。在本章中，我将展示使用*libbpf*的C代码；其他选项包括Go包*cilium/ebpf*和*libbpfgo*，以及Rust的Aya。我将在[第10章](ch10.html#ebpf_programming)进一步讨论这些选项。
- en: The Libbpf Library for User Space
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间的Libbpf库
- en: The *libbpf* library is a user space library you can use directly if you’re
    writing the user space part of your application in C. If you want to, you can
    use this library without using CO-RE. There’s an example of this in [Andrii Nakryiko’s
    excellent blog post on *libbpf-bootstrap*](https://oreil.ly/b3v7B).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库是一个用户空间库，如果你用C语言编写应用程序的用户空间部分，可以直接使用它。如果愿意，你可以在不使用CO-RE的情况下使用这个库。[Andrii
    Nakryiko在*libbpf-bootstrap*上有一个例子](https://oreil.ly/b3v7B)。'
- en: This library provides functions that wrap the `bpf()` and related syscalls that
    you met in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) to perform
    operations like loading programs into the kernel and attaching them to events,
    or accessing map information from user space. The conventional and easiest way
    to use these abstractions is through auto-generated BPF skeleton code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此库提供的函数封装了你在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中遇到的`bpf()`和相关系统调用，用于像将程序加载到内核中并将其附加到事件，或者从用户空间访问映射信息的操作。使用这些抽象的传统和最简单的方式是通过自动生成的BPF骨架代码。
- en: BPF Skeletons
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BPF骨架
- en: 'You can use `bpftool` to auto-generate this skeleton code from existing eBPF
    objects in ELF file format, like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`bpftool`从现有的以ELF文件格式存在的eBPF对象中自动生成这些骨架代码，如下所示：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Look into this skeleton header and you’ll see that it contains structure definitions
    for the eBPF programs and maps, as well as several functions that all start with
    the name `hello_buffer_config_bpf__` (based on the name of the object file). These
    functions manage the lifecycle of the eBPF programs and maps. You don’t have to
    use the skeleton code—you can make calls to *libbpf* directly if you prefer—but
    the auto-generated code will typically save you some typing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个骨架头文件，你会看到它包含了eBPF程序和映射的结构定义，以及几个以`hello_buffer_config_bpf__`开头的函数（根据对象文件的名称）。这些函数管理eBPF程序和映射的生命周期。如果你喜欢，你可以直接调用*libbpf*，而不必使用骨架代码，但通常自动生成的代码可以节省一些输入。
- en: Toward the end of the generated skeleton file you’ll see a function called `hello_buffer_config_bpf__elf_bytes`
    that returns the byte contents of the ELF object file *hello-buffer-config.bpf.o*.
    Once the skeleton has been generated, we don’t really need that object file anymore.
    You can test this by running `make` to generate the `hello-buffer-config` executable
    and then deleting the *.o* file; the executable has the eBPF bytecode contained
    within it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的骨架文件末尾，你会看到一个名为`hello_buffer_config_bpf__elf_bytes`的函数，它返回ELF对象文件*hello-buffer-config.bpf.o*的字节内容。一旦生成了骨架，我们实际上不再需要该对象文件。你可以通过运行`make`生成`hello-buffer-config`可执行文件，并删除*.o*文件来测试这一点；可执行文件中包含eBPF字节码。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you prefer, you can use the *libbpf* function `bpf_object__open_file` to
    load the eBPF programs and maps from an ELF file rather than using the bytes from
    a skeleton file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以使用*libbpf*函数`bpf_object__open_file`从ELF文件加载eBPF程序和映射，而不是使用骨架文件的字节。
- en: Here’s the outline of the user space code that manages the lifecycle of the
    eBPF program and maps for this example, using the generated skeleton code. I have
    omitted some of the details and error handling for clarity, but you’ll find the
    full source code in *chapter5/hello-buffer-config.c*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是管理此示例中eBPF程序和映射生命周期的用户空间代码概述，使用生成的骨架代码。为了清晰起见，我省略了部分细节和错误处理，但你可以在*chapter5/hello-buffer-config.c*中找到完整的源代码。
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#code_id_5_5)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_5_5)'
- en: This file includes the auto-generated skeleton header, as well as the header
    file I wrote manually for data structures shared between the user space and kernel
    code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包括自动生成的骨架头文件，以及我手动编写的用于用户空间和内核代码共享的头文件。
- en: '[![2](assets/2.png)](#code_id_5_6)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_5_6)'
- en: This code sets a callback function that will print any log messages generated
    by *libbpf*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了一个回调函数，用于打印由*libbpf*生成的任何日志消息。
- en: '[![3](assets/3.png)](#code_id_5_7)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_5_7)'
- en: Here a `skel` structure is created that represents all the maps and programs
    defined in the ELF bytes and loads them into the kernel.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建了一个 `skel` 结构，表示 ELF 字节中定义的所有映射和程序，并将它们加载到内核中。
- en: '[![4](assets/4.png)](#code_id_5_8)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_5_8)'
- en: Programs are auto-attached to the appropriate events.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会自动附加到适当的事件上。
- en: '[![5](assets/5.png)](#code_id_5_9)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_5_9)'
- en: This function creates a structure for handling the perf buffer output.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建用于处理性能缓冲区输出的结构。
- en: '[![6](assets/6.png)](#code_id_5_10)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_5_10)'
- en: Here that perf buffer is continuously polled.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在此连续轮询性能缓冲区。
- en: '[![7](assets/7.png)](#code_id_5_11)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#code_id_5_11)'
- en: This is the clean-up code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清理代码。
- en: Let’s dive into some of those steps in more detail.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨其中的一些步骤。
- en: Loading programs and maps into the kernel
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将程序和映射加载到内核中
- en: 'The first call to an auto-generated function is this one:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对自动生成的第一个调用是这个函数：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As its name suggests, this function covers two phases: opening and loading.
    The “open” phase involves reading the ELF data and converting its sections into
    structures that represent eBPF programs and maps. The “load” phase loads those
    maps and programs into the kernel, performing any CO-RE fixups as necessary.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，此函数涵盖了两个阶段：打开和加载。 “打开” 阶段涉及读取 ELF 数据并将其节转换为表示 eBPF 程序和映射的结构。 “加载” 阶段将这些映射和程序加载到内核中，并根据需要执行任何
    CO-RE 修复。
- en: 'These two phases can easily be handled separately, as the skeleton code provides
    separate `name__open()` and `name__load()` functions. This gives you the option
    to manipulate the eBPF information before loading it. This is commonly done to
    configure a program before loading it. For example, I could initialize a counter
    global variable `c` to some value, like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个阶段可以轻松分开处理，因为骨架代码提供了分开的 `name__open()` 和 `name__load()` 函数。这使您可以在加载之前操作 eBPF
    信息。例如，我可以将一个计数器全局变量 `c` 初始化为某个值，如下所示：
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The data type returned by `hello_buffer_config_bpf__open()`, and also by `hello_buffer_config_bpf__load()`,
    is a structure called `hello_buffer_config_bpf` defined in the skeleton header
    to include information about all the maps, programs, and data defined in the object
    file.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello_buffer_config_bpf__open()` 返回的数据类型，以及 `hello_buffer_config_bpf__load()`
    返回的数据类型，都是一个名为 `hello_buffer_config_bpf` 的结构体，在骨架头文件中定义了有关对象文件中定义的所有映射、程序和数据的信息。'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The skeleton object (`hello_buffer_config_bpf` in this example) is just a user
    space representation of information from the ELF bytes. Once it has been loaded
    into the kernel, if you change a value in the object, it won’t have any effect
    on the kernel-side data. So, for example, changing `skel->data->c` after loading
    will not have any effect.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架对象（在本例中为 `hello_buffer_config_bpf`）只是来自 ELF 字节信息的用户空间表示。一旦加载到内核中，如果在加载后更改
    `skel->data->c` 的值，它不会对内核端数据产生任何影响。
- en: Accessing existing maps
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问现有映射
- en: By default, *libbpf* will also create any maps that are defined in the ELF bytes,
    but sometimes you might want to write an eBPF program that reuses an existing
    map. You already saw an example of this in the previous chapter, where you saw
    `bpftool` iterating through all the maps, looking for the one that matched a specified
    name. Another common reason to use a map is to share information between two different
    eBPF programs, so only one program should create the map. The `bpf_map__set_autocreate()`
    function allows you to override *libbpf*’s auto-creation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*libbpf* 也会创建在 ELF 字节中定义的任何映射，但有时您可能希望编写一个 eBPF 程序，该程序重用现有的映射。在上一章中已经看到了一个例子，您看到
    `bpftool` 遍历所有映射，查找与指定名称匹配的映射。使用映射的另一个常见原因是在两个不同的 eBPF 程序之间共享信息，因此只有一个程序应该创建映射。`bpf_map__set_autocreate()`
    函数允许您覆盖 *libbpf* 的自动创建。
- en: 'So how do you access an existing map? Maps can be pinned, and if you know the
    pinned path, you can get a file descriptor to an existing map with `bpf_obj_get()`.
    Here’s a very simple example (available in the GitHub repository as *chapter5/find-map.c*):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何访问现有映射呢？映射可以被固定，如果您知道固定路径，可以使用 `bpf_obj_get()` 获取现有映射的文件描述符。以下是一个非常简单的示例（在
    GitHub 存储库中作为 *chapter5/find-map.c* 可用）：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To try this out you can create a map using `bpftool`, like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `bpftool` 创建一个映射来尝试这一点，就像这样：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running the find-map executable will print out:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 find-map 可执行文件将输出：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let’s get back to the *hello-buffer-config* example and the skeleton code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 *hello-buffer-config* 示例和骨架代码。
- en: Attaching to events
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加到事件
- en: 'The next skeleton function in the example attaches the program to the `execve`
    syscall function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例中的下一个骨架函数将程序附加到`execve`系统调用函数：
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The *libbpf* library automatically takes the attachment point from the `SEC()`
    definition for this program. If you didn’t define the attachment point fully,
    there are a whole series of *libbpf* functions, such as `bpf_program__attach_kprobe`,
    `bpf_program__attach_xdp`, and so on, for attaching different program types.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库会自动从该程序的`SEC()`定义中获取附加点。如果您没有完全定义附加点，那么还有一系列*libbpf*函数，例如`bpf_program__attach_kprobe`、`bpf_program__attach_xdp`等，用于附加不同类型的程序。'
- en: Managing an event buffer
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理事件缓冲区
- en: 'Setting up the perf buffer uses a function defined in *libbpf* itself, rather
    than in the skeleton:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 设置perf缓冲区使用的函数是在*libbpf*库本身中定义的，而不是在骨架中：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see the `perf_buffer__new()` function takes the file descriptor for
    the “output” map as the first argument. The `handle_event` argument is a callback
    function that gets called when new data arrives in the perf buffer, and `lost_event`
    gets called if there isn’t enough room in the perf buffer for the kernel to write
    a data entry. In my example these functions just write messages to the screen.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`perf_buffer__new()`函数将“输出”映射的文件描述符作为第一个参数。`handle_event`参数是一个回调函数，当perf缓冲区中有新数据到达时会调用它，如果内核没有足够的空间写入数据条目，则会调用`lost_event`。在我的示例中，这些函数只是将消息写入屏幕。
- en: 'Finally, the program has to poll the perf buffer repeatedly:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序必须重复轮询perf缓冲区：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The 100 is a timeout in milliseconds. The callback functions previously set
    up will get called as appropriate when data arrives or when the buffer is full.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 100是毫秒级的超时时间。以前设置的回调函数将在数据到达或缓冲区已满时适时调用。
- en: 'Finally, to clean up I free the perf buffer and destroy the eBPF programs and
    maps in the kernel, like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了清理，我释放perf缓冲区并销毁内核中的eBPF程序和映射，如下所示：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are a whole set of `perf_buffer_*`- and `ring_buffer_*`-related functions
    in *libbpf* to help you manage event buffers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*中有一整套与`perf_buffer_*`和`ring_buffer_*`相关的函数，帮助您管理事件缓冲区。'
- en: 'If you make and run this example `hello-buffer-config` program, you’ll see
    the following output (that’s very similar to what you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi)):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您制作并运行此示例`hello-buffer-config`程序，您将看到以下输出（与您在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到的非常相似）：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Libbpf Code Examples
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Libbpf代码示例
- en: 'There are lots of great examples of *libbpf*-based eBPF programs available
    that you can use as inspiration and guidance for writing your own:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基于*libbpf*的eBPF程序的优秀示例可供使用，可以作为编写自己程序的灵感和指导：
- en: The [*libbpf-bootstrap*](https://oreil.ly/zB0Co) project is intended to help
    you get off the ground with a set of example programs.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*libbpf-bootstrap*](https://oreil.ly/zB0Co)项目旨在帮助您通过一组示例程序入门。'
- en: The BCC project has many of the original BCC-based tools migrated to a *libbpf*
    version. You’ll find them in the [*libbpf-tools* directory](https://oreil.ly/Z9xDX).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BCC项目已经将许多原始的基于BCC的工具迁移到*libbpf*版本。您可以在[*libbpf-tools*目录](https://oreil.ly/Z9xDX)中找到它们。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: CO-RE enables eBPF programs that can run on kernel versions different from the
    versions on which they were built. This massively improves the portability of
    eBPF and makes life much easier for tool developers who want to deliver production-ready
    tooling to their users and customers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE使得eBPF程序能够在与其构建时不同的内核版本上运行。这极大地提高了eBPF的可移植性，并且为希望向用户和客户交付生产就绪工具的工具开发人员带来了极大的便利。
- en: 'In this chapter you saw how CO-RE achieves this by encoding type information
    into the compiled object file and using relocations to rewrite instructions as
    they are loaded into the kernel. You also had an introduction to writing code
    in C that uses *libbpf*: both the eBPF programs that run in the kernel and the
    user space programs that manage the lifecycle of those programs, based on auto-generated
    BPF skeleton code. In the next chapter you’ll learn how the kernel verifies that
    eBPF programs are safe to run.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了CO-RE是如何通过将类型信息编码到编译后的对象文件中，并使用重定位来在加载到内核时重写指令来实现的。您还介绍了如何在C中编写使用*libbpf*的代码：既在内核中运行的eBPF程序，又在用户空间中管理这些程序的生命周期，基于自动生成的BPF骨架代码。在下一章中，您将学习内核如何验证eBPF程序是否安全可运行。
- en: Exercises
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are a few things you can do to further explore BTF, CO-RE, and *libbpf*:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以进一步探索BTF、CO-RE和*libbpf*的一些事项：
- en: Experiment with `bpftool btf dump map` and `bpftool btf dump prog` to see the
    BTF information associated with maps and programs, respectively. Remember that
    you can specify individual maps and programs in more than one way.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`bpftool btf dump map`和`bpftool btf dump prog`来查看与映射和程序相关的BTF信息。请记住，你可以用多种方式指定单独的映射和程序。
- en: Compare the output from `bpftool btf dump file` and `bpftool btf dump prog`
    for the same program in its ELF object file form and after it has been loaded
    into the kernel. They should be identical.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较在ELF对象文件形式及加载到内核后的相同程序的`bpftool btf dump file`和`bpftool btf dump prog`的输出。它们应该是相同的。
- en: Examine the debug output from *bpftool -d prog load hello-buffer-config.bpf.o
    /sys/fs/bpf/hello*. You’ll see each section being loaded, checks on the license,
    and relocations taking place, as well as output describing each BPF program instruction.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查来自*bpftool -d prog load hello-buffer-config.bpf.o /sys/fs/bpf/hello*的调试输出。你将看到每个节被加载，对许可证的检查以及正在进行的重定位，以及描述每条BPF程序指令的输出。
- en: Try building a BPF program against a different *vmlinux* header file from BTFHub,
    and look in the debug output from `bpftool` for relocations that change offsets.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用来自BTFHub的不同*vmlinux*头文件构建BPF程序，并查看`bpftool`的调试输出，以查找更改偏移量的重定位。
- en: Modify the *hello-buffer-config.c* program so that you can configure different
    messages for different user IDs using the map (similar to the *hello-buffer-config.py*
    example in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi)).
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*hello-buffer-config.c*程序，以便可以使用映射为不同用户ID配置不同的消息（类似于[第四章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中的*hello-buffer-config.py*示例）。
- en: Try changing the section name in the `SEC();`, perhaps to your own name. When
    you come to load the program into the kernel you should see an error because *libbpf*
    doesn’t recognize the section name. This illustrates how *libbpf* uses the section
    name to work out what kind of BPF program this is. You could try writing your
    own attachment code to explicitly attach to an event of your choice rather than
    relying on *libbpf*’s auto-attachment.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改`SEC();`中的节名称，也许改成你自己的名字。当你加载程序到内核时，你应该会看到一个错误，因为*libbpf*不认识节名称。这说明了*libbpf*如何使用节名称来确定这是什么类型的BPF程序。你可以尝试编写自己的附加代码，显式地附加到你选择的事件，而不依赖于*libbpf*的自动附加。
- en: ^([1](ch05.html#ch05fn1-marker)) Strictly speaking, the data structure definitions
    come from kernel header files, and you could choose to compile based on a set
    of these header files that is different from what was used to build the kernel
    running on that machine. To work correctly (without the CO-RE mechanisms described
    in this chapter), the kernel headers have to be compatible with the kernel on
    the target machine where the eBPF program will run.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#ch05fn1-marker)) 严格来说，数据结构定义来自内核头文件，你可以选择基于一组不同于用于构建运行在目标机器上的内核的头文件编译的这些头文件。要正确工作（没有本章描述的CO-RE机制），内核头文件必须与将运行eBPF程序的目标机器上的内核兼容。
- en: ^([2](ch05.html#ch05fn2-marker)) Part of this section is adapted from “What
    Is eBPF?” by Liz Rice. Copyright © 2022 O’Reilly Media. Used with permission.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#ch05fn2-marker)) 本节部分内容改编自Liz Rice的“What Is eBPF?”。版权所有 © 2022
    O’Reilly Media。已获授权使用。
- en: ^([3](ch05.html#ch05fn3-marker)) A small and unscientific survey suggests that
    most people pronounce this the same as the word *core* rather than in two syllables.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#ch05fn3-marker)) 根据一项小规模且非科学的调查，大多数人发音与单词*core*相同，而不是分成两个音节。
- en: ^([4](ch05.html#ch05fn4-marker)) See the kernel documentation at [*https://docs.kernel.org/bpf/btf.html#type-encoding*](https://docs.kernel.org/bpf/btf.html#type-encoding).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#ch05fn4-marker)) 请参阅内核文档[*https://docs.kernel.org/bpf/btf.html#type-encoding*](https://docs.kernel.org/bpf/btf.html#type-encoding)。
- en: ^([5](ch05.html#ch05fn5-marker)) The kernel needs to have been built with the
    `CONFIG_DEBUG_INFO_BTF` option enabled.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.html#ch05fn5-marker)) 内核需要启用`CONFIG_DEBUG_INFO_BTF`选项进行构建。
- en: ^([6](ch05.html#ch05fn6-marker)) Which is the oldest Linux kernel version that
    can support BTF? See [*https://oreil.ly/HML9m*](https://oreil.ly/HML9m).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.html#ch05fn6-marker)) 哪个是支持BTF的最早的Linux内核版本？参见[*https://oreil.ly/HML9m*](https://oreil.ly/HML9m)。
- en: ^([7](ch05.html#ch05fn7-marker)) Well, normal C preprocessing applies so that
    you can do things like `#define`. But there’s no *special* rewriting like there
    is when you use BCC.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch05.html#ch05fn7-marker)) 好吧，正常的C预处理适用于你可以做`#define`等事情。但是没有像使用BCC时那样的*特殊*重写。
- en: ^([8](ch05.html#ch05fn8-marker)) eBPF programs handling network packets don’t
    get to use this helper function and can only access the network packet memory.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch05.html#ch05fn8-marker)) 处理网络数据包的 eBPF 程序无法使用这个帮助函数，只能访问网络数据包的内存。
- en: ^([9](ch05.html#ch05fn9-marker)) It is permitted in certain BTF-enabled program
    types such as `tp_btf`, `fentry`, and `fexit`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch05.html#ch05fn9-marker)) 在某些启用了 BTF 的程序类型中是允许的，比如 `tp_btf`、`fentry`
    和 `fexit`。
