- en: Chapter 1\. What Is eBPF, and Why Is It Important?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 什么是 eBPF，为什么它重要？
- en: eBPF is a revolutionary kernel technology that allows developers to write custom
    code that can be loaded into the kernel dynamically, changing the way the kernel
    behaves. (Don’t worry if you’re not confident about what the kernel is—we’ll come
    to that shortly in this chapter.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 是一项革命性的内核技术，允许开发人员编写可以动态加载到内核中的自定义代码，改变内核行为的方式。（如果你对内核不是很自信，不用担心，我们稍后在本章将详细介绍。）
- en: This enables a new generation of highly performant networking, observability,
    and security tools. And as you’ll see, if you want to instrument an app with these
    eBPF-based tools, you don’t need to modify or reconfigure the app in any way,
    thanks to eBPF’s vantage point within the kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得新一代高性能的网络、可观察性和安全工具成为可能。正如你将看到的那样，如果你想用这些基于 eBPF 的工具来仪表化一个应用程序，你无需修改或重新配置该应用程序，这要归功于
    eBPF 在内核中的优势位置。
- en: 'Just a few of the things you can do with eBPF include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 eBPF 做的一些事情包括：
- en: Performance tracing of pretty much any aspect of a system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎可以对系统的任何方面进行性能跟踪
- en: High-performance networking, with built-in visibility
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能网络，具有内置的可见性
- en: Detecting and (optionally) preventing malicious activity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和（可选地）防止恶意活动
- en: Let’s take a brief journey through eBPF’s history, starting with the Berkeley
    Packet Filter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下 eBPF 的历史，从伯克利数据包过滤器开始。
- en: 'eBPF’s Roots: The Berkeley Packet Filter'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF 的起源：伯克利数据包过滤器
- en: 'What we call “eBPF” today has its roots in the BSD Packet Filter, first described
    in 1993 in a paper^([1](ch01.html#ch01fn4)) written by Lawrence Berkeley National
    Laboratory’s Steven McCanne and Van Jacobson. This paper discusses a pseudomachine
    that can run *filters*, which are programs written to determine whether to accept
    or reject a network packet. These programs were written in the BPF instruction
    set, a general-purpose set of 32-bit instructions that closely resembles assembly
    language. Here’s an example taken directly from that paper:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天称之为“eBPF”的东西，其根源于1993年由劳伦斯伯克利国家实验室的 Steven McCanne 和 Van Jacobson 编写的一篇论文^([1](ch01.html#ch01fn4))，该论文讨论了一个伪机器，可以运行
    *过滤器*，这些程序编写用于确定是否接受或拒绝网络数据包。这些程序是用 BPF 指令集编写的，这是一组通用的32位指令，与汇编语言非常接近。以下是直接摘自该论文的一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tiny piece of code filters out packets that aren’t Internet Protocol (IP)
    packets. The input to this filter is an Ethernet packet, and the first instruction
    (`ldh`) loads a 2-byte value starting at byte 12 in this packet. In the next instruction
    (`jeq`) that value is compared with the value that represents an IP packet. If
    it matches, execution jumps to the instruction labeled `L1`, and the packet is
    accepted by returning a nonzero value (identified here as `#TRUE`). If it doesn’t
    match, the packet is not an IP packet and is rejected by returning `0`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小小的代码过滤掉不是 Internet 协议（IP）数据包的数据。这个过滤器的输入是一个以太网数据包，第一条指令（`ldh`）加载从数据包的第 12
    字节开始的一个 2 字节的值。在下一条指令（`jeq`）中，将这个值与表示 IP 数据包的值进行比较。如果匹配，执行跳转到标记为 `L1` 的指令，并且通过返回一个非零值（这里被标识为
    `#TRUE`）接受数据包。如果不匹配，则数据包不是 IP 数据包，通过返回 `0` 被拒绝。
- en: You can imagine (or, indeed, refer to the paper to find examples of) more complex
    filter programs that make decisions based on other aspects of the packet. Importantly,
    the author of the filter can write their own custom programs to be executed within
    the kernel, and this is the heart of what eBPF enables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象（或者确实参考论文找到例子），更复杂的过滤程序，这些程序基于数据包的其他方面做出决策。重要的是，过滤器的作者可以编写自己的自定义程序在内核中执行，这正是
    eBPF 能实现的核心。
- en: BPF came to stand for “Berkeley Packet Filter,” and it was first introduced
    to Linux in 1997, in kernel version 2.1.75,^([2](ch01.html#ch01fn5)) where it
    was used in the tcpdump utility as an efficient way to capture the packets to
    be traced out.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: BPF 的含义被改为“伯克利数据包过滤器”，最早在1997年被引入 Linux 内核版本 2.1.75 中，^([2](ch01.html#ch01fn5))
    它被用作 tcpdump 实用程序中高效捕获要跟踪的数据包的方式。
- en: Fast-forward to 2012, when seccomp-bpf was introduced in version 3.5 of the
    kernel. This enabled the use of BPF programs to make decisions about whether to
    allow or deny user space applications from making system calls. We’ll explore
    this in more detail in [Chapter 10](ch10.html#ebpf_programming). This was the
    first step in evolving BPF from the narrow scope of packet filtering to the general-purpose
    platform it is today. From this point on, the words *packet filter* in the name
    started to make less sense!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到2012年，seccomp-bpf在内核版本3.5中引入。这使得可以使用BPF程序来决定是否允许或拒绝用户空间应用程序进行系统调用。我们将在[第10章](ch10.html#ebpf_programming)中详细探讨这一点。这是将BPF从仅限于数据包过滤演变为如今通用平台的第一步。从这一点开始，名称中的“数据包过滤器”一词开始变得不那么合理了！
- en: From BPF to eBPF
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从BPF到eBPF
- en: 'BPF evolved to what we call “extended BPF” or “eBPF” starting in kernel version
    3.18 in 2014\. This involved several significant changes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从2014年的内核版本3.18开始，BPF演变为我们所称的“扩展BPF”或“eBPF”。这涉及了几个重大改变：
- en: The BPF instruction set was completely overhauled to be more efficient on 64-bit
    machines, and the interpreter was entirely rewritten.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPF指令集在64位机器上进行了彻底改进，使其更高效，并且解释器也进行了完全重写。
- en: eBPF *maps* were introduced, which are data structures that can be accessed
    by BPF programs and by user space applications, allowing information to be shared
    between them. You’ll learn about maps in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了eBPF *映射*，这是可以由BPF程序和用户空间应用程序访问的数据结构，允许它们之间共享信息。您将在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中了解映射。
- en: The `bpf()` system call was added so that user space programs can interact with
    eBPF programs in the kernel. You’ll read about this system call in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`bpf()`系统调用，以便用户空间程序可以与内核中的eBPF程序进行交互。您将在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中了解此系统调用。
- en: Several BPF helper functions were added. You’ll see a few examples in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    and some more details in [Chapter 6](ch06.html#the_ebpf_verifier).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了几个BPF辅助函数。您将在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)看到一些示例，并在[第6章](ch06.html#the_ebpf_verifier)中看到更多细节。
- en: The eBPF verifier was added to ensure that eBPF programs are safe to run. This
    is discussed in [Chapter 6](ch06.html#the_ebpf_verifier).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了eBPF验证器，以确保eBPF程序的安全运行。这在[第6章](ch06.html#the_ebpf_verifier)中讨论。
- en: This put the basis for eBPF in place, but development did not slow down! Since
    then, eBPF has evolved significantly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这为eBPF奠定了基础，但开发并未放缓！自那时以来，eBPF已经显著发展。
- en: The Evolution of eBPF to Production Systems
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF向生产系统的演变
- en: A feature called *kprobes* (kernel probes) had existed in the Linux kernel since
    2005, allowing for traps to be set on almost any instruction in the kernel code.
    Developers could write kernel modules that attached functions to kprobes for debugging
    or performance measurement purposes.^([3](ch01.html#ch01fn6))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自2005年以来，Linux内核中存在名为*kprobes*（内核探测点）的特性，允许在内核代码中的几乎任何指令上设置陷阱。开发人员可以编写内核模块，将函数附加到kprobes以进行调试或性能测量目的。^([3](ch01.html#ch01fn6))
- en: The ability to attach eBPF programs to kprobes was added in 2015, and this was
    the starting point for a revolution in the way tracing is done across Linux systems.
    At the same time, hooks started to be added within the kernel’s networking stack,
    allowing eBPF programs to take care of more aspects of networking functionality.
    We’ll see more of this in [Chapter 8](ch08.html#ebpf_for_networking).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年添加了将eBPF程序附加到kprobes的能力，这是在Linux系统中进行跟踪革命的起点。同时，开始在内核的网络堆栈中添加钩子，允许eBPF程序处理更多的网络功能。我们将在[第8章](ch08.html#ebpf_for_networking)中看到更多内容。
- en: By 2016, eBPF-based tools were being used in production systems. [Brendan Gregg’s](https://www.brendangregg.com)
    work on tracing at Netflix became widely known in infrastructure and operations
    circles, as did [his statement](https://oreil.ly/stV6v) that eBPF “brings superpowers
    to Linux.” In the same year, the Cilium project was announced, being the first
    networking project to use eBPF to replace the entire datapath in container environments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到2016年，基于eBPF的工具已经开始在生产系统中使用。[Brendan Gregg](https://www.brendangregg.com) 在Netflix上关于跟踪的工作变得广为人知，正如他在基础设施和运维领域所说，eBPF“为Linux带来了超能力”。同年，宣布了Cilium项目，这是第一个在容器环境中使用eBPF来替换整个数据路径的网络项目。
- en: The following year Facebook (now Meta) made [Katran](https://oreil.ly/X-WsL)
    an open source project. Katran, a layer 4 load balancer, met Facebook’s need for
    a [highly scalable and fast solution](https://oreil.ly/zl4yX). Every single packet
    to [Facebook.com](http://Facebook.com) since 2017 has passed through eBPF/XDP.^([4](ch01.html#ch01fn7))
    For me personally, this was the year that ignited my excitement about the possibilities
    enabled by this technology, after seeing [Thomas Graf’s talk](https://oreil.ly/g9ya0)
    about eBPF and the [Cilium project](https://oreil.ly/doKbd) at DockerCon in Austin,
    Texas.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 2023年，Facebook（现在的Meta）将[Katran](https://oreil.ly/X-WsL)开源。Katran作为第四层负载均衡器，满足了Facebook对[高可扩展性和快速解决方案](https://oreil.ly/zl4yX)的需求。自2017年以来，每个发送到[Facebook.com](http://Facebook.com)的数据包都经过eBPF/XDP的处理。^([4](ch01.html#ch01fn7))对我个人而言，这一年点燃了我对这项技术可能性的激情，特别是在德克萨斯州奥斯汀市DockerCon上看到[Thomas
    Graf的演讲](https://oreil.ly/g9ya0)，讲述了eBPF和[Cilium项目](https://oreil.ly/doKbd)。
- en: In 2018, eBPF became a separate subsystem within the Linux kernel, with [Daniel
    Borkmann](http://borkmann.ch) from Isovalent and [Alexei Starovoitov](https://oreil.ly/K8nXI)
    from Meta as its maintainers (they were later joined by [Andrii Nakryiko](https://nakryiko.com),
    also from Meta). The same year saw the introduction of BPF Type Format (BTF),
    which makes eBPF programs much more portable. We’ll explore this in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，eBPF成为Linux内核中的一个独立子系统，由Isovalent的[Daniel Borkmann](http://borkmann.ch)和Meta的[Alexei
    Starovoitov](https://oreil.ly/K8nXI)负责维护（后来还有来自Meta的[Andrii Nakryiko](https://nakryiko.com)加入）。同年还引入了BPF类型格式（BTF），极大地提升了eBPF程序的可移植性。我们将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中探讨这一点。
- en: 'The year 2020 saw the introduction of LSM BPF, allowing eBPF programs to be
    attached to the Linux Security Module (LSM) kernel interface. This indicated that
    a third major use case for eBPF had been identified: it became clear that eBPF
    is a great platform for security tooling, in addition to networking and observability.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年，引入了LSM BPF，允许将eBPF程序附加到Linux安全模块（LSM）内核接口上。这表明eBPF已经确定了第三个重要用例：除了网络和可观测性外，它还成为了一个出色的安全工具平台。
- en: Over the years, eBPF’s capabilities have grown substantially, thanks to the
    work of more than 300 kernel developers and many contributors to the associated
    user space tools (such as `bpftool`, which we’ll meet in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)),
    compilers, and programming language libraries. Programs were once limited to 4,096
    instructions, but that limit has grown to 1 million verified instructions^([5](ch01.html#ch01fn9))
    and has effectively been rendered irrelevant by support for tail calls and function
    calls (which you’ll see in Chapters [2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    and [3](ch03.html#anatomy_of_an_ebpf_program)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，由于300多名内核开发人员的工作以及许多贡献者对关联用户空间工具（如我们将在[第3章](ch03.html#anatomy_of_an_ebpf_program)中介绍的`bpftool`）的贡献，eBPF的能力显著增强。程序曾经限制在4096条指令，但现在已经增长到100万条经过验证的指令^([5](ch01.html#ch01fn9))，并且通过对尾调用和函数调用的支持，这一限制实际上已经变得不再重要（这些内容将在第[2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)和[3章](ch03.html#anatomy_of_an_ebpf_program)中介绍）。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For deeper insight into the history of eBPF, who better to refer to than the
    maintainers who have been working on it from the beginning?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想要深入了解eBPF的历史，最好去咨询那些从一开始就在这项技术上工作的维护者们。
- en: Alexei Starovoitov gave a fascinating presentation about the [history of BPF](https://youtu.be/DAvZH13725I)
    from its roots in software-defined networking (SDN). In this talk, he discusses
    the strategies used to get the early eBPF patches accepted into the kernel and
    reveals that the official birthday of eBPF is September 26, 2014, which marked
    the acceptance of the first set of patches covering the verifier, BPF system call,
    and maps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Alexei Starovoitov对[BPF的历史](https://youtu.be/DAvZH13725I)进行了一次引人入胜的演讲，从软件定义网络（SDN）的根源开始。在这次演讲中，他讨论了早期eBPF补丁被接受进内核的策略，并透露了eBPF的官方生日是2014年9月26日，标志着第一批涵盖验证器、BPF系统调用和映射的补丁被接受。
- en: 'Daniel Borkmann has also discussed the history of BPF and its evolution to
    support networking and tracing functionality. I highly recommend his talk [“eBPF
    and Kubernetes: Little Helper Minions for Scaling Microservices”](https://youtu.be/99jUcLt3rSk),
    which is full of interesting nuggets of information.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Daniel Borkmann还讨论了BPF的历史以及其演变支持网络和跟踪功能。我强烈推荐他的演讲[“eBPF和Kubernetes：扩展微服务的小助手”](https://youtu.be/99jUcLt3rSk)，其中充满了有趣的信息片段。
- en: Naming Is Hard
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名是困难的。
- en: eBPF’s applications range so far beyond packet filtering that the acronym is
    essentially meaningless now, and it has become a standalone term. And since the
    Linux kernels in widespread use these days all have support for the “extended”
    parts, the terms *eBPF* and *BPF* are largely used interchangeably. In the kernel
    source code and in eBPF programming, the common terminology is *BPF*. For example,
    as we’ll see in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    the system call for interacting with eBPF is `bpf()`, helper functions start with
    `bpf_`, and the different types of (e)BPF programs are identified with names that
    start with `BPF_PROG_TYPE`. Outside the kernel community, the name “eBPF” seems
    to have stuck, for example, in the community site [ebpf.io](https://ebpf.io) and
    in the name of the [eBPF Foundation](http://ebpf.foundation).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 的应用远远超出了数据包过滤的范围，以至于这个缩写现在基本上没有意义，它已经成为一个独立的术语。由于目前广泛使用的 Linux 内核都支持“扩展”部分，因此
    *eBPF* 和 *BPF* 这两个术语基本上可以互换使用。在内核源代码和 eBPF 编程中，通用术语是 *BPF*。例如，正如我们将在 [第四章](ch04.html#the_bpfleft_parenthesisright_parenthesi)
    中看到的那样，与 eBPF 交互的系统调用是 `bpf()`，辅助函数以 `bpf_` 开头，而不同类型的 (e)BPF 程序则以 `BPF_PROG_TYPE`
    开头命名。在内核社区之外，“eBPF” 这个名字似乎已经被接受，例如在社区网站 [ebpf.io](https://ebpf.io) 和 [eBPF Foundation](http://ebpf.foundation)
    的名称中。
- en: The Linux Kernel
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 内核
- en: To understand eBPF you’ll need a solid grasp of the difference between the kernel
    and user space in Linux. I covered this in my report “What Is eBPF?”^([6](ch01.html#ch01fn10))
    and I’ve adapted some of that content for the next few paragraphs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 eBPF，你需要对 Linux 中内核和用户空间的区别有深入的了解。我在我的报告 “What Is eBPF?”^([6](ch01.html#ch01fn10))
    中已经涵盖了这一点，并且我已经为接下来的几段内容做了一些调整。
- en: The Linux kernel is the software layer between your applications and the hardware
    they’re running on. Applications run in an unprivileged layer called *user space*,
    which can’t access hardware directly. Instead, an application makes requests using
    the system call (syscall) interface to request the kernel to act on its behalf.
    That hardware access can involve reading and writing to files, sending or receiving
    network traffic, or even just accessing memory. The kernel is also responsible
    for coordinating concurrent processes, enabling many applications to run at once.
    This is illustrated in [Figure 1-1](#applications_in_user_space_use_the_sysc).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核是应用程序和它们运行在的硬件之间的软件层。应用程序运行在一个称为 *用户空间* 的非特权层中，不能直接访问硬件。相反，应用程序使用系统调用（syscall）接口向内核请求代表其执行操作。硬件访问可以涉及读写文件、发送或接收网络流量，甚至只是访问内存。内核还负责协调并发进程，使许多应用程序可以同时运行。这在
    [图 1-1](#applications_in_user_space_use_the_sysc) 中有所体现。
- en: As application developers, we typically don’t use the system call interface
    directly, because programming languages give us high-level abstractions and standard
    libraries that are easier interfaces to program. As a result, a lot of people
    are blissfully unaware of how much the kernel is doing while our programs run.
    If you want to get a sense of how often the kernel is invoked, you can use the
    `strace` utility to show all the system calls an application makes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发者，我们通常不直接使用系统调用接口，因为编程语言提供了高级抽象和标准库，这些更容易编程的接口。因此，很多人对内核在我们程序运行时所做的工作一无所知。如果你想了解内核被调用的频率，可以使用
    `strace` 实用程序显示应用程序进行的所有系统调用。
- en: '![Applications in user space use the syscall interface to make requests to
    the kernel](assets/lebp_0101.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![用户空间中的应用程序使用系统调用接口向内核发出请求](assets/lebp_0101.png)'
- en: Figure 1-1\. Applications in user space use the syscall interface to make requests
    to the kernel
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 用户空间中的应用程序使用系统调用接口向内核发出请求。
- en: 'Here’s an example, where using `cat` to echo the word *hello* to the screen
    involves more than 100 system calls:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，使用 `cat` 将单词 *hello* 回显到屏幕上涉及超过 100 次系统调用：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because applications rely so heavily on the kernel, it means we can learn a
    lot about how an application behaves if we can observe its interactions with the
    kernel. With eBPF we can add instrumentation into the kernel to get these insights.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为应用程序在很大程度上依赖于内核，这意味着如果我们能观察应用程序与内核的交互，我们就可以了解应用程序的行为方式。使用 eBPF，我们可以在内核中添加仪表，以获得这些见解。
- en: For example, if you are able to intercept the system call for opening files,
    you can see exactly which files any application accesses. But how could you do
    that interception? Let’s consider what would be involved if we wanted to modify
    the kernel, adding new code to create some kind of output whenever that system
    call is invoked.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你能拦截打开文件的系统调用，你可以精确地看到任何应用程序访问的文件。但是你如何进行这种拦截？让我们考虑一下，如果我们想要修改内核，添加新代码以在调用该系统调用时创建某种输出，会涉及到什么。
- en: Adding New Functionality to the Kernel
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向内核添加新功能
- en: The Linux kernel is complex, with around 30 million lines of code at the time
    of this writing.^([7](ch01.html#ch01fn11)) Making a change to any codebase requires
    some familiarity with the existing code, so unless you’re a kernel developer already,
    this is likely to present a challenge.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核在撰写本文时非常复杂，大约有3000万行代码。^([7](ch01.html#ch01fn11)) 对任何代码库进行更改都需要对现有代码有一定的了解，因此，除非你已经是一个内核开发人员，否则这可能会是一个挑战。
- en: Additionally, if you want to contribute your change upstream, you’ll be facing
    a challenge that isn’t purely technical. Linux is a general-purpose operating
    system, used in all manner of environments and circumstances. This means that
    if you want your change to become part of an official Linux release, it’s not
    simply a matter of writing code that works. The code has to be accepted by the
    community (and more specifically by Linus Torvalds, creator and main developer
    of Linux) as a change that will be for the greater good of all. This isn’t a given—only
    one-third of submitted kernel patches are accepted.^([8](ch01.html#ch01fn12))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想要向上游贡献你的变更，你将面临一个不仅仅是技术上的挑战。Linux是一个通用操作系统，在各种环境和情况下使用。这意味着，如果你希望你的变更成为官方Linux发布的一部分，这不仅仅是编写有效代码的问题。代码必须被社区接受（更具体地说是被Linux的创始人和主要开发者Linus
    Torvalds接受），作为对所有人都有利的变更。这并非是理所当然的事情——只有三分之一的提交的内核补丁被接受。^([8](ch01.html#ch01fn12))
- en: Let’s suppose you’ve figured out a good technical approach for intercepting
    the system call for opening files. After some months of discussion and some hard
    development work on your part, let’s imagine the change is accepted into the kernel.
    Great! But how long will it be until it arrives on everyone’s machines?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经想出了一个良好的技术方法来拦截打开文件的系统调用。经过几个月的讨论和你的一些艰苦开发工作后，想象一下这个变更被内核接受了。太棒了！但是它会在所有人的机器上到达之前需要多长时间呢？
- en: There’s a new release of the Linux kernel every two or three months, but even
    when a change has made it into one of these releases, it’s still some time away
    from being available in most people’s production environments. This is because
    most of us don’t just use the Linux kernel directly—we use Linux distributions
    like Debian, Red Hat, Alpine, and Ubuntu that package up a version of the Linux
    kernel with various other components. You may well find that your favorite distribution
    is using a kernel release that’s several years old.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核每两三个月就会有一个新版本发布，但即使某个变更已经包含在这些版本中，它仍需一段时间才能在大多数人的生产环境中可用。这是因为我们大多数人不直接使用Linux内核，而是使用像Debian、Red
    Hat、Alpine和Ubuntu这样的Linux发行版，这些发行版将Linux内核与各种其他组件打包在一起。你很可能会发现你喜爱的发行版使用的内核版本已经几年前的了。
- en: For example, a lot of enterprise users employ Red Hat Enterprise Linux (RHEL).
    At the time of this writing, the current release is RHEL 8.5, dated November 2021,
    and it uses version 4.18 of the Linux kernel. This kernel was released in August
    2018.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，很多企业用户采用Red Hat Enterprise Linux（RHEL）。截至撰写本文时，当前版本为RHEL 8.5，发布日期为2021年11月，使用的Linux内核版本为4.18。该内核发布于2018年8月。
- en: As illustrated in the cartoon in [Figure 1-2](#adding_features_to_the_kernel_left_pare),
    it takes literally years to get new functionality from the idea stage into a production
    environment Linux kernel.^([9](ch01.html#ch01fn13))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第[Figure 1-2](#adding_features_to_the_kernel_left_pare)中的漫画所示，将新功能从想法阶段引入生产环境的Linux内核需要几乎数年时间。^([9](ch01.html#ch01fn13))
- en: '![Adding features to the kernel (cartoon by Vadim Shchekoldin, Isovalent)](assets/lebp_0102.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![向内核添加功能（由Isovalent的Vadim Shchekoldin绘制的漫画）](assets/lebp_0102.png)'
- en: Figure 1-2\. Adding features to the kernel (cartoon by Vadim Shchekoldin, Isovalent)
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 向内核添加功能（由Isovalent的Vadim Shchekoldin绘制的漫画）
- en: Kernel Modules
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模块
- en: If you don’t want to wait years for your change to make it into the kernel,
    there is another option. The Linux kernel was designed to accept kernel modules,
    which can be loaded and unloaded on demand. If you want to change or extend kernel
    behavior, writing a module is certainly one way to do it. A kernel module can
    be distributed for others to use independent of the official Linux kernel release,
    so it doesn’t have to be accepted into the main upstream codebase.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想等待数年才能让你的改动进入内核，还有另一种选择。Linux 内核设计成可以接受内核模块，这些模块可以按需加载和卸载。如果你想改变或扩展内核行为，编写一个模块当然是一种方法。内核模块可以分发给其他人使用，独立于官方
    Linux 内核版本，因此不需要被合并到主要上游代码库中。
- en: 'The biggest challenge here is that this is still full-on kernel programming.
    Users have historically been very cautious about using kernel modules, for one
    simple reason: if kernel code crashes, it takes down the machine and everything
    running on it. How can a user be confident that a kernel module is safe to run?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的挑战在于这仍然是完整的内核编程。用户在使用内核模块时历来非常谨慎，一个简单的原因是：如果内核代码崩溃，将导致整个机器和运行在上面的所有东西都崩溃。用户如何确信一个内核模块是安全可运行的？
- en: Being “safe to run” doesn’t just mean not crashing—the user wants to know that
    a kernel module is safe from a security perspective. Does it include vulnerabilities
    that an attacker could exploit? Do we trust the authors of the module not to put
    malicious code in it? Because the kernel is privileged code, it has access to
    everything on the machine, including all the data, so malicious code in the kernel
    would be a serious cause for concern. This applies to kernel modules too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “安全运行”不仅意味着不崩溃—用户还想知道一个内核模块从安全性角度是否安全。它是否包含攻击者可能利用的漏洞？我们是否信任模块的作者没有在其中放入恶意代码？因为内核是特权代码，它可以访问机器上的一切，包括所有数据，因此内核中的恶意代码将是一个严重的问题。这也适用于内核模块。
- en: The safety of the kernel is one important reason why Linux distributions take
    so long to incorporate new releases. If other people have been running a kernel
    version in a variety of circumstances for months or years, this should have flushed
    out issues. The distribution maintainers can have some confidence that the kernel
    they ship to their users/customers is *hardened*—that is, it is safe to run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内核安全性是 Linux 发行版需要很长时间才能整合新版本的一个重要原因。如果其他人在各种情况下运行了一个内核版本数月甚至数年，这应该能够找出其中的问题。发行版维护者可以相信他们向用户/客户发布的内核已经经过*强化*—即，可以安全运行。
- en: 'eBPF offers a very different approach to safety: the *eBPF verifier*, which
    ensures that an eBPF program is loaded only if it’s safe to run—it won’t crash
    the machine or lock it up in a hard loop, and it won’t allow data to be compromised.
    We’ll discuss the verification process in more detail in [Chapter 6](ch06.html#the_ebpf_verifier).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 提供了一种非常不同的安全方式：*eBPF 验证器*，它确保只有在安全的情况下才加载 eBPF 程序—这不会使机器崩溃或者陷入死循环，并且不会允许数据被泄漏。我们将在[第
    6 章](ch06.html#the_ebpf_verifier)中详细讨论验证过程。
- en: Dynamic Loading of eBPF Programs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF 程序的动态加载
- en: eBPF programs can be loaded into and removed from the kernel dynamically. Once
    they are attached to an event, they’ll be triggered by that event regardless of
    what caused that event to occur. For example, if you attach a program to the syscall
    for opening files, it will be triggered whenever any process tries to open a file.
    It doesn’t matter whether that process was already running when the program was
    loaded. This is a huge advantage compared to upgrading the kernel and then having
    to reboot the machine to use its new functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 程序可以动态加载到内核中，并且可以随时卸载。一旦它们附加到一个事件上，它们将被该事件触发，不论是什么导致了该事件的发生。例如，如果你将一个程序附加到打开文件的系统调用上，那么无论何时任何进程尝试打开文件，它都会被触发。这与升级内核然后必须重新启动机器以使用其新功能相比是一个巨大的优势。
- en: This leads to one of the great strengths of observability or security tooling
    that uses eBPF—it instantly gets visibility over everything that’s happening on
    the machine. In environments running containers, that includes visibility over
    all processes running inside those containers as well as on the host machine.
    I’ll dig into the consequences of this for cloud native deployments later in this
    chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致使用 eBPF 的可观测性或安全工具的一大优势—它立即获得对机器上发生的所有事情的可见性。在运行容器的环境中，这包括对所有运行在这些容器内及主机上的进程的可见性。我将在本章后面深入探讨这对云原生部署的影响。
- en: Additionally, as illustrated in [Figure 1-3](#adding_kernel_features_with_ebpf_left_p),
    people can create new kernel functionality very quickly through eBPF without requiring
    every other Linux user to accept the same changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如在[图 1-3](#adding_kernel_features_with_ebpf_left_p)中所示，人们可以通过eBPF快速创建新的内核功能，而无需让每个Linux用户都接受相同的更改。
- en: '![Adding kernel features with eBPF (cartoon by Vadim Shchekoldin, Isovalent)](assets/lebp_0103.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![通过eBPF添加内核功能（Vadim Shchekoldin, Isovalent提供的漫画）](assets/lebp_0103.png)'
- en: Figure 1-3\. Adding kernel features with eBPF (cartoon by Vadim Shchekoldin,
    Isovalent)
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 通过eBPF添加内核功能（Vadim Shchekoldin, Isovalent提供的漫画）
- en: High Performance of eBPF Programs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF程序的高性能
- en: eBPF programs are a very efficient way to add instrumentation. Once loaded and
    JIT-compiled (which you’ll see in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)),
    the program runs as native machine instructions on the CPU. Additionally, there’s
    no need to incur the cost of transitioning between kernel and user space (which
    is an expensive operation) to handle each event.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序是增加仪表化的一种非常高效的方式。一旦加载并进行即时编译（您将在[第三章](ch03.html#anatomy_of_an_ebpf_program)中看到），程序将作为本机机器指令在CPU上运行。此外，无需承担每个事件处理时内核和用户空间之间转换的成本（这是一项昂贵的操作）。
- en: The 2018 paper^([10](ch01.html#ch01fn14)) that describes the eXpress Data Path
    (XDP) includes some illustrations of the kinds of performance improvements eBPF
    enables in networking. For example, implementing routing in XDP “improves performance
    with a factor of 2.5” compared to the regular Linux kernel implementation, and
    “XDP offers a performance gain of 4.3x over IPVS” for load balancing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 描述eXpress Data Path (XDP)的2018年论文^([10](ch01.html#ch01fn14))包括一些插图，展示了eBPF在网络中带来的性能改进。例如，在XDP中实现路由“相比常规Linux内核实现提升了2.5倍性能”，并且“XDP相比于IPVS提供了4.3倍的性能增益”用于负载平衡。
- en: For performance tracing and security observability, another advantage of eBPF
    is that relevant events can be filtered within the kernel before incurring the
    costs of sending them to user space. Filtering only certain network packets was,
    after all, the point of the original BPF implementation. Today eBPF programs can
    collect information about all manner of events across a system, and they can use
    complex, customized programmatic filters to send only the relevant subset of information
    to user space.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能跟踪和安全可观察性，eBPF的另一个优势是，在将相关事件发送到用户空间的成本之前，可以在内核中对其进行过滤。毕竟，最初的BPF实现的目的就是仅过滤特定的网络数据包。如今，eBPF程序可以收集系统中各种事件的信息，并可以使用复杂的、定制的程序化过滤器，仅向用户空间发送相关的信息子集。
- en: eBPF in Cloud Native Environments
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生环境中的eBPF
- en: 'These days lots of organizations choose not to run applications by executing
    programs directly on servers. Instead, many use cloud native approaches: containers,
    orchestrators such as Kubernetes or ECS, or serverless approaches like Lambda,
    cloud functions, Fargate, and so on. These approaches all use automation to choose
    the server where each workload will run; in serverless, we’re not even aware what
    server is running each workload.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多组织选择不直接在服务器上执行程序来运行应用程序。相反，许多使用云原生方法：容器、诸如Kubernetes或ECS的编排器，或者像Lambda、云函数、Fargate等的无服务器方法。这些方法都使用自动化来选择每个工作负载将运行的服务器；在无服务器中，我们甚至不知道每个工作负载在哪台服务器上运行。
- en: Nevertheless, there are servers involved, and each of those servers (whether
    it’s a virtual machine or bare-metal machine) runs a kernel. Where applications
    run in a container, if they’re running on the same (virtual) machine, they share
    the same kernel. In a Kubernetes environment, this means all the containers in
    all the pods on a given node are using the same kernel. When we instrument that
    kernel with eBPF programs, all the containerized workloads on that node are visible
    to those eBPF programs, as illustrated in [Figure 1-4](#ebpf_programs_in_the_kernel_have_visibi).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管涉及到服务器，每个服务器（无论是虚拟机还是裸机）都运行着一个内核。在容器中运行应用程序时，如果它们在同一（虚拟）机器上运行，则共享同一个内核。在Kubernetes环境中，这意味着在给定节点上的所有pod中的所有容器都在使用同一个内核。当我们用eBPF程序进行内核仪表化时，那个节点上的所有容器化工作负载对这些eBPF程序都是可见的，正如[图 1-4](#ebpf_programs_in_the_kernel_have_visibi)所示。
- en: '![eBPF programs in the kernel have visibility of all applications running on
    a Kubernetes node](assets/lebp_0104.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![eBPF程序在内核中具有对运行在Kubernetes节点上所有应用程序的可见性](assets/lebp_0104.png)'
- en: Figure 1-4\. eBPF programs in the kernel have visibility of all applications
    running on a Kubernetes node
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. eBPF程序在内核中具有对运行在Kubernetes节点上所有应用程序的可见性
- en: 'Visibility of all the processes on the node, combined with the ability to load
    eBPF programs dynamically, gives us the real superpowers of eBPF-based tooling
    in cloud native computing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 节点上所有进程的可见性，加上能够动态加载 eBPF 程序的能力，使我们在云原生计算中使用基于 eBPF 的工具具备真正的超能力：
- en: We don’t need to change our applications, or even the way they are configured,
    to instrument them with eBPF tooling.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要更改应用程序，甚至不需要更改它们的配置方式来使用 eBPF 工具。
- en: As soon as it’s loaded into the kernel and attached to an event, an eBPF program
    can start observing preexisting application processes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦加载到内核并附加到事件，eBPF 程序就可以开始观察现有的应用程序进程。
- en: 'Contrast this with the *sidecar model*, which has been used to add functionality
    like logging, tracing, security, and service mesh functionality into Kubernetes
    apps. In the sidecar approach, the instrumentation runs as a container that is
    “injected” into each application pod. This process involves modifying the YAML
    that defines the application pods, adding in the definition of the sidecar container.
    This approach is certainly more convenient than adding the instrumentation into
    the source code of the application (which is what we had to do before the sidecar
    approach; for example, including a logging library in our application and making
    calls into that library at appropriate points in the code). Nevertheless, the
    sidecar approach has a few downsides:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *旁车模型* 相对比，该模型已被用于将日志记录、跟踪、安全性和服务网格功能等功能添加到 Kubernetes 应用程序中。在旁车方法中，工具化作为一个“注入”到每个应用程序
    pod 中的容器运行。这个过程涉及修改定义应用程序 pod 的 YAML，增加旁车容器的定义。这种方法确实比将工具化添加到应用程序源代码中更为方便（这是我们在旁车方法之前必须做的事情；例如，在应用程序中包含日志记录库，并在代码中适当位置调用该库）。然而，旁车方法也有一些缺点：
- en: The application pod has to be restarted for the sidecar to be added.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序 pod 必须重新启动以添加旁车。
- en: Something has to modify the application YAML. This is generally an automated
    process, but if something goes wrong, the sidecar won’t be added, which means
    the pod doesn’t get instrumented. For example, a deployment might be annotated
    to indicate that an admission controller should add the sidecar YAML to the pod
    spec for that deployment. But if the deployment isn’t labeled correctly, the sidecar
    won’t get added, and it’s therefore not visible to the instrumentation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有某种方式修改应用程序 YAML。通常这是一个自动化的过程，但如果出现问题，旁车将无法添加，这意味着 pod 不会被工具化。例如，部署可以被注释以指示准入控制器应该向该部署的
    pod 规范中添加旁车 YAML。但如果部署没有正确标记，旁车就不会被添加，因此不会被工具化。
- en: When there are multiple containers within a pod, they might reach readiness
    at different times, the ordering of which may not be predictable. Pod start-up
    time can be significantly slowed by the injection of sidecars, or worse, it can
    cause race conditions or other instabilities. For example, the [Open Service Mesh
    documentation](https://oreil.ly/z80Q5) describes how application containers have
    to be resilient to all traffic being dropped until the Envoy proxy container is
    ready.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个 pod 中有多个容器时，它们可能在不同的时间到达就绪状态，其顺序可能是不可预测的。通过注入旁车，pod 的启动时间可能会显著延长，或者更糟糕的是，可能会导致竞争条件或其他不稳定性。例如，[Open
    Service Mesh 文档](https://oreil.ly/z80Q5)描述了应用程序容器必须能够处理所有流量被丢弃，直到 Envoy 代理容器准备就绪的情况。
- en: Where networking functionality such as service mesh is implemented as a sidecar,
    it necessarily means that all traffic to and from the application container has
    to travel through the network stack in the kernel to reach a network proxy container,
    adding latency to that traffic; this is illustrated in [Figure 1-5](#path_of_a_network_packet_using_a_networ).
    We’ll talk about improving network efficiency with eBPF in [Chapter 9](ch09.html#ebpf_for_security).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在像服务网格这样的网络功能实现为旁车时，这必然意味着所有与应用程序容器之间的流量都必须通过内核中的网络堆栈到达网络代理容器，从而增加了流量的延迟；这在[图 1-5](#path_of_a_network_packet_using_a_networ)中有所体现。我们将在[第
    9 章](ch09.html#ebpf_for_security)中讨论如何使用 eBPF 改善网络效率。
- en: '![Path of a network packet using a service mesh proxy sidecar container](assets/lebp_0105.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![网络包路径使用服务网格代理旁车容器](assets/lebp_0105.png)'
- en: Figure 1-5\. Path of a network packet using a service mesh proxy sidecar container
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-5\. 网络包路径使用服务网格代理旁车容器
- en: All these issues are inherent problems with the sidecar model. Fortunately,
    now that eBPF is available as a platform, we have a new model that can avoid these
    issues. Additionally, because eBPF-based tools can see everything that’s happening
    on a (virtual) machine, they are harder for bad actors to sidestep. For example,
    if an attacker manages to deploy a cryptocurrency mining app on one of your hosts,
    they probably won’t do you the courtesy of instrumenting it with the sidecars
    you’re using on your application workloads. If you’re relying on a sidecar-based
    security tool to prevent apps from making unexpected network connections, that
    tool isn’t going to spot the mining app connecting to its mining pool if the sidecar
    isn’t injected. In contrast, network security implemented in eBPF can police all
    traffic on the host machine, so this cryptocurrency mining operation could easily
    be stopped. The ability to drop network packets for security reasons is something
    we’ll come back to in [Chapter 8](ch08.html#ebpf_for_networking).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都是侧车模型固有的问题。幸运的是，现在eBPF作为一个平台可用，我们有了一个可以避免这些问题的新模型。此外，由于基于eBPF的工具可以查看（虚拟）机器上发生的一切，它们对于恶意行为者来说更难以规避。例如，如果攻击者成功在您的主机上部署了一个加密货币挖掘应用程序，他们可能不会在您的应用工作负载上使用的侧车工具中加入它。如果您依赖于基于侧车的安全工具来防止应用程序进行意外的网络连接，那么如果未注入侧车，该工具将无法发现挖掘应用连接到其挖掘池。相比之下，基于eBPF实施的网络安全可以监管主机上的所有流量，因此这种加密货币挖掘操作很容易被阻止。有关出于安全原因丢弃网络数据包的能力，我们将在[第8章](ch08.html#ebpf_for_networking)中回到这个问题。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope this chapter has given you some insight into why eBPF as a platform is
    so powerful. It allows us to change the behavior of the kernel, providing us the
    flexibility to build bespoke tools or customized policies. eBPF-based tools can
    observe any event across the kernel, and hence across all applications running
    on a (virtual) machine, whether they are containerized or not. eBPF programs can
    also be deployed dynamically, allowing behavior to be changed on the fly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章为您解释了eBPF作为平台如此强大的原因。它允许我们改变内核的行为，为我们提供构建定制工具或自定义策略的灵活性。基于eBPF的工具可以观察（虚拟）机器上发生的任何事件，因此可以观察到所有正在运行的应用程序，无论它们是否容器化。eBPF程序还可以动态部署，允许在运行时更改行为。
- en: So far we’ve discussed eBPF at a relatively conceptual level. In the next chapter
    we’ll make it more concrete and explore the constituent parts of an eBPF-based
    application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在相对概念化的层次上讨论了eBPF。在下一章中，我们将使其更加具体，并探索基于eBPF的应用程序的组成部分。
- en: '^([1](ch01.html#ch01fn4-marker)) [“The BSD Packet Filter: A New Architecture
    for User-level Packet Capture”](https://oreil.ly/4GpgQ) by Steven McCanne and
    Van Jacobson.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](ch01.html#ch01fn4-marker)) 由Steven McCanne和Van Jacobson撰写的[“The BSD Packet
    Filter: A New Architecture for User-level Packet Capture”](https://oreil.ly/4GpgQ)。'
- en: ^([2](ch01.html#ch01fn5-marker)) These and other details come from Alexei Starovoitov’s
    2015 NetDev presentation, [“BPF – in-kernel virtual machine”](https://oreil.ly/hISe1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#ch01fn5-marker)) 这些以及其他细节来自于Alexei Starovoitov在2015年NetDev会议上的演示，[“BPF
    – in-kernel virtual machine”](https://oreil.ly/hISe1)。
- en: ^([3](ch01.html#ch01fn6-marker)) There is a good description of how kprobes
    work in [the kernel documentation](https://oreil.ly/Ue6Ii).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#ch01fn6-marker)) 在[内核文档](https://oreil.ly/Ue6Ii)中有关kprobes工作方式的良好描述。
- en: '^([4](ch01.html#ch01fn7-marker)) This wonderful fact comes from Daniel Borkmann’s
    KubeCon 2020 talk titled [“eBPF and Kubernetes: Little Helper Minions for Scaling
    Microservices”](https://oreil.ly/tIR9o).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch01.html#ch01fn7-marker)) 这个令人惊叹的事实来自Daniel Borkmann在KubeCon 2020上的演讲，题为[“eBPF
    and Kubernetes: Little Helper Minions for Scaling Microservices”](https://oreil.ly/tIR9o)。'
- en: ^([5](ch01.html#ch01fn9-marker)) For more details on the instruction limit and
    “complexity limit,” see [*https://oreil.ly/0iVer*](https://oreil.ly/0iVer).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01.html#ch01fn9-marker)) 关于指令限制和“复杂性限制”的更多细节，请参阅[*https://oreil.ly/0iVer*](https://oreil.ly/0iVer)。
- en: ^([6](ch01.html#ch01fn10-marker)) Extract from “What Is eBPF?” by Liz Rice.
    Copyright © 2022 O’Reilly Media. Used with permission.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01.html#ch01fn10-marker)) 摘自Liz Rice的“What Is eBPF?”。版权所有 © 2022 O’Reilly
    Media，已授权使用。
- en: ^([7](ch01.html#ch01fn11-marker)) [“Linux 5.12 Coming In At Around 28.8 Million
    Lines”](https://oreil.ly/9zJP2). Phoronix, March 2021.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch01.html#ch01fn11-marker)) [“Linux 5.12 Coming In At Around 28.8 Million
    Lines”](https://oreil.ly/9zJP2). Phoronix, March 2021.
- en: ^([8](ch01.html#ch01fn12-marker)) Jiang Y, Adams B, German DM. 2013\. [“Will
    My Patch Make It? And How Fast?”](https://oreil.ly/rj2P4) (2013). According to
    this research paper, 33% of patches are accepted, and most take three to six months.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch01.html#ch01fn12-marker)) 江宇，亚当斯，德国人DM。2013年。[“我的补丁会通过吗？以及有多快？”](https://oreil.ly/rj2P4)（2013）。根据这篇研究论文，有33%的补丁被接受，大多数需要三到六个月的时间。
- en: ^([9](ch01.html#ch01fn13-marker)) Thankfully, security patches to existing functionality
    are made available more quickly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch01.html#ch01fn13-marker)) 幸运的是，对现有功能的安全补丁更快地提供。
- en: '^([10](ch01.html#ch01fn14-marker)) Høiland-Jørgensen T, Brouer JD, Borkmann
    D, et al. [“The eXpress data path: fast programmable packet processing in the
    operating system kernel”](https://oreil.ly/qyhLK). *Proceedings of the 14th International
    Conference on emerging Networking EXperiments and Technologies* (CoNEXT ’18).
    Association for Computing Machinery; 2018:54–66.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch01.html#ch01fn14-marker)) Høiland-Jørgensen T，Brouer JD，Borkmann D等。[“eXpress数据路径：操作系统内核中快速可编程数据包处理”](https://oreil.ly/qyhLK)。*第14届新兴网络实验与技术国际会议论文集*（CoNEXT
    ’18）。计算机协会；2018：54–66。
