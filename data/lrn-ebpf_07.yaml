- en: Chapter 7\. eBPF Program and Attachment Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. eBPF 程序和附着类型
- en: In the preceding chapters you saw lots of examples of eBPF programs, and you
    probably spotted the fact that they are attached to different types of events.
    Some of the examples I’ve shown attach to kprobes, but in other examples I’ve
    demonstrated XDP programs that handle a newly arrived network packet. These are
    just two of the many attachment points within the kernel. In this chapter we’ll
    take a deeper look at different program types and how they can be attached to
    different events.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了很多 eBPF 程序的例子，可能注意到它们附着在不同类型的事件上。我展示的一些例子附着在 kprobe 上，但在其他例子中，我展示了处理新到达的网络数据包的
    XDP 程序。这些只是内核中许多附着点中的两个。在本章中，我们将深入探讨不同的程序类型以及它们如何附着到不同的事件上。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can build and run the examples from this chapter using the code and instructions
    at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter7* directory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    上的代码和指导来构建和运行本章的示例。本章的代码位于 *chapter7* 目录中。
- en: At the time of this writing, some of the examples are not supported on ARM processors.
    Check out the *README* file in the *chapter7* directory for more details and advice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，一些示例在 ARM 处理器上不受支持。请查看 *chapter7* 目录下的 *README* 文件以获取更多详细信息和建议。
- en: There are currently around 30 program types enumerated in [*uapi/linux/bpf.h*](https://oreil.ly/6dNIW),
    and more than 40 attachment types. The attachment type defines more specifically
    where the program gets attached; for lots of program types, the attachment type
    can be inferred from the program type, but some program types can be attached
    to multiple different points in the kernel, so an attachment type has to be specified
    as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 [*uapi/linux/bpf.h*](https://oreil.ly/6dNIW) 中列出了大约 30 种程序类型，以及超过 40 种附着类型。附着类型更具体地定义了程序附着的位置；对于许多程序类型，附着类型可以从程序类型推断出来，但某些程序类型可以附着到内核中多个不同的点，因此还必须指定附着类型。
- en: As you know, this book isn’t intended to be a reference manual, so I won’t cover
    every single eBPF program type. There’s a good chance that new types will have
    been added by the time you read this book anyway!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，本书不是一本参考手册，因此我不会详细介绍每一种 eBPF 程序类型。不过，在你阅读本书时，很可能已经新增了新的类型！
- en: Program Context Arguments
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序上下文参数
- en: All eBPF programs take a context argument that is a pointer, but the structure
    it points to depends on the type of event that triggered it. eBPF programmers
    need to write programs that accept the appropriate type of context; there is no
    point in pretending that the context argument points to a network packet if the
    event is, say, a tracepoint. Defining different types of programs allows the verifier
    to ensure that the contextual information is handled appropriately and to enforce
    rules about what helper functions are permissible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 eBPF 程序都需要一个指针类型的上下文参数，但它所指向的结构取决于触发它的事件类型。eBPF 程序员需要编写能够接受适当类型上下文的程序；如果事件是跟踪点，那么假装上下文参数指向网络数据包是没有意义的。定义不同类型的程序允许验证器确保上下文信息被适当处理，并强制执行关于哪些辅助函数是允许的规则。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To dive into the details of the context data passed to different BPF program
    types, check out [this post by Alan Maguire on Oracle’s blog](https://oreil.ly/6dNIW).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解传递给不同 BPF 程序类型的上下文数据的详细信息，请查看 Alan Maguire 在 Oracle 博客上的[这篇文章](https://oreil.ly/6dNIW)。
- en: Helper Functions and Return Codes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助函数和返回代码
- en: As you saw in the previous chapter, the verifier checks that all helper functions
    used by a program are compatible with its program type. The example in the previous
    chapter demonstrated that the `bpf_get_current_pid_tgid()` helper function isn’t
    permitted in an XDP program. There is no user space process or thread involved
    at the point where a packet is received and the XDP hook is triggered, so a call
    to discover the current process and thread ID doesn’t make sense in that context.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所示，验证器检查程序使用的所有辅助函数是否与其程序类型兼容。前一章的示例表明，在 XDP 程序中不允许使用 `bpf_get_current_pid_tgid()`
    辅助函数。在接收数据包并触发 XDP 钩子时，并没有涉及用户空间的进程或线程，因此在这种情况下调用获取当前进程和线程 ID 的函数是没有意义的。
- en: The program type also determines the meaning of the return code from the program.
    Again using XDP as an example, the return code value tells the kernel what to
    do with the packet once the eBPF program has finished processing it—which could
    involve passing it to the network stack, dropping it, or redirecting it to a different
    interface. These return codes wouldn’t make any sense when an eBPF program is
    triggered by, say, hitting a particular tracepoint, where there is no network
    packet involved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序类型还确定了程序的返回代码的含义。再以XDP为例，返回代码告诉内核在eBPF程序完成处理后应该如何处理数据包——包括传递到网络堆栈、丢弃或重定向到另一个接口。当eBPF程序由于某种情况，比如命中特定的tracepoint时，这些返回代码就没有意义了，因为这时候没有涉及到网络数据包。
- en: There is a [manpage for helper functions](https://oreil.ly/e8K73) (with, quite
    reasonably, disclaimers that it might not be complete due to the ongoing development
    of the BPF subsystem).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[助手函数的man页面](https://oreil.ly/e8K73)（带有合理的免责声明，由于BPF子系统的持续开发，该页面可能不完整）。'
- en: You can get a list of which helper functions are available for each program
    type in your version of the kernel with the `bpftool feature` command. This shows
    the system configuration and lists all the available program types and map types,
    and even lists all the helper functions that are supported for each program type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`bpftool feature`命令获取您内核版本中每种程序类型可用的助手函数列表。该命令显示系统配置，并列出所有可用的程序类型和映射类型，甚至列出了每种程序类型支持的所有助手函数。
- en: Helper functions are considered part of the *UAPI*, the Linux kernel’s external,
    stable interface. As such, once a helper function has been defined in the kernel,
    it shouldn’t change in the future, even though the kernel’s internal functions
    and data structures can change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 助手函数被视为*UAPI*的一部分，即Linux内核的外部稳定接口。因此，一旦在内核中定义了助手函数，即使内核的内部函数和数据结构可能会发生变化，助手函数也不应该在将来发生变化。
- en: Despite the risk of changes between kernel versions, there was demand from eBPF
    programmers to be able to access some internal functions from eBPF programs. This
    can be achieved using the mechanism called *BPF kernel functions*, or [*kfuncs*](https://oreil.ly/gKSEx)*.*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内核版本之间可能发生变化，但eBPF程序员需要能够访问一些内部函数。这可以通过称为*BPF内核函数*或[*kfuncs*](https://oreil.ly/gKSEx)*.*的机制来实现。
- en: Kfuncs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kfuncs
- en: Kfuncs allow internal kernel functions to be registered with the BPF subsystem
    so that the verifier will allow them to be called from eBPF programs. There is
    a registration for each eBPF program type that is permitted to call a given kfunc.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Kfuncs允许将内部内核函数注册到BPF子系统中，以便验证器允许它们从eBPF程序中调用。对于每种允许调用特定kfunc的eBPF程序类型都有一个注册。
- en: Unlike helper functions, kfuncs don’t provide compatibility guarantees, so an
    eBPF programmer has to consider the possibility of changes between kernel versions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与助手函数不同，kfuncs不提供兼容性保证，因此eBPF程序员必须考虑内核版本之间的变化可能性。
- en: There is a set of [“core” BPF kfuncs](https://oreil.ly/06qoi), which at the
    time of this writing consists of functions that allow eBPF programs to obtain
    and release kernel references to tasks and cgroups.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组[“核心”BPF kfuncs](https://oreil.ly/06qoi)，目前包括允许eBPF程序获取和释放任务及cgroup内核引用的函数。
- en: To recap, the type of an eBPF program determines what events it can be attached
    to, which in turn defines the type of context information it receives. The program
    type also defines the set of helper functions and kfuncs it can call.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，eBPF程序的类型决定了它可以附加到哪些事件，从而定义了它接收的上下文信息的类型。程序类型还定义了它可以调用的助手函数和kfuncs集合。
- en: 'Program types are broadly considered to fall into two categories: tracing (or
    perf) program types and networking-related program types. Let’s look at some examples.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序类型通常分为两类：跟踪（或perf）程序类型和与网络相关的程序类型。我们来看一些例子。
- en: Tracing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪
- en: Programs that attach to kprobes, tracepoints, raw tracepoints, fentry/fexit
    probes, and perf events were all designed to provide an efficient way for eBPF
    programs in the kernel to report tracing information about events into user space.
    These tracing-related types weren’t expected to influence the way the kernel behaves
    in response to the events they are attached to (although, as you’ll see in [Chapter 9](ch09.html#ebpf_for_security),
    there have been some innovations in this area!).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到 kprobes、tracepoints、原始 tracepoints、fentry/fexit probes 和性能事件的程序，都旨在为内核中的
    eBPF 程序提供一种有效的方式，将关于事件的跟踪信息报告到用户空间。这些与跟踪相关的类型并不预期会影响内核对它们附加的事件的响应方式（尽管正如你在 [第
    9 章](ch09.html#ebpf_for_security) 中看到的，这方面确实有一些创新！）。
- en: 'These are sometimes referred to as “perf-related” programs. For example, the
    `bpftool perf` subcommand lets you view programs attached to perf-related events
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有时被称为“与性能相关的”程序。例如，`bpftool perf` 子命令允许你查看附加到类似性能事件的程序：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding output is what I see when running example code from the *hello.bpf.c*
    file in the *chapter7* directory, which attaches different programs to a variety
    of events that are all related to `execve()`. I’ll discuss all of these types
    in this section, but as an overview, these programs are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是我在 *chapter7* 目录中运行 *hello.bpf.c* 文件中的示例代码时看到的。这些代码附加到与 `execve()` 相关的各种事件，我将在本节中讨论所有这些类型，但作为概述，这些程序包括：
- en: A kprobe attached to the entry point to the `execve()` system call.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个附加到 `execve()` 系统调用入口点的 kprobe。
- en: A kprobe attached to a kernel function, `do_execve()`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个附加到内核函数 `do_execve()` 的 kprobe。
- en: A tracepoint placed at the entry to the `execve()` syscall.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个放置在 `execve()` 系统调用入口处的 tracepoint。
- en: Two versions of a raw tracepoint called during the processing of `execve()`.
    One of these, as you’ll see in this section, is a BTF-enabled version.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理 `execve()` 过程中调用的两个原始 tracepoint 的版本。你将在本节中看到，其中一个是启用了 BTF 的版本。
- en: You’ll need `CAP_PERFMON` and `CAP_BPF` or `CAP_SYS_ADMIN` capabilities to use
    any of the tracing-related eBPF program types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用与跟踪相关的 eBPF 程序类型，你需要 `CAP_PERFMON` 和 `CAP_BPF` 或 `CAP_SYS_ADMIN` 权限。
- en: Kprobes and Kretprobes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kprobes 和 Kretprobes
- en: I discussed the concept of kprobes in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque).
    You can attach kprobe programs almost anywhere in the kernel.^([1](ch07.html#ch07fn1))
    Commonly, they are attached using kprobes to the entry to a function and kretprobes
    to the exit of a function, but you can use kprobes to attach to an instruction
    that is some specified offset after the entry to the function. If you choose to
    do this,^([2](ch07.html#ch07fn2)) you’d need to be confident that the kernel version
    you’re running on has the instruction you want to attach to where you think it
    is! Attaching to kernel function entry and exit points can be relatively stable,
    but arbitrary lines of code might easily be modified from one release to the next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [第 1 章](ch01.html#what_is_ebpf_and_why_is_it_importantque) 中讨论了 kprobes 的概念。你几乎可以将
    kprobe 程序附加到内核的任何位置。^([1](ch07.html#ch07fn1)) 通常，它们使用 kprobes 附加到函数的入口点，使用 kretprobes
    附加到函数的出口点，但你也可以使用 kprobes 附加到函数入口后指定偏移量处的指令。如果你选择这样做，^([2](ch07.html#ch07fn2))
    你需要确信你运行的内核版本确实有你想要附加到的指令！附加到内核函数的入口和出口点可能相对稳定，但任意代码行可能会在不同版本之间轻易修改。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the example output from `bpftool perf list`, you can see that there is an
    offset of 0 for both of the kprobes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bpftool perf list` 的示例输出中，你可以看到两个 kprobe 的偏移量都为 0。
- en: When the kernel is compiled, there’s also the possibility that the compiler
    chooses to “inline” any given kernel function; that is, rather than jump from
    where the function is called, the compiler might emit the machine code to implement
    whatever the function does within the calling functions. If a function happens
    to get inlined, there won’t be a kprobe entry point for your eBPF program to attach
    to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核编译时，也有可能编译器选择“内联”任何给定的内核函数；也就是说，而不是从调用函数处跳转，编译器可能会生成机器代码来实现函数在调用函数内部的操作。如果一个函数被内联了，你的
    eBPF 程序就无法附加到 kprobe 的入口点。
- en: Attaching kprobes to syscall entry points
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加 kprobes 到系统调用入口点
- en: 'The first example eBPF program for this chapter is called `kprobe_sys_execve`,
    and it is a kprobe attached to the `execve()` syscall. The function and its section
    definition look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个示例 eBPF 程序称为 `kprobe_sys_execve`，它是附加到 `execve()` 系统调用的 kprobe。该函数及其段定义如下：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the same as what you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中看到的内容相同。
- en: One reason to attach to syscalls is that they are stable interfaces that won’t
    change between kernel versions (the same is true of tracepoints, which we’ll come
    to shortly). However, syscall kprobes shouldn’t be relied on for security tooling,
    for reasons I’ll cover in detail in [Chapter 9](ch09.html#ebpf_for_security).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到系统调用的一个原因是它们是稳定的接口，在内核版本之间不会改变（跟踪点也是如此，我们马上就会讲到）。然而，出于详细的安全工具原因，不应依赖于系统调用kprobes，我将在[第9章](ch09.html#ebpf_for_security)中详细讨论。
- en: Attaching kprobes to other kernel functions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将kprobes附加到其他内核函数
- en: 'You can find lots of examples where eBPF-based tools use kprobes to attach
    to system calls, but, as mentioned earlier, kprobes can also be attached to any
    noninlined function in the kernel. I’ve provided an example in *hello.bpf.c* that
    attaches a kprobe to the function `do_execve()`, and it’s defined like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到很多例子，eBPF基础工具使用kprobes附加到系统调用，但正如前面提到的，kprobes也可以附加到内核中任何非内联函数。我在*hello.bpf.c*中提供了一个示例，它将kprobe附加到函数`do_execve()`，并且定义如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Because `do_execve()` isn’t a system call, there are a few differences between
    this and the previous example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`do_execve()`不是一个系统调用，所以这与前面的例子有一些区别：
- en: The format of the SEC name is identical to the previous version attached to
    the syscall entry point, but there is no need to define platform-specific variants
    because `do_execve()`, like most kernel functions, is common to all platforms.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEC名称的格式与附加到系统调用入口点的先前版本相同，但无需定义特定于平台的变体，因为像大多数内核函数一样，`do_execve()`对所有平台都是通用的。
- en: I used the `BPF_KPROBE` macro rather than `BPF_KPROBE_SYSCALL`. The intent is
    exactly the same, just that the latter handles syscall parameters.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用了`BPF_KPROBE`宏而不是`BPF_KPROBE_SYSCALL`。意图完全相同，只是后者处理系统调用参数。
- en: 'There is another important difference: the `pathname` parameter to the syscall
    is a pointer to a string `(char *)`, but for this function the parameter is called
    `filename`, and it’s a pointer to a `struct filename`, which is a data structure
    used within the kernel.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个重要的区别是系统调用的`pathname`参数是一个指向字符串的指针`(char *)`，但对于这个函数，该参数称为`filename`，它是指向内核中使用的数据结构`struct
    filename`的指针。
- en: 'You might well be wondering how I knew to use this type for this parameter.
    I’ll show you. The `do_execve()` function in the kernel has the following signature:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我是如何知道要为这个参数使用这种类型的。我会给你看。内核中的`do_execve()`函数具有以下签名：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I chose to ignore the `do_execve()` parameters `__argv` and `__envp`, and only
    declare the `filename` argument, using the type `struct filename *` to match the
    kernel function’s definition. Given the way arguments are laid out sequentially
    in memory, it’s OK to ignore the last *n* parameters, but you can’t ignore an
    earlier argument in the list if you want to use a later one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择忽略`do_execve()`的参数`__argv`和`__envp`，仅声明`filename`参数，使用类型`struct filename
    *`以匹配内核函数的定义。鉴于参数按顺序排列在内存中的方式，忽略最后的*n*个参数是可以的，但如果要使用后面的参数，则不能忽略列表中较早的参数。
- en: 'This `filename` structure is defined internal to the kernel, and it’s an illustration
    of how eBPF programming is kernel programming: I had to look up the definition
    of `do_execve()` to find its arguments, and the definition of `struct filename`.
    The name of the executable that is about to be run is pointed to by `filename->name`.
    I’m retrieving this name in the example code with the following lines:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`filename`结构在内核内部定义，这说明了eBPF编程是内核编程的一部分：我不得不查找`do_execve()`的定义以找到其参数的定义，以及`struct
    filename`的定义。即将运行的可执行文件的名称由`filename->name`指向。在示例代码中，我使用以下代码行检索此名称：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So to recap: the context parameter to a syscall kprobe is a structure representing
    the values passed by user space into the syscall. The context parameter to a “regular”
    (nonsyscall) kprobe is a structure representing the parameters passed to the called
    function by whatever kernel code is calling it, so the structure depends on the
    function definition.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下：系统调用kprobe的上下文参数是一个表示用户空间传递给系统调用的值的结构体。“常规”（非系统调用）kprobe的上下文参数是一个表示由调用它的内核代码传递给被调用函数的参数的结构体，因此结构体取决于函数定义。
- en: Kretprobes are very similar to kprobes, except that they are triggered when
    a function returns and can access the return value instead of the arguments.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kretprobes与kprobes非常相似，不同之处在于它们在函数返回时触发，并且可以访问返回值而不是参数。
- en: Kprobes and kretprobes are a reasonable way to hook into kernel functions, but
    there’s a newer option you should consider if you’re running on recent kernels.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行在最新内核上，那么kprobes和kretprobes是连接到内核函数的合理方式，但是如果您要考虑的是较新的选项，则有一个新的选项。
- en: Fentry/Fexit
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fentry/Fexit
- en: A more efficient mechanism for tracing the entry to and exit from kernel functions
    was introduced along with the idea of *BPF trampoline* in kernel version 5.5 (on
    x86 processors; BPF trampoline support doesn’t arrive for [ARM processors until
    Linux 6.0](https://oreil.ly/ccuz1)). If you’re using a recent enough kernel, fentry/fexit
    is now the preferred method for tracing the entry to or exit from a kernel function.
    You can write the same code inside a kprobe or fentry type program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核版本5.5引入了一种更高效的机制，用于跟踪进入和退出内核函数的想法与*x86处理器上的BPF跳板*一起引入（ARM处理器上的BPF跳板支持直到Linux
    6.0才到来）。如果您使用的是足够新的内核，fentry/fexit现在是跟踪内核函数进入或退出的首选方法。您可以在kprobe或fentry类型程序中编写相同的代码。
- en: 'There’s an example fentry program called `fentry_execve()` in *chapter7/hello.bpf.c*.
    I declared the eBPF program for this kprobe using *libbpf*’s macro `BPF_PROG`,
    which is another convenient wrapper giving access to typed parameters rather than
    the generic context pointer, but this version is used for fentry, fexit, and tracepoint
    program types. The definition looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在*chapter7/hello.bpf.c*中有一个名为`fentry_execve()`的示例fentry程序。我使用*libbpf*的宏`BPF_PROG`声明了这个kprobe的eBPF程序，这是另一个方便的包装器，提供了对类型化参数的访问，而不是通用的上下文指针，但是此版本用于fentry、fexit和tracepoint程序类型。定义如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The section name tells *libbpf* to attach to the fentry hook at the start of
    the `d⁠o⁠_​e⁠x⁠e⁠c⁠v⁠e⁠(⁠)` kernel function. Just as in the kprobe example, the
    context parameters reflect the parameters passed to the kernel function where
    you want to attach this eBPF program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 部分名称告诉*libbpf*在`d⁠o⁠_​e⁠x⁠e⁠c⁠v⁠e⁠(⁠)`内核函数的开始处附加fentry挂钩。就像kprobe示例中一样，上下文参数反映了您想要附加此eBPF程序的内核函数传递的参数。
- en: 'Fentry and fexit attachment points were designed to be more efficient than
    kprobes, but there’s another advantage when you want to generate an event at the
    end of a function: the fexit hook has access to the input parameters to the function,
    which kretprobe does not. You can see an example of this in [*libbpf-bootstrap*’s
    examples](https://oreil.ly/6HDh_). Both *kprobe.bpf.c* and *fentry.bpf.c* are
    equivalent examples that hook into the `do_unlinkat()` kernel function. The eBPF
    program attached to the kretprobe has the following signature:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Fentry和fexit附加点的设计目的是比kprobes更高效，但是当您想在函数结束时生成事件时，还有另一个优势：fexit挂钩可以访问函数的输入参数，而kretprobe则不能。您可以在[*libbpf-bootstrap*的示例](https://oreil.ly/6HDh_)中看到一个例子。*kprobe.bpf.c*和*fentry.bpf.c*是钩入`do_unlinkat()`内核函数的等效示例。附加到kretprobe的eBPF程序具有以下签名：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `BPF_KRETPROBE` macro expands to make this a kretprobe program on exit
    from `do_unlinkat()`. The only parameter the eBPF program receives is `ret`, which
    holds the return value from `do_unlinkat()`. Compare this to the fexit version:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_KRETPROBE`宏扩展以在从`do_unlinkat()`退出时创建一个kretprobe程序。eBPF程序仅接收`ret`参数，该参数保存了从`do_unlinkat()`返回的值。与fexit版本进行比较：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this version the program gets access not just to the return value `ret`,
    but also to the input parameters to `do_unlinkat()`, which are `dfd` and `name`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，程序不仅可以访问返回值`ret`，还可以访问传递给`do_unlinkat()`的输入参数，这些参数是`dfd`和`name`。
- en: Tracepoints
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tracepoints
- en: '[Tracepoints](https://oreil.ly/yXk_L) are marked locations in the kernel code
    (we’ll come to user space tracepoints later in this chapter). They’re not by any
    means exclusive to eBPF and have long been used to generate kernel trace output
    and by tools like [SystemTap](https://oreil.ly/bLmQL). Unlike attaching to arbitrary
    instructions using kprobes, tracepoints are stable between kernel releases (although
    an older kernel might not have the full set of tracepoints that have been added
    into a newer one).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tracepoints](https://oreil.ly/yXk_L)是内核代码中标记的位置（我们稍后在本章讨论用户空间tracepoints）。它们并不专属于eBPF，并且长期以来已被用于生成内核跟踪输出并被诸如[SystemTap](https://oreil.ly/bLmQL)之类的工具使用。与使用kprobes连接到任意指令不同，tracepoints在内核发布之间是稳定的（尽管旧内核可能没有新增到新内核中的完整tracepoint集）。'
- en: 'You can see the available set of tracing subsystems on your kernel by looking
    at */sys/kernel/tracing/available_events*, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看*/sys/kernel/tracing/available_events*来查看内核上可用的跟踪子系统，如下所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: My 5.15 version of the kernel has more than 1,400 tracepoints defined in this
    list. The section definition for a tracepoint eBPF program should match one of
    these items so that *libbpf* can automatically attach it to the tracepoint. The
    definition is in the form `SEC("tp/tracing subsystem/tracepoint name")`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 5.15 内核版本在此列表中定义了超过 1,400 个追踪点。追踪点 eBPF 程序的部分定义应该匹配其中的一个项目，以便*libbpf*可以自动将其附加到追踪点上。定义的形式为`SEC("tp/tracing
    subsystem/tracepoint name")`。
- en: 'You’ll find an example in the *chapter7/hello.bpf.c*files that matches the
    `syscalls:sys_enter_execve` tracepoint that gets hit when the kernel starts processing
    an `execve()` call. The section definition tells *libbpf* that this is a tracepoint
    program, and where it should be attached, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*chapter7/hello.bpf.c*文件中找到一个示例，匹配`syscalls:sys_enter_execve`追踪点，当内核开始处理`execve()`调用时就会触发。该部分定义告诉*libbpf*这是一个追踪点程序，并且它应该附加在哪里，就像这样：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What about the context parameter to a tracepoint? As I’ll come to shortly,
    BTF can help us here, but first let’s consider what is needed when BTF isn’t available.
    Each tracepoint has a format describing the fields that get traced out from it.
    As an example, here’s the format for the tracepoint at the entry to the `execve()`
    syscall:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 针对追踪点的上下文参数怎么样呢？稍后我将来详细介绍，BTF 可以在这里帮助我们，但首先让我们考虑当 BTF 不可用时需要什么。每个追踪点都有一个格式，描述从中追踪出的字段。举个例子，这是`execve()`系统调用进入时的追踪点格式：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I used this information to define a matching structure called `m⁠y⁠_⁠s⁠y⁠s⁠c⁠a⁠l⁠l⁠s⁠_⁠e⁠n⁠t⁠e⁠r⁠_​e⁠x⁠e⁠c⁠v⁠e`
    in *chapter7/hello.bpf.c*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这些信息在*chapter7/hello.bpf.c*中定义了一个匹配的结构，称为`my_syscalls_enter_execve`：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: eBPF programs aren’t allowed to access the first four of these fields. If you
    try to access them, the program will fail verification with an `invalid bpf_context
    access` error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 程序不允许访问这四个字段中的前四个。如果尝试访问它们，程序将因为`invalid bpf_context access`错误而验证失败。
- en: 'My example eBPF program that attaches to this tracepoint can use a pointer
    to this type as its context parameter, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例 eBPF 程序连接到此追踪点时，可以使用指向此类型的指针作为其上下文参数，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then you can access the contents of this structure. For example, you can get
    the filename pointer as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以访问此结构的内容。例如，您可以获取文件名指针如下：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you use a tracepoint program type, the structure passed to the eBPF program
    has already been mapped from a set of raw arguments. For better performance, you
    can directly access these raw arguments with a raw tracepoint eBPF program type.
    The section definition should start with `raw_tp` (or `raw_tracepoint`) instead
    of `tp`. You’ll need to convert the arguments from `__u64` to whatever type the
    tracepoint structure uses (when the tracepoint is the entry to a system call,
    these arguments are dependent on the chip architecture).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用追踪点程序类型时，传递给 eBPF 程序的结构体已经从一组原始参数映射而来。为了提高性能，您可以直接访问这些原始参数，使用原始追踪点 eBPF
    程序类型。该部分定义应该以`raw_tp`（或`raw_tracepoint`）开头，而不是`tp`。您需要将这些参数从`__u64`转换为追踪点结构体使用的任何类型（当追踪点是系统调用的入口时，这些参数依赖于芯片架构）。
- en: BTF-Enabled Tracepoints
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用了 BTF 的追踪点
- en: In the previous example I wrote a structure called `my_syscalls_enter_execve`
    to define the context parameter for my eBPF program. But when you define a structure
    in your eBPF code or parse the raw arguments, there’s a risk that your code might
    not match the kernel it’s running on. The good news is that BTF, which you met
    in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), also solves this problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我编写了一个名为`my_syscalls_enter_execve`的结构，来定义我的 eBPF 程序的上下文参数。但是，当您在您的 eBPF
    代码中定义一个结构或解析原始参数时，存在代码可能与其运行的内核不匹配的风险。好消息是，您在[第 5 章](ch05.html#co_recomma_btfcomma_and_libbpf)中遇到的
    BTF 也解决了这个问题。
- en: 'With BTF support, there will be a structure defined in *vmlinux.h* that matches
    the context structure passed to a tracepoint eBPF program. Your eBPF program should
    use the section definition `SEC("tp_btf/*tracepoint name*")` where the tracepoint
    name is one of the available events listed in */sys/kernel/tracing/available_events*.
    The example program in *chapter7/hello.bpf.c* looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 BTF 支持时，在*vmlinux.h*中将定义一个与传递给追踪点 eBPF 程序的上下文结构匹配的结构。您的 eBPF 程序应该使用部分定义`SEC("tp_btf/*tracepoint
    name*")`，其中追踪点名称是*sys/kernel/tracing/available_events*中列出的可用事件之一。在*chapter7/hello.bpf.c*中的示例程序如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the structure name matches the tracepoint name, prefixed with
    `trace_event_raw_`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，结构名称与追踪点名称匹配，并且前缀为`trace_event_raw_`。
- en: User Space Attachments
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户空间附件
- en: 'So far I have shown examples of eBPF programs attaching to events defined within
    the kernel’s source code. There are similar attachment points within user space
    code: uprobes and uretprobes for attaching to the entry and exit of user space
    functions, and user statically defined tracepoints (USDTs) for attaching to specified
    tracepoints within application code or user space libraries. These all use the
    `BPF_PROG_TYPE_KPROBE` program type.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示了 eBPF 程序附加到内核源代码中定义的事件的示例。在用户空间代码中也有类似的附加点：uprobes 和 uretprobes 用于附加到用户空间函数的入口和出口，以及用户静态定义的跟踪点（USDTs）用于附加到应用程序代码或用户空间库中指定的跟踪点。所有这些都使用
    `BPF_PROG_TYPE_KPROBE` 程序类型。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are lots of public examples of programs attached to user space events.
    Here are a few from the BCC project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多公开的示例程序附加到用户空间事件。以下是来自 BCC 项目的一些示例：
- en: The [bashreadline](https://oreil.ly/gDkaQ) and [funclatency tools](https://oreil.ly/zLT54)
    attach to u(ret)probe.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bashreadline](https://oreil.ly/gDkaQ) 和 [funclatency 工具](https://oreil.ly/zLT54)
    附加到 `uretprobe`。'
- en: '[USDT sample](https://oreil.ly/o894f) in BCC.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[BCC 中的 USDT 示例](https://oreil.ly/o894f)。'
- en: 'If you’re using *libbpf*, the `SEC()` macro lets you define the auto-attachment
    point for these user space probes. You’ll find the format required for the section
    name in the [*libbpf* documentation](https://oreil.ly/o0CBQ). For example, to
    attach a uprobe to the start of the `SSL_write()` function in OpenSSL, you would
    define the section for the eBPF program with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 *libbpf*，`SEC()` 宏可以让您定义这些用户空间探针的自动附加点。您可以在 [*libbpf* 文档](https://oreil.ly/o0CBQ)
    中找到所需的节名称格式。例如，要将 uprobe 附加到 OpenSSL 中 `SSL_write()` 函数的开头，您需要使用以下定义的 eBPF 程序节：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a few gotchas to be aware of when instrumenting user space code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具化用户空间代码时，需要注意一些要点：
- en: Notice that the path to this shared library in this example is architecture
    specific, so you may need corresponding architecture-specific definitions.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，此示例中共享库的路径是特定于架构的，因此您可能需要相应的架构特定定义。
- en: Unless you control the machine you’re running the code on, you can’t know what
    user space libraries and applications will be installed.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非您控制运行代码的机器，否则无法确定安装了哪些用户空间库和应用程序。
- en: An application might be built as a standalone binary, so it won’t hit any probes
    you might attach within shared libraries.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应用程序可以作为一个独立的二进制文件构建，因此它不会触发你可能在共享库中附加的任何探针。
- en: Containers typically run with their own copy of a filesystem, with their own
    set of dependencies installed in it. The path to a shared library used by a container
    won’t be the same as the path to a shared library on the host machine.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器通常运行在自己的文件系统副本上，并安装了自己的依赖项集。容器使用的共享库路径与主机上的共享库路径不同。
- en: Your eBPF program might need to be aware of the language in which an application
    was written. For example, in C the arguments to a function are generally passed
    using registers, but in Go they are passed using the stack,^([3](ch07.html#ch07fn3))
    so the `pt_args` structure holding register information may be of less use.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的 eBPF 程序可能需要了解应用程序的编程语言。例如，在 C 中，函数的参数通常使用寄存器传递，但在 Go 中则使用堆栈，^([3](ch07.html#ch07fn3))
    因此保存寄存器信息的 `pt_args` 结构可能不太有用。
- en: That said, there are lots of useful tools that instrument user space applications
    with eBPF. For example, you can hook into the SSL library to trace out decrypted
    versions of encrypted information—we’ll explore this in more detail in the next
    chapter. Another example is continuous profiling of your applications, using tools
    such as [Parca](https://www.parca.dev).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有许多有用的工具可以使用 eBPF 为用户空间应用程序进行工具化。例如，您可以钩入 SSL 库以跟踪加密信息的解密版本 —— 我们将在下一章节详细探讨这一点。另一个例子是连续分析您的应用程序，使用诸如
    [Parca](https://www.parca.dev) 等工具。
- en: LSM
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LSM
- en: '`BPF_PROG_TYPE_LSM` programs are attached to the *Linux Security Module (LSM)
    API*, which is a stable interface within the kernel originally intended for kernel
    modules to use to enforce security policies. As you’ll see in [Chapter 9](ch09.html#ebpf_for_security),
    where I’ll discuss this in more detail, eBPF security tooling can now use this
    interface too.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG_TYPE_LSM` 程序附加到 *Linux Security Module (LSM) API*，这是内核中的一个稳定接口，最初用于内核模块以强制执行安全策略。正如您将在
    [第9章](ch09.html#ebpf_for_security) 中详细讨论的那样，现在 eBPF 安全工具也可以使用这个接口。'
- en: '`BPF_PROG_TYPE_LSM` programs are attached using `bpf(BPF_RAW_TRACEPOINT_OPEN)`,
    and in many ways they are treated like tracing programs. One interesting characteristic
    of `BPF_PROG_TYPE_LSM` programs is that the return value affects the way the kernel
    behaves. A nonzero return code indicates that the security check wasn’t passed,
    so the kernel won’t proceed with whatever operation it was asked to complete.
    This is a significant difference from perf-related program types where the return
    code is ignored.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG_TYPE_LSM` 程序通过 `bpf(BPF_RAW_TRACEPOINT_OPEN)` 进行挂载，并且在很多方面它们被视为跟踪程序。`BPF_PROG_TYPE_LSM`
    程序的一个有趣特性是返回值会影响内核的行为方式。非零的返回码表示安全检查未通过，因此内核不会继续完成所请求的操作。这与与性能相关的程序类型有显著不同，后者会忽略返回码。'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux kernel documentation covers [LSM BPF programs](https://oreil.ly/vcPHY).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核文档涵盖[LSM BPF 程序](https://oreil.ly/vcPHY)。
- en: The LSM program type isn’t the only one with a role to play in security. Many
    of the networking-related program types that you’ll see in the next section can
    be used for network security to permit or deny networking traffic or networking-related
    operations. You’ll also see more about eBPF being used for security purposes in
    [Chapter 9](ch09.html#ebpf_for_security).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: LSM 程序类型并非在安全性方面扮演的唯一角色。您将在下一节中看到许多与网络相关的程序类型，这些程序类型可以用于网络安全，允许或拒绝网络流量或与网络相关的操作。在[第 9
    章](ch09.html#ebpf_for_security)中，您还将看到更多关于 eBPF 用于安全目的的内容。
- en: So far in this chapter you have seen how a set of kernel and user space tracing
    program types enable visibility over the whole system. The next set of eBPF program
    types to consider are those that let us hook into the network stack, with the
    option not merely to observe but also to affect how it handles data being sent
    and received.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，您已经看到了一组内核和用户空间跟踪程序类型，它们能够实现对整个系统的可见性。接下来要考虑的一组 eBPF 程序类型是让我们能够钩入网络堆栈的程序类型，不仅可以观察数据的传输，还可以影响内核处理发送和接收数据的方式。
- en: Networking
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: There are lots of different eBPF program types intended to process network messages
    as they pass through various points in the network stack. [Figure 7-1](#bpf_program_types_hook_into_various_poi)
    shows where some of the commonly used program types attach. These program types
    all require `CAP_NET_ADMIN` and `CAP_BPF`, or `CAP_SYS_ADMIN`, capabilities to
    be permitted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的 eBPF 程序类型，旨在处理网络消息，当它们通过网络堆栈中的各个点时。[图 7-1](#bpf_program_types_hook_into_various_poi)
    展示了一些常用程序类型的挂载点。所有这些程序类型都需要 `CAP_NET_ADMIN` 和 `CAP_BPF`，或者 `CAP_SYS_ADMIN` 权限才能允许。
- en: The context passed to these types of programs is the network message in question,
    although the type of structure depends on the data the kernel has at the relevant
    point in the network stack. At the bottom of the stack, data is held in the form
    of Layer 2 network packets, which are essentially a series of bytes that have
    been or are ready to be transmitted “on the wire.” At the top of the stack, applications
    use sockets, and the kernel creates socket buffers to handle data being sent and
    received from these sockets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给这些程序类型的上下文是相关网络消息，尽管结构类型取决于内核在网络堆栈相关点处的数据。在堆栈底部，数据以 Layer 2 网络数据包的形式保存，这些数据包基本上是一系列即将或已经准备好通过“电线”传输的字节。在堆栈顶部，应用程序使用套接字，并且内核创建套接字缓冲区来处理从这些套接字发送和接收的数据。
- en: '![BPF program types hook into various points in the network stack](assets/lebp_0701.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![BPF 程序类型钩入网络堆栈中的各个点](assets/lebp_0701.png)'
- en: Figure 7-1\. BPF program types hook into various points in the network stack
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. BPF 程序类型钩入网络堆栈中的各个点
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The network layer model is beyond the scope of this book, but it’s covered in
    many other books, posts, and training courses. I discussed it in [Chapter 10](ch10.html#ebpf_programming)
    of [*Container Security*](https://www.oreilly.com/library/view/container-security/9781492056690/)
    (O’Reilly). For the purposes of this book, it’s sufficient to know that Layer
    7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC;
    TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2\. One
    of the roles of the networking stack is to convert messages between these different
    formats.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层模型超出了本书的范围，但它在许多其他书籍、文章和培训课程中有所涵盖。我在[*Container Security*](https://www.oreilly.com/library/view/container-security/9781492056690/)（O’Reilly）的[第 10
    章](ch10.html#ebpf_programming)中讨论过它。对于本书的目的，知道 Layer 7 涵盖供应用程序使用的格式，如 HTTP、DNS
    或 gRPC；TCP 位于 Layer 4；IP 位于 Layer 3；以太网和 WiFi 位于 Layer 2 是足够的。网络堆栈的一个作用是在这些不同格式之间转换消息。
- en: 'One big difference between the networking program types and the tracing-related
    types you saw earlier in this chapter is that they are generally intended to allow
    for the customization of networking behaviors. That involves two main characteristics:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 网络程序类型与本章前面讨论的跟踪相关类型之间的一个重要区别在于，它们通常旨在允许定制网络行为。这涉及两个主要特点：
- en: Using a return code from the eBPF program to tell the kernel what to do with
    a network packet—which could involve processing it as usual, dropping it, or redirecting
    it to a different destination
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用eBPF程序的返回代码告知内核如何处理网络数据包——这可能包括像往常一样处理、丢弃或重定向到不同的目的地。
- en: Allowing the eBPF program to modify network packets, socket configuration parameters,
    and so on
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许eBPF程序修改网络数据包、套接字配置参数等等
- en: You’ll see some examples of how these characteristics are used to build powerful
    networking capabilities in the next chapter, but for now, here’s an overview of
    the eBPF program types.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章看到这些特征如何用于构建强大的网络功能的一些示例，但现在，这里是eBPF程序类型的概述。
- en: Sockets
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字
- en: 'At the top of the stack, a subset of these network-related program types relates
    to sockets and socket operations:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈的顶部，一部分与套接字及套接字操作相关的网络程序类型：
- en: '`BPF_PROG_TYPE_SOCKET_FILTER` was the first program type to be added to the
    kernel. You probably guessed from the name that this is used for socket filtering,
    but what’s less obvious is that this doesn’t mean filtering data being sent to
    or from an application. It’s used to filter a *copy* of socket data that can be
    sent to an observability tool such as tcpdump.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BPF_PROG_TYPE_SOCKET_FILTER`是添加到内核中的第一个程序类型。你可能从名称中猜到了它用于套接字过滤，但不那么明显的是，这并不意味着过滤应用程序发送或接收的数据。它用于过滤可以发送到像tcpdump这样的观测工具的套接字数据的*副本*。'
- en: A socket is specific to a Layer 4 (TCP) connection. `BPF_PROG_TYPE_SOCK_OPS`
    allows eBPF programs to intercept various operations and actions that take place
    on a socket, and to set for that socket parameters such as TCP timeout values.
    Sockets only exist at the endpoints for a connection, and not on any middleboxes
    that they might pass through.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字是特定于第4层（TCP）连接的。`BPF_PROG_TYPE_SOCK_OPS`允许eBPF程序拦截发生在套接字上的各种操作和动作，并为该套接字设置参数，如TCP超时值。套接字仅存在于连接的端点上，而不在它们可能经过的任何中间盒上。
- en: '`BPF_PROG_TYPE_SK_SKB` programs are used in conjunction with a special map
    type that holds a set of references to sockets to provide what’s known as [*sockmap*
    operations](https://oreil.ly/0Enuo): redirecting traffic to different destinations
    at the socket layer.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BPF_PROG_TYPE_SK_SKB`程序与一种特殊的映射类型结合使用，该映射类型保存了一组引用套接字，以提供所谓的[*sockmap*操作](https://oreil.ly/0Enuo)：将流量重定向到套接字层的不同目的地。'
- en: Traffic Control
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量控制
- en: Further down the network stack comes “TC” or traffic control. There is a whole
    subsystem in the Linux kernel related to TC, and a glance at the [manpage for
    the `tc` command](https://oreil.ly/kfyg5) will give you an idea of how complex
    it is and how important it is to computing in general to have deep levels of flexibility
    and configuration over the way network packets are handled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络栈的更深层次是“TC”或流量控制。Linux内核中有一个与TC相关的完整子系统，查看[‘tc’命令的man页面](https://oreil.ly/kfyg5)将让你了解其复杂性以及在计算中拥有深层灵活性和配置方式的重要性。
- en: eBPF programs can be attached to provide custom filters and classifiers for
    network packets for both ingress and egress traffic. This is one of the building
    blocks of the Cilium project, and I’ll cover some examples in the next chapter.
    If you can’t wait until then, there are some good examples on [Quentin Monnet’s
    blog](https://oreil.ly/heQ2D). This can be done programmatically, but you also
    have the option to use the `tc` command to manipulate these kinds of eBPF programs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序可以附加以为网络数据包提供自定义过滤器和分类器，用于入口和出口流量。这是Cilium项目的构建块之一，我将在下一章节中介绍一些示例。如果你等不及，可以在[Quentin
    Monnet的博客](https://oreil.ly/heQ2D)上找到一些很好的例子。这可以通过编程方式实现，但你也可以选择使用`tc`命令来操作这些类型的eBPF程序。
- en: XDP
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XDP
- en: 'You briefly met XDP (eXpress Data Path) eBPF programs in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    In that example I loaded the eBPF program and attached it to the `eth0` interface
    using the following commands:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html#anatomy_of_an_ebpf_program)中简要介绍了XDP（eXpress数据路径）eBPF程序。在那个例子中，我加载了eBPF程序，并使用以下命令将其附加到`eth0`接口：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s worth noting that XDP programs attach to a specific interface (or virtual
    interface), and you may very well have different XDP programs attached to different
    interfaces. In [Chapter 8](ch08.html#ebpf_for_networking) you’ll learn more about
    how XDP programs can be offloaded to network cards or executed by network drivers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，XDP 程序附加到特定的接口（或虚拟接口），您很可能会在不同的接口上附加不同的 XDP 程序。在[第 8 章](ch08.html#ebpf_for_networking)中，您将更多地了解
    XDP 程序如何被卸载到网络卡或由网络驱动程序执行的内容。
- en: 'XDP programs are another example of programs that can be managed using Linux
    network utilities—in this case, the `link` subcommand of [iproute2’s ip](https://oreil.ly/8Isau).
    The roughly equivalent command for loading and attaching the program to `eth0`
    would be this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: XDP 程序是可以使用 Linux 网络实用程序管理的另一个示例—在这种情况下，使用[iproute2 的 ip 的 link 子命令](https://oreil.ly/8Isau)。加载并附加程序到
    `eth0` 的大致等效命令如下：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command reads the eBPF program marked as section `xdp` from the `hello.bpf.o`
    object and attaches it to the `eth0` network interface. The `ip link show` command
    for this interface now includes some information about the XDP program that’s
    attached to it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从 `hello.bpf.o` 对象读取标记为 `xdp` 部分的 eBPF 程序，并将其附加到 `eth0` 网络接口。此接口的 `ip link
    show` 命令现在包含有关附加到其上的 XDP 程序的一些信息：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Removing the XDP program with `ip link` can be done like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ip link` 删除 XDP 程序可以像这样进行：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll see a lot more about XDP programs and their applications in the next
    chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，您将看到更多关于 XDP 程序及其应用的内容。
- en: Flow Dissector
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流分析器
- en: A flow dissector is used at various points in the network stack to extract details
    from a packet’s headers. eBPF programs of type `BPF_PROG_TYPE_FLOW_DISSECTOR`
    can implement custom packet dissection. There’s a nice write-up in this LWN article
    on [writing network flow dissectors in BPF](https://oreil.ly/nFKLV).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 流分析器在网络堆栈的各个点上用于从数据包头部提取详细信息。类型为 `BPF_PROG_TYPE_FLOW_DISSECTOR` 的 eBPF 程序可以实现自定义数据包解析。在这篇
    LWN 文章中有一篇关于[使用 BPF 编写网络流分析器](https://oreil.ly/nFKLV)的详细介绍。
- en: Lightweight Tunnels
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量级隧道
- en: The family of `BPF_PROG_TYPE_LWT_*` program types can be used to implement network
    encapsulation in eBPF programs. These program types can also be manipulated using
    the `ip` command, but this time it’s the `route` subcommand that’s involved. In
    practice, these are used infrequently.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG_TYPE_LWT_*` 程序类型系列可用于在 eBPF 程序中实现网络封装。这些程序类型也可以使用 `ip` 命令进行操作，但这次是涉及到
    `route` 子命令。在实践中，这些用法并不常见。'
- en: Cgroups
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cgroups
- en: eBPF programs can be attached to cgroups (short for “control groups”). *Cgroups*
    are a concept in the Linux kernel that restricts the set of resources a given
    process or group of processes can have access to. Cgroups are one of the mechanisms
    that isolate one container (or one Kubernetes pod) from another. Attaching eBPF
    programs to a cgroup allows for custom behavior that only applies to that cgroup’s
    processes. All processes are associated with a cgroup, including processes that
    are not running inside a container.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 程序可以附加到 cgroups（即“控制组”）。*Cgroups* 是 Linux 内核中的一个概念，它限制了给定进程或一组进程可以访问的资源集。Cgroups
    是隔离一个容器（或一个 Kubernetes Pod）与另一个容器之间的机制之一。将 eBPF 程序附加到 cgroup 允许对该 cgroup 的进程应用仅适用于其自身的自定义行为。所有进程都与一个
    cgroup 相关联，包括没有运行在容器内的进程。
- en: There are several cgroup-related program types, and even more hooks where they
    can be attached. At least at the time of this writing, they are nearly all networking
    related, although there is also a `BPF_CGROUP_SYSCTL` program type that can be
    attached to sysctl commands affecting a particular cgroup.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种与 cgroup 相关的程序类型，以及更多它们可以附加的钩子。至少在撰写本文时，它们几乎全部与网络相关，尽管也有一个 `BPF_CGROUP_SYSCTL`
    程序类型，可以附加到影响特定 cgroup 的 sysctl 命令上。
- en: As an example, there are socket-related program types specific to cgroups `BPF_PROG_TYPE_CGROUP_SOCK`
    and `BPF_PROG_TYPE_CGROUP_SKB`. eBPF programs can determine whether a given cgroup
    is permitted to perform a requested socket operation or data transmission. This
    is useful for network security policy enforcement (which I’ll cover in the next
    chapter). Socket programs can also trick the calling process into thinking they
    are connecting to a particular destination address.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与 cgroups 特定的与套接字相关的程序类型有关 `BPF_PROG_TYPE_CGROUP_SOCK` 和 `BPF_PROG_TYPE_CGROUP_SKB`。eBPF
    程序可以确定特定 cgroup 是否被允许执行请求的套接字操作或数据传输。这对于网络安全策略执行（将在下一章节中介绍）非常有用。套接字程序还可以欺骗调用进程，使其认为它们正在连接到特定的目标地址。
- en: Infrared Controllers
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红外控制器
- en: Programs of type [BPF_PROG_TYPE_LIRC_MODE2](https://oreil.ly/AwG1C) can be attached
    to the file descriptor for an infrared controller device to provide decoding for
    infrared protocols. At the time of this writing, this program type requires `CAP_NET_ADMIN`,
    but I think this illustrates that the division of program types into tracing related
    and networking related doesn’t fully express the range of different applications
    that eBPF can address.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 [BPF_PROG_TYPE_LIRC_MODE2](https://oreil.ly/AwG1C) 的程序可以附加到红外控制器设备的文件描述符上，提供红外协议的解码。在撰写本文时，此程序类型需要
    `CAP_NET_ADMIN`，但我认为这说明了将程序类型分为跟踪相关和网络相关并不能完全表达 eBPF 可以解决的不同应用范围。
- en: BPF Attachment Types
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF 附加类型
- en: The attachment type offers more fine-grained control over where a program can
    be attached in the system. For some program types there is a one-to-one correlation
    to the type of hook that it can be attached to, so the attachment type is implicitly
    defined by the program type. For example, XDP programs are attached to XDP hooks
    in the network stack. For a few program types, an attachment type also has to
    be specified.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 附加类型为程序在系统中附加位置提供了更精细的控制。对于某些程序类型，其与可以附加的挂接类型有一对一的关系，因此附加类型由程序类型隐含定义。例如，XDP
    程序附加到网络堆栈中的 XDP 挂接点。对于少数程序类型，还必须指定附加类型。
- en: The attachment type is involved in deciding which helper functions are valid,
    and it also restricts access to parts of the context information in some cases.
    There was an example of this earlier in this chapter where the verifier gives
    an `invalid bpf_context access` error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 附加类型涉及决定哪些辅助函数是有效的，它还在某些情况下限制对上下文信息的访问。本章早些时候有一个例子，在该例子中，验证器给出了 `invalid bpf_context
    access` 错误。
- en: You can also see which program types need an attachment type to be specified,
    and which attachment types are valid, in the kernel function [bpf_prog_load_check_attach](https://oreil.ly/0LqCQ)
    (defined in [*bpf/syscall.c*](https://oreil.ly/7OrYS)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在内核函数 [bpf_prog_load_check_attach](https://oreil.ly/0LqCQ)（定义在 [*bpf/syscall.c*](https://oreil.ly/7OrYS)
    中）中看到需要指定附加类型的程序类型，以及哪些附加类型是有效的。
- en: 'For example, here is the code that checks the attachment type for a program
    of type `CGROUP_SOCK`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是检查 `CGROUP_SOCK` 程序附加类型的代码：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This program type can be attached in multiple places: at socket creation, at
    socket release, or after a bind is completed in IPv4 or IPv6.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序类型可以附加在多个位置：在套接字创建时、在套接字释放时或在完成 IPv4 或 IPv6 中的绑定后。
- en: Another place to find a listing of the valid attachment types for programs is
    the [*libbpf* documentation](https://oreil.ly/jraLh), where you’ll also find the
    section names that *libbpf* understands for each program and attachment type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个查找程序有效附加类型列表的地方是 [*libbpf* 文档](https://oreil.ly/jraLh)，你还将找到 *libbpf* 为每个程序和附加类型理解的章节名称。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you saw that various eBPF program types are used to attach into
    different hook points in the kernel. If you want to write code that responds to
    a particular event, you’ll need to determine the program type(s) that are appropriate
    for hooking onto that event. The context passed into the program depends on the
    program type, and the kernel may also respond differently to the return code from
    your program, depending on its type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到各种 eBPF 程序类型被用于附加到内核中的不同挂接点。如果你想编写响应特定事件的代码，你需要确定适合挂接到该事件的程序类型。传递到程序中的上下文取决于程序类型，而内核对程序的返回码也可能因其类型不同而有不同的响应。
- en: The example code for this chapter mostly focused on perf-related (tracing) events.
    In the next two chapters you’ll see more details on different eBPF program types
    used for networking and security applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码大多集中在与性能相关的（跟踪）事件上。在接下来的两章中，你将看到更多关于用于网络和安全应用的不同 eBPF 程序类型的详细信息。
- en: Exercises
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The example code for this chapter includes kprobe, fentry, tracepoint, raw tracepoint,
    and BTF-enabled tracepoint programs that are all attached to the entry to the
    same system call. As you know, eBPF tracing programs can be attached to many other
    places besides syscalls.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码包括 kprobe、fentry、tracepoint、raw tracepoint 和 BTF-enabled tracepoint 程序，它们都附加到相同系统调用的入口。正如你所知，eBPF
    跟踪程序除了系统调用之外还可以附加到许多其他位置。
- en: 'Run the example code using `strace` to capture the `bpf()` system calls, like
    this:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例代码时，使用 `strace` 来捕获 `bpf()` 系统调用，如下所示：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will record information about each `bpf()` syscall into a file called *outfile*.
    Look for the `BPF_PROG_LOAD` instructions in that file, and see how the `prog_type`
    file varies for different programs. You can identify which program is which by
    the `prog_name` field in the trace, and match them to the source code in *chapter7/hello.bpf.c*.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将记录每个 `bpf()` 系统调用的信息到名为 *outfile* 的文件中。查找文件中的 `BPF_PROG_LOAD` 指令，并查看 `prog_type`
    文件在不同程序中的变化。您可以通过跟踪中的 `prog_name` 字段识别每个程序，并将其与 *chapter7/hello.bpf.c* 中的源代码匹配。
- en: The example user space code in *hello.c* loads all the program objects defined
    in `hello.bpf.o`. As an exercise in writing *libbpf* user space code, modify the
    example code load and attach just one of the eBPF programs (pick whichever one
    you like), without removing those programs from *hello.bpf.c*.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*hello.c* 中的示例用户空间代码加载了 `hello.bpf.o` 中定义的所有程序对象。作为编写 *libbpf* 用户空间代码的练习，修改示例代码以加载并附加一个
    eBPF 程序（选择您喜欢的任何一个），而不从 *hello.bpf.c* 中删除这些程序。'
- en: Write a kprobe and/or fentry program that is triggered when some other kernel
    function is called. You can find the available functions in your kernel version
    by looking at */proc/kallsyms*.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 kprobe 和/或 fentry 程序，当调用其他内核函数时触发。您可以通过查看 */proc/kallsyms* 来找到您内核版本中可用的函数。
- en: Write a regular, raw or BTF-enabled tracepoint program that attaches to some
    other kernel tracepoint. You can find the available tracepoints in `/sys/kernel/tracing/available_events`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个常规、原始或启用了 BTF 的 tracepoint 程序，附加到其他内核 tracepoint 上。您可以在 `/sys/kernel/tracing/available_events`
    中找到可用的 tracepoint。
- en: 'Try to attach more than one XDP program to a given interface, and confirm that
    you can’t! You should see an error that looks something like this:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将多个 XDP 程序附加到给定接口，并确认您无法这样做！您应该看到类似以下错误：
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ^([1](ch07.html#ch07fn1-marker)) Except for a few parts of the kernel where
    kprobes aren’t permitted for security reasons. These are listed in `/sys/kernel/debug/kprobes/blacklist`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#ch07fn1-marker)) 除了出于安全原因，在某些内核部分 kprobe 不被允许。这些列在 `/sys/kernel/debug/kprobes/blacklist`
    中。
- en: ^([2](ch07.html#ch07fn2-marker)) The only example I have seen so far is in the
    [cilium/ebpf test suite](https://oreil.ly/rL5E8).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#ch07fn2-marker)) 我迄今为止看到的唯一示例是在 [cilium/ebpf 测试套件](https://oreil.ly/rL5E8)
    中。
- en: ^([3](ch07.html#ch07fn3-marker)) Up to Go version 1.17, when a new register-based
    calling convention was introduced. Nevertheless, I think there will be Go executables
    built with older versions circulating for some time to come.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#ch07fn3-marker)) 直到 Go 版本 1.17，引入了新的基于寄存器的调用约定。尽管如此，我认为还将有使用旧版本构建的
    Go 可执行文件在未来一段时间内继续流通。
