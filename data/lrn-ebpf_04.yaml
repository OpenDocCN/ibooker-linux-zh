- en: Chapter 4\. The bpf() System Call
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章\. `bpf()`系统调用
- en: As you saw in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    when user space applications want the kernel to do something on their behalf,
    they make requests using the system call API. It therefore makes sense that if
    a user space application wants to load an eBPF program into the kernel, there
    must be some system calls involved. In fact, there’s a system call named `bpf()`,
    and in this chapter I’ll show you how it’s used to load and interact with eBPF
    programs and maps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](ch01.html#what_is_ebpf_and_why_is_it_importantque)中看到的，当用户空间应用程序希望内核代表它们执行某些操作时，它们使用系统调用API发出请求。因此，如果用户空间应用程序希望将eBPF程序加载到内核中，必须涉及一些系统调用。实际上，有一个名为`bpf()`的系统调用，在本章中我将向您展示如何使用它来加载和与eBPF程序和映射交互。
- en: It’s worth noting that the eBPF code running in the kernel does not use syscalls
    to access maps. The syscall interface is only used by user space applications.
    Instead, eBPF programs use helper functions to read and write to maps; you already
    saw examples of this in the previous two chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，运行在内核中的eBPF代码不使用系统调用来访问映射。系统调用接口仅由用户空间应用程序使用。相反，eBPF程序使用辅助函数来读取和写入映射；您已经在前两章中看到了这方面的示例。
- en: If you go on to write eBPF programs yourself, there’s a good chance you won’t
    directly call these `bpf()` system calls yourself. There are libraries that I’ll
    discuss later in the book that offer higher-level abstractions to make things
    easier. That said, those abstractions generally map pretty directly to the underlying
    syscall commands you’ll see in this chapter. Whatever library you’re using, you’ll
    need a grasp of the underlying operations—loading a program, creating and accessing
    maps, and so on—that you’ll see in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您继续编写自己的eBPF程序，有很大的机会您不会直接调用这些`bpf()`系统调用。本书后面将讨论提供更高级抽象以简化操作的库。尽管如此，这些抽象通常相当直接地映射到您将在本章中看到的底层系统调用命令。无论使用哪种库，您都需要掌握底层操作——加载程序、创建和访问映射等——这些操作将在本章中看到。
- en: 'Before I show you examples of `bpf()` system calls, let’s consider what the
    [manpage for `bpf()` says](https://oreil.ly/NJdIM), which is that `bpf()` is used
    to “perform a command on an extended BPF map or program.” It also tells us that
    `bpf()`’s signature is as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向您展示`bpf()`系统调用示例之前，让我们考虑一下[`bpf()`的man页面中写着](https://oreil.ly/NJdIM)，`bpf()`用于“在扩展BPF映射或程序上执行命令”。它还告诉我们，`bpf()`的签名如下：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first argument to `bpf()`, `cmd`, specifies which command to perform. The
    `bpf()` syscall doesn’t just do one thing—there are lots of different commands
    that can be used to manipulate eBPF programs and maps. [Figure 4-1](#a_userspace_program_interacts_with_ebpf)
    shows an overview of some of the common commands the user space code might use
    to load eBPF programs, create maps, attach programs to events, and access the
    key–value pairs in a map.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpf()`的第一个参数`cmd`指定要执行的命令。`bpf()`系统调用不只是做一件事情——有很多不同的命令可以用来操作eBPF程序和映射。[图 4-1](#a_userspace_program_interacts_with_ebpf)展示了用户空间代码可能用来加载eBPF程序、创建映射、将程序附加到事件以及访问映射中键值对的一些常见命令概述。'
- en: '![A user space program interacts with eBPF programs and maps in the kernel
    using syscalls](assets/lebp_0401.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![用户空间程序通过系统调用与内核中的eBPF程序和映射交互](assets/lebp_0401.png)'
- en: Figure 4-1\. A userspace program interacts with eBPF programs and maps in the
    kernel using syscalls
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 用户空间程序通过系统调用与内核中的eBPF程序和映射交互
- en: The `attr` argument to the `bpf()` syscall holds whatever data is needed to
    specify the parameters for the command, and `size` indicates how many bytes of
    data there are in `attr`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpf()`系统调用的`attr`参数包含用于指定命令参数的任何数据，`size`指示`attr`中有多少字节的数据。'
- en: You already met `strace` in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    when I used it to show how user space code makes many requests across the syscall
    API. In this chapter I’ll use it to demonstrate how the `bpf()` syscall is used.
    The output from `strace` includes the arguments to each syscall, but to keep the
    example output in this chapter from being too cluttered, I’ll omit lots of the
    details from the `attr` arguments unless they are particularly interesting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在[第1章](ch01.html#what_is_ebpf_and_why_is_it_importantque)中遇到了`strace`，我在那里使用它来展示用户空间代码如何通过系统调用API发出许多请求。在本章中，我将使用它来演示如何使用`bpf()`系统调用。`strace`的输出包括每个系统调用的参数，但为了保持本章中示例输出的简洁性，我将省略`attr`参数的许多细节，除非它们特别有趣。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the code, along with instructions for setting up an environment
    to run it in, at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter4* directory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)找到代码，以及设置运行环境的说明。本章的代码位于
    *chapter4* 目录中。
- en: For this example I’m going to use a BCC program called *hello-buffer-config.py*,
    which builds on the examples you saw in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    Like the *hello-buffer.py* example, this program sends a message to the perf buffer
    whenever it runs, conveying information from the kernel to user space about `execve()`
    syscall events. What’s new in this version is that it allows for different messages
    to be configured for each user ID.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我将使用一个名为 *hello-buffer-config.py* 的 BCC 程序，它构建在您在[第 2 章](ch02.html#ebpfapostrophes_quotation_markhello_wor)看到的示例基础之上。与
    *hello-buffer.py* 示例类似，此程序在每次运行时都将消息发送到性能缓冲区，从内核向用户空间传递有关 `execve()` 系统调用事件的信息。这个版本的新功能是允许为每个用户
    ID 配置不同的消息。
- en: 'Here’s the eBPF source code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 eBPF 源代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#code_id_4_1)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_4_1)'
- en: This line indicates that there’s a structure definition, `user_msg_t`, for holding
    a 12-character message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此行指示存在一个结构定义 `user_msg_t`，用于保存一个 12 字符消息。
- en: '[![2](assets/2.png)](#code_id_4_2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_4_2)'
- en: The BCC macro `BPF_HASH` is used to define a hash table map called `config`.
    It will hold values of type `user_msg_t`, indexed by keys of type `u32`, which
    is the right size for a user ID. (If you don’t specify the types for the keys
    and values, BCC defaults to `u64` for both.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: BCC 宏 `BPF_HASH` 用于定义一个名为 `config` 的哈希表映射。它将以 `u32` 类型的键索引类型为 `user_msg_t` 的值，这对于用户
    ID 来说是正确大小的。（如果您不指定键和值的类型，BCC 默认为 `u64`）
- en: '[![3](assets/3.png)](#code_id_4_3)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_4_3)'
- en: The perf buffer output is defined in exactly the same way as in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    You can submit arbitrary data to a buffer, so there’s no need to specify any data
    types here…
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 性能缓冲输出的定义方式与[第 2 章](ch02.html#ebpfapostrophes_quotation_markhello_wor)完全相同。您可以向缓冲区提交任意数据，因此这里无需指定任何数据类型…
- en: '[![4](assets/4.png)](#code_id_4_4)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_4_4)'
- en: …although in practice, in this example the program always submits a `data_t`
    structure. This is also unchanged from the [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: …尽管在实践中，在此示例中程序总是提交一个 `data_t` 结构。这与[第 2 章](ch02.html#ebpfapostrophes_quotation_markhello_wor)的示例也没有变化。
- en: '[![5](assets/5.png)](#code_id_4_5)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_4_5)'
- en: Most of the rest of the eBPF program is unchanged from the `hello()` version
    you saw earlier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分 eBPF 程序其余部分与您之前看到的 `hello()` 版本没有变化。
- en: '[![6](assets/6.png)](#code_id_4_6)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_4_6)'
- en: The only difference is that having used a helper function to get the user ID,
    the code looks for an entry in the `config` hash map with that user ID as the
    key. If there is a matching entry, the value contains a message that gets used
    instead of the default “Hello World.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于使用了一个帮助函数来获取用户 ID 后，代码查找 `config` 哈希映射中具有该用户 ID 作为键的条目。如果有匹配的条目，该值包含一个替代默认“Hello
    World”的消息。
- en: 'The Python code has two additional lines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码有两行额外内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These define messages in the `config` hash table for user IDs 0 and 501, which
    correspond to the root user and my user ID on this virtual machine. This code
    uses Python’s `ctypes` package to ensure that the key and value have the same
    types as those used in the C definition of `user_msg_t`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些为 `config` 哈希表中的用户 ID 0 和 501 定义了消息，分别对应于根用户和我在此虚拟机上的用户 ID。此代码使用 Python 的
    `ctypes` 包确保键和值的类型与 `user_msg_t` 的 C 定义中使用的类型相同。
- en: 'Here’s some illustrative output from this example, along with the commands
    I ran in a second terminal to obtain it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个示例的一些说明性输出，以及我在第二个终端中运行的命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you’ve got an idea of what this program does, I’d like to show you
    the `bpf()` system calls that are used when it runs. I’ll run it again using `strace`,
    specifying `-e bpf` to indicate that I am only interested in seeing the `bpf()`
    syscall:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了这个程序的功能，我想展示一下运行时使用的 `bpf()` 系统调用。我将再次使用 `strace` 运行它，并指定 `-e bpf` 表示我只关心看到
    `bpf()` 系统调用：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output you’ll see if you try this yourself shows several calls to this
    syscall. For each, you’ll see the command indicating what the `bpf()` syscall
    should do. The broad outline looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己尝试，你将看到输出中显示了几次对此系统调用的调用。对于每次调用，你将看到指示`bpf()`系统调用应执行什么操作的命令。大致概述如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s examine them one by one. Neither you, the reader, nor I have infinite
    patience, so I won’t discuss every single argument to every single call! I’ll
    focus on the parts that I think really help to tell the story of what’s happening
    when a user space program interacts with an eBPF program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查它们。既然你和我都没有无限耐心，我不会讨论每个调用的每个参数！我将专注于那些我认为真正有助于讲述当用户空间程序与eBPF程序交互时发生了什么的部分。
- en: Loading BTF Data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载BTF数据
- en: 'The first call to `bpf()` that I see looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的第一个`bpf()`调用如下：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case the command you can see in the output is `BPF_BTF_LOAD`. This is
    just one of a set of valid commands that are (at least at the time of this writing)
    most comprehensively documented within the kernel source code.^([1](ch04.html#ch04fn1))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以在输出中看到的命令是`BPF_BTF_LOAD`。这只是一组有效命令中的一个（至少在撰写本文时是如此），这些命令在内核源代码中得到了最全面的文档记录。^([1](ch04.html#ch04fn1))
- en: It’s possible that you won’t see a call with this command if you’re using a
    relatively old Linux kernel, as it relates to BTF, or BPF Type Format.^([2](ch04.html#ch04fn2))
    BTF allows eBPF programs to be portable across different kernel versions so that
    you can compile a program on one machine and use it on another, which might be
    using a different kernel version and hence have different kernel data structures.
    I’ll discuss this in more detail in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是相对较旧的Linux内核，可能不会看到此命令的调用，因为它涉及到BTF或BPF类型格式。^([2](ch04.html#ch04fn2))
    BTF允许eBPF程序在不同的内核版本之间可移植，因此你可以在一台机器上编译程序，然后在另一台机器上使用，即使它使用的是不同的内核版本，因此具有不同的内核数据结构。我将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中详细讨论这个问题。
- en: This call to `bpf()` is loading a blob of BTF data into the kernel, and the
    return code from the `bpf()` system call (`3` in my example) is a file descriptor
    that refers to that data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此次`bpf()`调用正在将一块BTF数据加载到内核中，而`bpf()`系统调用的返回代码（在我的示例中为`3`）是一个文件描述符，指向该数据。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *file descriptor* is an identifier for an open file (or file-like object).
    If you open a file (with the `open()` or `openat()` system call) the return code
    is a file descriptor, which is then passed as an argument to other syscalls such
    as `read()` or `write()` to perform operations on that file. Here the blob of
    data isn’t exactly a file, but it is given a file descriptor as an identifier
    that can be used for future operations that refer to it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件描述符*是打开文件（或类似文件对象）的标识符。如果你使用`open()`或`openat()`系统调用打开一个文件，返回的代码就是文件描述符，然后可以将其作为参数传递给其他系统调用，如`read()`或`write()`，以执行对该文件的操作。这里的数据块并不完全是文件，但它确实获得了文件描述符作为标识符，以便将来引用它时使用。'
- en: Creating Maps
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建映射
- en: 'The next `bpf()` creates the `output` perf buffer map:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`bpf()`创建了`output`性能缓冲映射：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can probably guess from the command name `BPF_MAP_CREATE` that this call
    creates an eBPF map. You can see that the type of this map is `PERF_EVENT_ARRAY`
    and it is called `output`. The keys and values in this perf event map are 4 bytes
    long. There’s also a limit of four key–value pairs that can be held in this map,
    defined by the field `max_entries`; I’ll explain why there are four entries in
    this map later in this chapter. The return value of `4` is the file descriptor
    for the user space code to access the `output` map.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从命令名称`BPF_MAP_CREATE`推测出，此调用创建了一个eBPF映射。你可以看到，这个映射的类型是`PERF_EVENT_ARRAY`，名为`output`。在这个性能事件映射中，键和值都是4字节长。此映射最多可以容纳四对键-值，由`max_entries`字段定义；我稍后会解释为什么这个映射中有四个条目。返回值`4`是用户空间代码访问`output`映射的文件描述符。
- en: 'The next `bpf()` system call in the output creates the `config` map:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的下一个`bpf()`系统调用创建了`config`映射：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This map is defined to be a hash table map, with keys that are 4 bytes long
    (which corresponds to a 32-bit integer that can be used to hold a user ID) and
    values that are 12 bytes long (which matches the length of the `msg_t` structure).
    I didn’t specify the size of the table, so it has been given BCC’s default size
    of 10,240 entries.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此映射被定义为哈希表映射，键长为4字节（对应于可以用于保存用户ID的32位整数），值长为12字节（与`msg_t`结构的长度相匹配）。我没有指定表的大小，因此它使用了BCC的默认大小，即10,240个条目。
- en: This `bpf()` system call also returns a file descriptor, `5`, which will be
    used to refer to this `config` map in future syscalls.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `bpf()` 系统调用也返回一个文件描述符，`5`，它将被用来在未来的系统调用中引用这个 `config` 映射。
- en: You can also see the field `btf_fd=3`, which tells the kernel to use the BTF
    file descriptor `3` that was obtained earlier. As you’ll see in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    BTF information describes the layout of data structures, and including this in
    the definition of the map means there’s information about the layout of the key
    and value types used in this map. This is used by tools like `bpftool` to pretty-print
    map dumps, making them human readable—you saw an example of this in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到 `btf_fd=3` 字段，它告诉内核要使用之前获取的 BTF 文件描述符 `3`。正如你将在[第 5 章](ch05.html#co_recomma_btfcomma_and_libbpf)看到的那样，BTF
    信息描述了数据结构的布局，并且将其包含在映射的定义中意味着关于在该映射中使用的键和值类型布局的信息。这些信息由像 `bpftool` 这样的工具用来打印映射转储，使其更易读——你在[第
    3 章](ch03.html#anatomy_of_an_ebpf_program)中已经看到了一个示例。
- en: Loading a Program
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载程序
- en: 'So far you have seen the example program using syscalls to load BTF data into
    the kernel and create some eBPF maps. The next thing it does is load the eBPF
    program being loaded into the kernel with the following `bpf()` syscall:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了示例程序使用系统调用将 BTF 数据加载到内核并创建了一些 eBPF 映射。接下来要做的是使用以下 `bpf()` 系统调用加载正在加载到内核中的
    eBPF 程序：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Quite a few of the fields here are interesting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些字段非常有趣：
- en: The `prog_type` field describes the program type, which here indicates that
    it’s intended to be attached to a kprobe. You’ll learn more about program types
    in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog_type` 字段描述了程序类型，这里指示它是要附加到 kprobe。你将在[第 7 章](ch07.html#ebpf_program_and_attachment_types)中进一步了解程序类型。'
- en: The `insn_cnt` field means “instruction count.” This is the number of bytecode
    instructions in the program.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insn_cnt` 字段表示“指令计数”。这是程序中的字节码指令数。'
- en: The bytecode instructions that make up this eBPF program are held in memory
    at the address specified in the `insns` field.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组成这个 eBPF 程序的字节码指令保存在 `insns` 字段指定的内存地址中。
- en: This program was specified as GPL licensed so that it can use GPL-licensed BPF
    helper functions.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此程序被指定为 GPL 许可，因此它可以使用 GPL 许可的 BPF 辅助函数。
- en: The program name is `hello`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序名称是 `hello`。
- en: The `expected_attach_type` of `BPF_CGROUP_INET_INGRESS` might seem surprising,
    because that sounds like something to do with ingress network traffic, but you
    know this eBPF program is going to be attached to a kprobe. In fact, the `expected_attach_type`
    field is only used for some program types, and `BPF_PROG_TYPE_KPROBE` isn’t one
    of them. `BPF_CGROUP_INET_INGRESS` just happens to be the first in the list of
    BPF attachment types,^([3](ch04.html#ch04fn3)) so it has the value `0`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expected_attach_type` 是 `BPF_CGROUP_INET_INGRESS`，这可能听起来令人惊讶，因为它听起来与入口网络流量有关，但你知道这个
    eBPF 程序将要附加到一个 kprobe 上。实际上，`expected_attach_type` 字段仅用于某些程序类型，并且 `BPF_PROG_TYPE_KPROBE`
    不在其中。`BPF_CGROUP_INET_INGRESS` 恰好是 BPF 附加类型列表中的第一个，^([3](ch04.html#ch04fn3)) 因此它的值是
    `0`。'
- en: The `prog_btf_fd` field tells the kernel which blob of previously loaded BTF
    data to use with this program. The value `3` here corresponds to the file descriptor
    you saw returned from the `BPF_BTF_LOAD` syscall (and it’s the same blob of BTF
    data used for the `config` map).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog_btf_fd` 字段告诉内核要使用之前加载的 BTF 数据块来执行这个程序。这里的值 `3` 对应于从 `BPF_BTF_LOAD` 系统调用返回的文件描述符（而且这与
    `config` 映射使用的同一个 BTF 数据块相同）。'
- en: If the program had failed verification (which I’ll discuss in [Chapter 6](ch06.html#the_ebpf_verifier)),
    this syscall would have returned a negative value, but here you can see it returned
    the file descriptor 6\. To recap, at this point the file descriptors have the
    meanings shown in [Table 4-1](#file_descriptors_when_running_hello_buf).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序验证失败（我将在[第 6 章](ch06.html#the_ebpf_verifier)中讨论），此系统调用将返回一个负值，但在这里你可以看到它返回了文件描述符
    `6`。总结一下，此时文件描述符的含义如[表 4-1](#file_descriptors_when_running_hello_buf)所示。
- en: Table 4-1\. File descriptors when running hello-buffer-config.py after loading
    the program
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 运行 hello-buffer-config.py 时的文件描述符
- en: '| File descriptor | Represents |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 文件描述符 | 代表 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `3` | BTF data |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `3` | BTF 数据 |'
- en: '| `4` | `output` perf buffer map |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `output` 性能缓冲区映射 |'
- en: '| `5` | `config` hash table map |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `config` 哈希表映射 |'
- en: '| `6` | `hello` eBPF program |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `hello` eBPF 程序 |'
- en: Modifying a Map from User Space
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改用户空间中的映射
- en: 'You already saw the line in the Python user space source code that configures
    special messages that will be displayed for the root user with user ID 0, and
    for the user with ID 501:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在 Python 用户空间源代码中看到了一行，该行配置了将显示给根用户（用户 ID 0）和用户 ID 501 的特殊消息：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see these entries being defined in the map through syscalls like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过这样的系统调用看到这些条目是如何在映射中定义的：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `BPF_MAP_UPDATE_ELEM` command updates the key–value pair in a map. The `BPF_ANY`
    flag indicates that if the key doesn’t already exist in this map, it should be
    created. There are two of these calls, corresponding to the two entries configured
    for two different user IDs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_MAP_UPDATE_ELEM` 命令更新映射中的键值对。 `BPF_ANY` 标志表示，如果该映射中不存在该键，则应创建它。 这两个调用对应于为两个不同用户
    ID 配置的两个条目。'
- en: The `map_fd` field identifies which map is being operated on. You can see that
    in this case it’s `5`, which is the file descriptor value returned earlier when
    the `config` map was created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`map_fd` 字段标识正在操作的映射。 您可以看到在这种情况下它是 `5`，这是早些时候创建 `config` 映射时返回的文件描述符值。'
- en: File descriptors are assigned by the kernel for a particular process, so this
    value of `5` is only valid for this particular user space process in which the
    Python program is running. However, multiple user space programs (and multiple
    eBPF programs in the kernel) can all access the same map. Two user space programs
    that access the same map structure in the kernel might very well be assigned different
    file descriptor values; equally, two user space programs might have the same file
    descriptor value for entirely different maps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符由内核为特定进程分配，因此 `5` 的这个值仅对运行 Python 程序的特定用户空间进程有效。 但是，多个用户空间程序（以及内核中的多个 eBPF
    程序）都可以访问相同的映射。 两个访问内核中同一映射结构的用户空间程序可能会被分配不同的文件描述符值；同样，两个用户空间程序可能会对完全不同的映射使用相同的文件描述符值。
- en: 'Both the key and the value are pointers, so you can’t tell the numeric value
    of either the key or the value from this `strace` output. You could, however,
    use `bpftool` to view the map’s contents and see something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值都是指针，因此无法从此 `strace` 输出中知道键或值的数值。 但是，您可以使用 `bpftool` 查看映射的内容，并看到类似以下的内容：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How does `bpftool` know how to format this output? For example, how does it
    know the value is a structure, with a field called `message` that contains a string?
    The answer is that it uses the definitions in the BTF information included on
    the `BPF_MAP_CREATE` syscall that defined this map. You’ll see more details on
    how BTF conveys this information in the next chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool` 如何知道如何格式化此输出呢？ 例如，它如何知道值是一个结构，其中有一个名为 `message` 的字段，其中包含一个字符串？ 答案是它使用
    BPF_MAP_CREATE 系统调用中包含的 BTF 信息中定义的定义。 在下一章节中，您将看到有关 BTF 如何传达此信息的更多详细信息。'
- en: You’ve now seen how user space interacts with the kernel to load programs and
    maps and to update the information in a map. In the sequence of syscalls you have
    seen up to this point, the program hasn’t yet been attached to an event. This
    step has to happen; otherwise, the program will never be triggered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到用户空间如何与内核交互以加载程序和映射，并更新映射中的信息。 在您到目前为止看到的系统调用序列中，程序尚未附加到事件。 这一步必须发生；否则，程序将永远不会被触发。
- en: 'Fair warning: different types of eBPF programs get attached to different events
    in a variety of different ways! Later in this chapter I’ll show you the syscalls
    used in this example to attach to the kprobe event, and in this case it doesn’t
    involve `bpf()`. In contrast, in the exercises at the end of this chapter I will
    show you another example where a `bpf()` syscall is used to attach a program to
    a raw tracepoint event.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 公平警告：不同类型的 eBPF 程序以各种不同的方式附加到不同事件上！ 在本例中，稍后我将向您展示用于附加到 kprobe 事件的示例中使用的系统调用，而在这种情况下它不涉及
    `bpf()`。 相比之下，在本章末尾的练习中，我将向您展示另一个示例，在该示例中使用 `bpf()` 系统调用将程序附加到原始跟踪点事件。
- en: Before we get to those details, I’d like to discuss what happens when you quit
    running the program. You’ll find that the program and maps are automatically unloaded,
    and this happens because the kernel is keeping track of them using *reference
    counts*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这些细节之前，我想讨论一下当您停止运行程序时会发生什么。 您会发现程序和映射会自动卸载，这是因为内核使用 *引用计数* 来跟踪它们。
- en: BPF Program and Map References
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF 程序和映射引用
- en: You know that loading a BPF program into the kernel with the `bpf()` syscall
    returns a file descriptor. Within the kernel, this file descriptor is a *reference*
    to the program. The user space process that made the syscall owns this file descriptor;
    when that process exits, the file descriptor gets released, and the reference
    count to the program is decremented. When there are no references left to a BPF
    program, the kernel removes the program.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道使用 `bpf()` 系统调用将 BPF 程序加载到内核中会返回一个文件描述符。在内核中，这个文件描述符是对程序的 *引用*。进行此系统调用的用户空间进程拥有此文件描述符；当该进程退出时，文件描述符将被释放，程序的引用计数将减少。当没有引用指向
    BPF 程序时，内核将删除该程序。
- en: An additional reference is created when you *pin* a program to the filesystem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*固定* 程序到文件系统时会创建额外的引用。'
- en: Pinning
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定
- en: 'You already saw pinning in action in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3章](ch03.html#anatomy_of_an_ebpf_program) 中，你已经看到了固定的示例，具体命令如下：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These pinned objects aren’t real files persisted to disk. They are created on
    a *pseudo filesystem*, which behaves like a regular disk-based filesystem with
    directories and files. But they are held in memory, which means they will not
    remain in place over a system reboot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些固定的对象并不是真实存储在磁盘上的文件。它们是在 *伪文件系统* 上创建的，其行为类似于具有目录和文件的常规基于磁盘的文件系统。但它们保存在内存中，这意味着它们在系统重启后不会保持原位。
- en: If `bpftool` were to allow you to load the program without pinning it, that
    would be pointless, because the file descriptor gets released when `bpftool` exits,
    and if there are zero references, the program would get deleted, so nothing useful
    would have been achieved. But pinning it to the filesystem means there is an additional
    reference to the program, so the program remains loaded after the command completes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `bpftool` 允许你在不固定的情况下加载程序，那将毫无意义，因为当 `bpftool` 退出时文件描述符会释放，如果引用计数为零，程序会被删除，因此没有实现任何有用的功能。但是将其固定到文件系统意味着程序有了额外的引用，因此程序在命令完成后仍然加载。
- en: 'The reference counter also gets incremented when a BPF program is attached
    to a hook that will trigger it. The behavior of these reference counts depends
    on the BPF program type. You’ll learn more about these program types in [Chapter 7](ch07.html#ebpf_program_and_attachment_types),
    but there are some that relate to tracing (like kprobes and tracepoints) and are
    always associated with a user space process; for these types of eBPF programs,
    the kernel’s reference count gets decremented when that process exits. Programs
    that are attached within the network stack or cgroups (short for “control groups”)
    aren’t associated with any user space process, so they stay in place even after
    the user space program that loads them exits. You already saw an example of this
    when loading an XDP program with the `ip link` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 BPF 程序附加到触发它的钩子上时，引用计数器也会增加。这些引用计数的行为取决于 BPF 程序的类型。关于这些程序类型，你将在 [第7章](ch07.html#ebpf_program_and_attachment_types)
    中了解更多，但有些与跟踪相关（如 kprobes 和 tracepoints），总是与用户空间进程相关联；对于这些类型的 eBPF 程序，内核的引用计数在该进程退出时会减少。附加在网络堆栈或
    cgroups（“控制组”）中的程序与任何用户空间进程无关联，因此即使加载它们的用户空间程序退出后，它们也会保持在原位。当使用 `ip link` 命令加载
    XDP 程序时，你已经看到了这种情况的一个例子：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ip` command has completed, and there is no definition of a pinned location,
    but nevertheless, `bpftool` will show you that the XDP program is loaded in the
    kernel:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip` 命令已完成，并没有固定位置的定义，但是 `bpftool` 将显示 XDP 程序已加载到内核中：'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The reference count for this program is nonzero, because of the attachment to
    the XDP hook that persisted after the `ip link` command completed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接到 XDP 钩子后，此程序的引用计数不为零，即使 `ip link` 命令完成后也是如此。
- en: eBPF maps also have reference counters, and they get cleaned up when their reference
    count drops to zero. Each eBPF program that uses a map increments the counter,
    as does each file descriptor that user space programs might hold to the map.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 映射也有引用计数器，当其引用计数降至零时会进行清理。每个使用映射的 eBPF 程序都会增加计数器，用户空间程序持有的每个文件描述符也会增加计数器。
- en: It’s possible that the source code for an eBPF program might define a map that
    the program doesn’t actually reference. Suppose you wanted to store some metadata
    about a program; you could define it as a global variable, and as you saw in the
    previous chapter, this information gets stored in a map. If the eBPF program doesn’t
    do anything with that map, there won’t automatically be a reference count from
    the program to the map. There’s a `BPF(BPF_PROG_BIND_MAP)` syscall that associates
    a map with a program so that the map doesn’t get cleaned up as soon as the user
    space loader program exits and is no longer holding a file descriptor reference
    to the map.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能eBPF程序的源代码定义了一个程序实际上不引用的映射。假设您想存储关于程序的一些元数据；您可以将其定义为全局变量，并且正如您在上一章中看到的那样，这些信息会存储在一个映射中。如果eBPF程序对该映射什么也不做，则程序到映射之间不会自动存在引用计数。有一个`BPF(BPF_PROG_BIND_MAP)`系统调用将一个映射与一个程序关联起来，以便在用户空间加载程序退出并且不再持有映射的文件描述符引用时，映射不会立即被清除。
- en: Maps can also be pinned to the filesystem, and user space programs can gain
    access to the map by knowing the path to the map.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 映射也可以固定到文件系统，并且用户空间程序可以通过知道映射的路径来访问该映射。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Alexei Starovoitov wrote a good description of BPF reference counters and file
    descriptors in his blog post [“Lifetime of BPF Objects”](https://oreil.ly/vofxH).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Alexei Starovoitov在他的博客文章[“BPF对象的生命周期”](https://oreil.ly/vofxH)中对BPF引用计数器和文件描述符进行了很好的描述。
- en: Another way to create a reference to a BPF program is with a BPF link.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建对BPF程序的引用的方式是使用BPF链接。
- en: BPF Links
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BPF链接
- en: BPF links provide a layer of abstraction between an eBPF program and the event
    it’s attached to. A BPF link itself can be pinned to the filesystem, which creates
    an additional reference to the program. This means the user space process that
    loaded the program into the kernel can terminate, leaving the program loaded.
    The file descriptor for the user space loader program gets freed up, decreasing
    the count of references to the program, but the reference count will be nonzero
    because of the BPF link.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: BPF链接为eBPF程序和其附加的事件之间提供了一层抽象。BPF链接本身可以固定到文件系统上，这样会为程序创建一个额外的引用。这意味着加载程序将eBPF程序加载到内核中的用户空间进程可以终止，但是程序仍然保持加载状态。用户空间加载程序的文件描述符被释放，减少对程序的引用计数，但由于BPF链接的存在，引用计数将不为零。
- en: You’ll get an opportunity to see BPF links in action if you follow the exercises
    at the end of this chapter. For now, let’s get back to the sequence of `bpf()`
    syscalls used by *hello-buffer-config.py*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本章结束后跟随练习，您将有机会看到BPF链接的实际操作。现在，让我们回到*hello-buffer-config.py*中使用的`bpf()`系统调用序列。
- en: Additional Syscalls Involved in eBPF
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF涉及的其他系统调用
- en: To recap, so far you have seen `bpf()` syscalls that add the BTF data, program
    and maps, and map data to the kernel. The next thing the `strace` output shows
    relates to setting up the perf buffer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，到目前为止您已经看到了用于向内核添加BTF数据、程序和映射以及映射数据的`bpf()`系统调用。接下来，`strace`输出显示的下一步与设置性能缓冲区有关。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The rest of this chapter dives relatively deeply into the syscall sequences
    involved when using perf buffers, ring buffers, kprobes, and map iterations. Not
    all eBPF programs need to do these things, so if you’re in a hurry or you’re finding
    it a bit too detailed, feel free to skip to the chapter summary. I won’t be offended!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将相对深入地探讨在使用性能缓冲区、环形缓冲区、kprobes和映射迭代时涉及的系统调用序列。并非所有的eBPF程序都需要执行这些操作，所以如果您赶时间或者感觉内容有点过于详细，可以直接跳到章节总结部分，我不会介意的！
- en: Initializing the Perf Buffer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化性能缓冲区
- en: 'You have seen the `bpf(BPF_MAP_UPDATE_ELEM)` calls that add entries into the
    `config` map. Next, the output shows some calls that look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了`bpf(BPF_MAP_UPDATE_ELEM)`调用，该调用将条目添加到`config`映射中。接下来，输出显示了一些类似以下的调用：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These look very similar to the calls that defined the `config` map entries,
    except in this case the map’s file descriptor is `4`, which represents the `output`
    perf buffer map.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来与定义`config`映射条目的调用非常相似，不同之处在于此时映射的文件描述符为`4`，代表了`output`性能缓冲区映射。
- en: 'As before, the key and the value are pointers, so you can’t tell the numeric
    value of either the key or the value from this `strace` output. I see this syscall
    repeated four times with identical values for all the parameters, though there’s
    no way of knowing whether the values the pointers hold have changed between each
    call. Looking at these `BPF_MAP_UPDATE_ELEM bpf()` calls leaves some unanswered
    questions about how the buffer is set up and used:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，键和值都是指针，因此你无法从这个 `strace` 输出中得知键或值的数值。我看到这个系统调用重复了四次，所有参数的值都相同，尽管无法知道指针所持有的值在每次调用之间是否有变化。查看这些
    `BPF_MAP_UPDATE_ELEM bpf()` 调用留下了一些关于如何设置和使用缓冲区的未解答问题：
- en: Why are there four calls to `BPF_MAP_UPDATE_ELEM`? Does this relate to the fact
    that the `output` map was created with a maximum of four entries?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么会有四次调用 `BPF_MAP_UPDATE_ELEM`？这是否与 `output` map 创建时最多四个条目有关？
- en: After these four instances of `BPF_MAP_UPDATE_ELEM`, no more `bpf()` syscalls
    appear in the `strace` output. That might seem a little odd, because the map is
    there so that the eBPF program can write data every time it is triggered, and
    you’ve seen data being displayed by the user space code. That data is clearly
    not being retrieved from the map with `bpf()` syscalls, so how is it obtained?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这四个 `BPF_MAP_UPDATE_ELEM` 实例之后，`strace` 输出中不再出现更多的 `bpf()` 系统调用。这可能看起来有点奇怪，因为这个映射存在的目的是使
    eBPF 程序每次触发时能够写入数据，而你已经看到用户空间代码显示了数据。显然，这些数据并未通过 `bpf()` 系统调用从映射中检索，那么它是如何获取的？
- en: 'You’ve also yet to see any evidence of how the eBPF program is getting attached
    to the kprobe event that triggers it. To get the explanation for all these concerns,
    I need `strace` to show a few more syscalls when running this example, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有看到任何证据表明 eBPF 程序是如何附加到触发它的 kprobe 事件上的。要解释所有这些问题，我需要 `strace` 在运行这个例子时显示更多的系统调用，就像这样：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For brevity, I’m going to ignore calls to `ioctl()` that aren’t specifically
    related to the eBPF functionality of this example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为简洁起见，我将忽略那些与这个例子的 eBPF 功能不相关的 `ioctl()` 调用。
- en: Attaching to Kprobe Events
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加到 Kprobe 事件上
- en: 'You’ve seen that file descriptor 6 was assigned to represent the eBPF program
    *hello* once it was loaded into the kernel. To attach the eBPF program to an event,
    you also need a file descriptor representing that particular event. The following
    line from the `strace` output shows the creation of the file descriptor for the
    `execve()` kprobe:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到文件描述符 6 被分配来代表内核中加载的 eBPF 程序 *hello*。为了将 eBPF 程序附加到事件上，你还需要一个文件描述符来代表特定的事件。`strace`
    输出中的以下行显示了为 `execve()` kprobe 创建文件描述符的过程：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'According to the [manpage for the `perf_event_open()` syscall](https://oreil.ly/xpRJs),
    it “creates a file descriptor that allows measuring performance information.”
    You can see from the output that `strace` doesn’t know how to interpret the type
    parameter with the value `6`, but if you examine that manpage further, it describes
    how Linux supports dynamic types of Performance Measurement Unit:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [manpage for the `perf_event_open()` syscall](https://oreil.ly/xpRJs) 所述，“创建一个文件描述符，允许测量性能信息。”
    你可以从输出中看到 `strace` 不知道如何解释类型参数值为 `6`，但如果进一步查看该 manpage，它描述了 Linux 支持性能测量单元的动态类型：
- en: …there is a subdirectory per PMU instance under */sys/bus/event_source/devices*.
    In each subdirectory there is a type file whose content is an integer that can
    be used in the type field.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …在 */sys/bus/event_source/devices* 下每个 PMU 实例都有一个子目录。在每个子目录中，有一个类型文件，其内容是一个整数，可以在类型字段中使用。
- en: 'Sure enough, if you look under that directory, you’ll find a *kprobe/type*
    file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实在该目录下查找，你会找到一个 *kprobe/type* 文件：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From this, you can see that the call to `perf_event_open()` has a type set to
    the value `6` to indicate that it’s a kprobe type of perf event.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以看到 `perf_event_open()` 的调用设置了类型值为 `6`，表示它是一种 kprobe 类型的性能事件。
- en: Unfortunately, `strace` doesn’t output the details that would conclusively show
    that the kprobe is attached to the `execve()` syscall, but I hope there is enough
    evidence here to convince you that that’s what the file descriptor returned here
    represents.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 并没有输出详细信息来确切显示 kprobe 已经附加到 `execve()` 系统调用上，但我希望这里的证据足以说服你，这个文件描述符返回的是这个。'
- en: 'The return code from `perf_event_open()` is `7`, and this represents the file
    descriptor for the kprobe’s perf event, and you know that file descriptor `6`
    represents the *hello* eBPF program. The manpage for `perf_event_open()` also
    explains how to use `ioctl()` to create the attachment between the two:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf_event_open()`的返回代码是`7`，这表示了kprobe的性能事件的文件描述符，你知道文件描述符`6`表示*eBPF*程序的*hello*。`perf_event_open()`的手册还解释了如何使用`ioctl()`来创建两者之间的附加关系：'
- en: '`PERF_EVENT_IOC_SET_BPF` [...] allows attaching a Berkeley Packet Filter (BPF)
    program to an existing kprobe tracepoint event. The argument is a BPF program
    file descriptor that was created by a previous `bpf(2)` system call.'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`PERF_EVENT_IOC_SET_BPF` [...] 允许将一个伯克利数据包过滤（BPF）程序附加到一个已存在的kprobe跟踪点事件上。该参数是通过先前的`bpf(2)`系统调用创建的BPF程序文件描述符。'
- en: 'This explains the following `ioctl()` syscall that you’ll see in the `strace`
    output, with arguments referring to the two file descriptors:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了你会在`strace`输出中看到的以下`ioctl()`系统调用，其参数涉及两个文件描述符：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is also another `ioctl()` call that turns the kprobe event on:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个`ioctl()`调用来启用kprobe事件：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this in place, the eBPF program should be triggered whenever `execve()`
    is run on this machine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，每当在这台机器上运行`execve()`时，eBPF程序就应该会被触发。
- en: Setting Up and Reading Perf Events
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和读取性能事件
- en: 'I already mentioned that I see four calls to `bpf(BPF_MAP_UPDATE_ELEM)` related
    to the output perf buffer. With the additional syscalls being traced, the `strace`
    output shows four sequences, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了，我看到了四次调用`bpf(BPF_MAP_UPDATE_ELEM)`与输出性能缓冲相关联。随着额外的系统调用被跟踪，`strace`输出显示了四个序列，如下所示：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I’ve used `X` to indicate where the output shows values `0`, `1`, `2`, and
    `3` in the four instances of this call. Referring to the manpage for the `perf_event_open()`
    syscall, you’ll see that this is the `cpu`, and the field before it is `pid` or
    process ID. From the manpage:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了`X`来指示输出在四个此调用实例中显示值`0`、`1`、`2`和`3`的位置。参考`perf_event_open()`系统调用的手册页面，你会看到这是`cpu`，而它之前的字段是`pid`或进程ID。从手册页面来看：
- en: pid == -1 and cpu >= 0
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pid == -1且cpu >= 0
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This measures all processes/threads on the specified CPU.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这会测量指定CPU上的所有进程/线程。
- en: 'The fact that this sequence happens four times corresponds to there being four
    CPU cores in my laptop. This, at last, is the explanation for why there are four
    entries in the “output” perf buffer map: there is one for each CPU core. It also
    explains the “array” part of the map type name `BPF_MAP_TYPE_PERF_EVENT_ARRAY`,
    as the map doesn’t just represent one perf ring buffer but an array of buffers,
    one for each core.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列发生四次的事实对应于我笔记本电脑中存在四个CPU核心。这最终解释了为什么“output”性能缓冲区映射中有四个条目的原因：每个CPU核心都有一个。这也解释了映射类型名称`BPF_MAP_TYPE_PERF_EVENT_ARRAY`中“array”的部分，因为该映射不仅仅表示一个性能环缓冲区，而是一个缓冲区数组，每个核心一个。
- en: If you write eBPF programs, you won’t need to worry about details like handling
    the number of cores, as this will be taken care of for you by any of the eBPF
    libraries discussed in [Chapter 10](ch10.html#ebpf_programming), but I think it’s
    an interesting aspect of the syscalls you see when you use `strace` on this program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写eBPF程序，你不需要担心如何处理核心数量等细节，因为在[第10章](ch10.html#ebpf_programming)讨论的任何eBPF库中，这些细节都会为你处理，但我认为这是在使用`strace`分析该程序时看到的系统调用的一个有趣方面。
- en: The `perf_event_open()` calls each return a file descriptor, which I’ve represented
    as `Y`; these have the values `8`, `9`, `10`, and `11`. The `ioctl()` syscalls
    enable the perf output for each of these file descriptors. The `BPF_MAP_UPDATE_ELEM
    bpf()` syscalls set the map entry to point to the perf ring buffer for each CPU
    core to indicate where it can submit data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`perf_event_open()`调用都返回一个文件描述符，我将它们表示为`Y`；它们的值分别是`8`、`9`、`10`和`11`。`ioctl()`系统调用使得每个CPU核心的性能输出启用了对应的性能环缓冲区的映射条目以指示可以提交数据的位置。
- en: 'User space code can then use `ppoll()` on all four of these output stream file
    descriptors so that it can get the data output, whichever core happens to run
    the eBPF program *hello* for any given `execve()` kprobe event. Here’s the syscall
    to `ppoll()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间代码可以随后在这四个输出流文件描述符上使用`ppoll()`，以便在任何给定的`execve()` kprobe事件触发*eBPF*程序*hello*时获取数据输出。这是对`ppoll()`的系统调用：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you’ll see if you try running the example program yourself, these `ppoll()`
    calls block until there is something to read from one of the file descriptors.
    You won’t see the return code written to the screen until something triggers `execve()`,
    which causes the eBPF program to write data that user space retrieves using this
    `ppoll()` call.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己尝试运行示例程序，你会发现这些`ppoll()`调用会阻塞，直到有文件描述符有数据可读。只有在触发`execve()`时，才会将返回码写入屏幕，这会导致eBPF程序使用这个`ppoll()`调用从用户空间检索数据。
- en: In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor) I mentioned
    that if you have a kernel of version 5.8 or above, BPF ring buffers are now preferred
    over perf buffers.^([4](ch04.html#ch04fn4)) Let’s take a look at a modified version
    of the same example code that uses a ring buffer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中，我提到如果你的内核版本是5.8或以上，BPF环形缓冲区现在优先于性能缓冲区。^([4](ch04.html#ch04fn4))
    让我们看一下使用环形缓冲区的同一示例代码的修改版本。
- en: Ring Buffers
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环形缓冲区
- en: As discussed in the [kernel documentation](https://oreil.ly/RN_RA), ring buffers
    are preferred over perf buffers partly for performance reasons, but also to ensure
    that the ordering of data is preserved, even if the data is submitted by different
    CPU cores. There is just one buffer, shared across all cores.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如[内核文档](https://oreil.ly/RN_RA)中所述，环形缓冲区比性能缓冲区更受欢迎，部分原因是性能，但也确保数据的顺序性保持，即使数据由不同CPU核心提交。只有一个缓冲区，跨所有核心共享。
- en: There aren’t many changes needed to convert *hello-buffer-config.py* to use
    a ring buffer. In the accompanying GitHub repo you’ll find this example as *chapter4/hello-ring-buffer-config.py*.
    [Table 4-2](#differences_between_example_bcc_code_us) shows the differences.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 转换*hello-buffer-config.py*以使用环形缓冲区几乎不需要进行太多更改。在附带的GitHub仓库中，你会找到这个示例作为*chapter4/hello-ring-buffer-config.py*。[表 4-2](#differences_between_example_bcc_code_us)
    展示了差异。
- en: Table 4-2\. Differences between example BCC code using a perf buffer and a ring
    buffer
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. 使用性能缓冲区和环形缓冲区的示例BCC代码之间的差异
- en: '| *hello-buffer-config.py* | *hello-ring-buffer-config.py* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| *hello-buffer-config.py* | *hello-ring-buffer-config.py* |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BPF_PERF_OUTPUT(output);` | `BPF_RINGBUF_OUTPUT(output, 1);` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `BPF_PERF_OUTPUT(output);` | `BPF_RINGBUF_OUTPUT(output, 1);` |'
- en: '| `output.perf_submit(ctx, &data, sizeof(data));` | `output.ringbuf_output(&data,
    sizeof(data), 0);` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `output.perf_submit(ctx, &data, sizeof(data));` | `output.ringbuf_output(&data,
    sizeof(data), 0);` |'
- en: '| `b["output"]. open_perf_buffer(print_event)` | `b["output"]. open_ring_buffer(print_event)`
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `b["output"]. open_perf_buffer(print_event)` | `b["output"]. open_ring_buffer(print_event)`
    |'
- en: '| `b.perf_buffer_poll()` | `b.ring_buffer_poll()` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `b.perf_buffer_poll()` | `b.ring_buffer_poll()` |'
- en: As you’d expect, since these changes relate only to the `output` buffer, the
    syscalls related to loading the program and the `config` map and attaching the
    program to the kprobe event all remain unchanged.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，由于这些变化仅涉及`output`缓冲区，加载程序和`config`映射以及将程序附加到kprobe事件相关的系统调用都保持不变。
- en: 'The `bpf()` syscall that creates the `output` ring buffer map looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`output`环形缓冲区映射的`bpf()`系统调用如下：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The major difference in the `strace` output is that there is no sign of the
    series of four different `perf_event_open()`, `ioctl()`, and `bpf(BPF_MAP_UPDATE_ELEM)`
    system calls that you observed during the setup of a perf buffer. For a ring buffer,
    there’s just the one file descriptor shared across all CPU cores.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`输出中的主要差异在于，在设置性能缓冲区时，你观察到的四个不同的`perf_event_open()`、`ioctl()`和`bpf(BPF_MAP_UPDATE_ELEM)`系统调用序列不再存在。对于环形缓冲区，只有一个文件描述符被所有CPU核心共享。'
- en: At the time of this writing, BCC is using the `ppoll` mechanism I showed earlier
    for perf buffers, but it uses the newer `epoll` mechanism to wait for data from
    the ring buffer. Let’s use this as an opportunity to understand the difference
    between `ppoll` and `epoll`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，BCC正在使用我之前展示的`ppoll`机制来进行性能缓冲区，但它使用更新的`epoll`机制来等待环形缓冲区的数据。让我们利用这个机会来理解`ppoll`和`epoll`之间的区别。
- en: 'In the perf buffer example, I showed *hello-buffer-config.py* generating a
    `ppoll()` syscall, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能缓冲区示例中，我展示了*hello-buffer-config.py*生成`ppoll()`系统调用，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that this passes in the set of file descriptors `8`, `9`, `10`, and `11`
    from which the user space process wants to retrieve data. Every time this poll
    event returns data, another call has to be made to `ppoll()` to set up the same
    set of file descriptors all over again. When using `epoll`, the file descriptor
    set is managed in a kernel object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此处传入了文件描述符集 `8`、`9`、`10` 和 `11`，用户空间进程希望从中检索数据。每次此轮询事件返回数据时，必须再次调用 `ppoll()`
    来设置相同的文件描述符集。在使用 `epoll` 时，文件描述符集由内核对象管理。
- en: You can see this in the following sequence of `epoll`-related system calls made
    when *hello-ring-buffer-config.py* is setting up access to the `output` ring buffer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *hello-ring-buffer-config.py* 设置访问 `output` 环形缓冲区时，您可以在以下 `epoll` 相关系统调用序列中看到这一点。
- en: 'First, the user space program asks for a new `epoll` instance to be created
    in the kernel:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户空间程序请求在内核中创建一个新的 `epoll` 实例：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This returns file descriptor `8`. Then there is a call to `epoll_ctl()`, which
    tells the kernel to add file descriptor `4` (the `output` buffer) to the set of
    file descriptors in that `epoll` instance:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回文件描述符 `8`。然后调用 `epoll_ctl()`，告知内核将文件描述符 `4`（`output` 缓冲区）添加到该 `epoll` 实例的文件描述符集中：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The user space program uses `epoll_pwait()` to wait until data is available
    in the ring buffer. This call only returns when data is available:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间程序使用 `epoll_pwait()` 等待环形缓冲区中有数据可用。此调用仅在数据可用时返回：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, if you’re writing code using a framework like BCC (or *libbpf* or
    any of the other libraries I’ll describe later in this book), you really don’t
    need to know these underlying details about how your user space application gets
    information from the kernel via perf or ring buffers. I hope you’ve found it interesting
    to get a peek under the covers to see how these things work.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您使用像 BCC（或 *libbpf* 或本书后面将描述的任何其他库）这样的框架编写代码，您实际上不需要了解如何通过 perf 或环形缓冲区从内核获取信息的这些底层细节。我希望您发现了解这些工作原理的底层细节很有趣。
- en: However, you might well find yourself writing code that accesses a map from
    user space, and it might be helpful to see an example of how this is achieved.
    Earlier in this chapter, I used `bpftool` to examine the contents of the `config`
    map. Since it’s a utility that runs in user space, let’s use `strace` to see what
    syscalls it’s making to retrieve this information.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能会发现自己编写访问用户空间映射的代码，看到如何实现这一点可能会很有帮助。在本章前面，我使用 `bpftool` 检查了 `config` 映射的内容。由于它是在用户空间运行的实用程序，让我们使用
    `strace` 看看它调用内核以检索此信息的过程。
- en: Reading Information from a Map
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从映射中读取信息
- en: 'The following command shows an extract of the `bpf()` syscalls that `bpftool`
    makes while reading the contents of the `config` map:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示 `bpftool` 在读取 `config` 映射内容时所做的 `bpf()` 系统调用的摘录：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you’ll see, the sequence consists of two main steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该序列包括两个主要步骤：
- en: Iterate through all the maps, looking for any with the name `config`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代所有映射，寻找任何名称为 `config` 的映射。
- en: If a matching map is found, iterate through all the elements in that map.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配的映射，请迭代该映射中的所有元素。
- en: Finding a Map
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找映射
- en: 'The output starts with a repeated sequence of similar calls, as `bpftool` walks
    through all the maps looking for any with the name `config`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以类似调用的重复序列开始，因为 `bpftool` 浏览所有映射，寻找任何名称为 `config` 的映射：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#code_id_4_7)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_4_7)'
- en: '`BPF_MAP_GET_NEXT_ID` gets the ID of the next map after the value specified
    in `start_id`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_MAP_GET_NEXT_ID` 获取指定 `start_id` 后下一个映射的 ID。'
- en: '[![2](assets/2.png)](#code_id_4_8)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_4_8)'
- en: '`BPF_MAP_GET_FD_BY_ID` returns the file descriptor for the specified map ID.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_MAP_GET_FD_BY_ID` 返回指定映射 ID 的文件描述符。'
- en: '[![3](assets/3.png)](#code_id_4_9)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_4_9)'
- en: '`BPF_OBJ_GET_INFO_BY_FD` retrieves information about the object (in this case,
    the map) referred to by the file descriptor. This information includes its name
    so `bpftool` can check whether this is the map it is looking for.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_OBJ_GET_INFO_BY_FD` 检索有关文件描述符引用的对象（在本例中是映射）的信息。此信息包括其名称，因此 `bpftool` 可以检查这是否是它正在寻找的映射。'
- en: '[![4](assets/4.png)](#code_id_4_10)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_4_10)'
- en: The sequence repeats, getting the ID of the next map after the one in step 1.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 序列重复，在步骤 1 中的下一个映射的 ID。
- en: 'There’s a group of these three syscalls for each map loaded into the kernel,
    and you should also see that the values used for `start_id` and `map_id` match
    the IDs of those maps. The repeated pattern ends when there are no more maps left
    to look at, which results in `BPF_MAP_GET_NEXT_ID` returning a value of `ENOENT`,
    like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加载到内核中的每个映射，都有这三个系统调用的一组。您还应该看到 `start_id` 和 `map_id` 的值与这些映射的 ID 匹配。当没有更多映射可查看时，重复模式会结束，这导致
    `BPF_MAP_GET_NEXT_ID` 返回 `ENOENT`，如下所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If a matching map has been found, `bpftool` holds its file descriptor so that
    it can read the elements out of that map.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了匹配的映射，`bpftool` 将持有其文件描述符，以便可以从该映射中读取元素。
- en: Reading Map Elements
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取映射元素
- en: 'At this point `bpftool` has a file descriptor reference to the map(s) it’s
    going to read from. Let’s look at the syscall sequence for reading that information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`bpftool` 拥有映射的文件描述符引用，它将从中读取。让我们看看用于读取该信息的系统调用序列：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#code_id_4_11)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_4_11)'
- en: First, the application needs to find a valid key that is present in the map.
    It does this with the `BPF_MAP_GET_NEXT_KEY` flavor of the `bpf()` syscall. The
    `key` argument is a pointer to a key, and the syscall will return the next valid
    key *after* this one. By passing in a NULL pointer, the application is requesting
    the first valid key in the map. The kernel writes the key into the location specified
    by the `next_key` pointer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应用程序需要找到映射中存在的有效键。它使用 `bpf()` 系统调用的 `BPF_MAP_GET_NEXT_KEY` 类型。`key` 参数是一个指向键的指针，系统调用将返回此键之后的下一个有效键。通过传递
    NULL 指针，应用程序请求映射中的第一个有效键。内核将键写入由 `next_key` 指针指定的位置。
- en: '[![2](assets/2.png)](#code_id_4_12)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_4_12)'
- en: Given a key, the application requests the associated value, which gets written
    to the memory location specified by `value`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个键，应用程序请求关联的值，并将其写入由 `value` 指定的内存位置。
- en: '[![3](assets/3.png)](#code_id_4_13)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_4_13)'
- en: At this point, `bpftool` has the contents of the first key–value pair, and it
    writes this information to the screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`bpftool` 拥有第一个键-值对的内容，并将此信息写入屏幕。
- en: '[![4](assets/4.png)](#code_id_4_14)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_4_14)'
- en: Here, `bpftool` moves on to the next key in the map, retrieves its value, and
    writes out this key–value pair to the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bpftool` 继续移动到映射中的下一个键，检索其值，并将此键-值对写入屏幕。
- en: '[![5](assets/5.png)](#code_id_4_15)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_4_15)'
- en: The next call to `BPF_MAP_GET_NEXT_KEY` returns `ENOENT` to indicate that there
    are no more entries in the map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `BPF_MAP_GET_NEXT_KEY` 的下一次调用返回 `ENOENT`，以指示映射中没有更多条目。
- en: '[![6](assets/6.png)](#code_id_4_16)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_4_16)'
- en: Here, `bpftool` finalizes the output written to screen and exits.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bpftool` 完成了写入屏幕的最终输出并退出。
- en: Notice that here, `bpftool` has been assigned file descriptor `3` to correspond
    to the `config` map. This is the same map that *hello-buffer-config.py* refers
    to with file descriptor `4`. As I’ve mentioned already, file descriptors are process
    specific.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，`bpftool` 已被分配文件描述符 `3`，对应于 `config` 映射。这是 *hello-buffer-config.py* 使用文件描述符
    `4` 引用的同一个映射。正如我之前提到的，文件描述符是进程特定的。
- en: This analysis of how `bpftool` behaves shows how a user space program can iterate
    through the available maps and through the key–value pairs stored in a map.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 分析显示了 `bpftool` 的行为方式，展示了用户空间程序如何迭代可用映射及映射中存储的键-值对。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter you saw how user space code uses the `bpf()` syscall to load
    eBPF programs and maps. You saw programs and maps being created using the `BPF_PROG_LOAD`
    and `BPF_MAP_CREATE` commands.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了用户空间代码如何使用 `bpf()` 系统调用加载 eBPF 程序和映射。您看到了使用 `BPF_PROG_LOAD` 和 `BPF_MAP_CREATE`
    命令创建程序和映射。
- en: You learned that the kernel keeps track of the number of references to eBPF
    programs and maps, releasing them when the reference count drops to zero. You
    were also introduced to the concepts of pinning BPF objects to a filesystem and
    using BPF links to create additional references.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解到内核跟踪对 eBPF 程序和映射的引用计数，当引用计数降至零时释放它们。还介绍了将 BPF 对象固定到文件系统并使用 BPF 链接创建附加引用的概念。
- en: You saw an example of `BPF_MAP_UPDATE_ELEM` being used to create entries in
    a map from user space. There are similar commands—`BPF_MAP_LOOKUP_ELEM` and `BPF_MAP_DELETE_ELEM`—for
    retrieving and deleting values from a map. There is also the command `BPF_MAP_GET_NEXT_KEY`
    for finding the next key that’s present in a map. You can use this to iterate
    through all the valid entries.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了一个示例，展示了如何使用`BPF_MAP_UPDATE_ELEM`来从用户空间创建映射条目。类似的命令还有`BPF_MAP_LOOKUP_ELEM`和`BPF_MAP_DELETE_ELEM`，用于从映射中检索和删除值。还有一个命令`BPF_MAP_GET_NEXT_KEY`，用于查找映射中下一个存在的键。您可以使用它来遍历所有有效的条目。
- en: You saw examples of user space programs making use of `perf_event_open()` and
    `ioctl()` for attaching eBPF programs to kprobe events. The attachment method
    can be very different for other types of eBPF programs, and some of them even
    use the `bpf()` system call. For example, there’s a `bpf(BPF_PROG_ATTACH)` syscall
    that can be used to attach cgroup programs, and `bpf(BPF_RAW_TRACEPOINT_OPEN)`
    for raw tracepoints (see Exercise 5 at the end of this chapter).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了用户空间程序示例，这些程序利用`perf_event_open()`和`ioctl()`来将eBPF程序附加到kprobe事件。对于其他类型的eBPF程序，附加方法可能大不相同，有些甚至使用`bpf()`系统调用。例如，有一个`bpf(BPF_PROG_ATTACH)`系统调用可用于附加cgroup程序，以及一个`bpf(BPF_RAW_TRACEPOINT_OPEN)`用于原始tracepoint（见本章末尾的练习5）。
- en: I also showed how you can use `BPF_MAP_GET_NEXT_ID`, `BPF_MAP_GET_FD_BY_ID`,
    and `BPF_OBJ_GET_INFO_BY_FD` to locate map (and other) objects held by the kernel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我还展示了如何使用`BPF_MAP_GET_NEXT_ID`、`BPF_MAP_GET_FD_BY_ID`和`BPF_OBJ_GET_INFO_BY_FD`来定位内核持有的映射（和其他）对象。
- en: There are some other `bpf()` commands that I haven’t covered in this chapter,
    but what you have seen here is enough to get a good overview.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中还有一些其他`bpf()`命令我没有涵盖，但您在这里看到的已经足以提供一个良好的概述。
- en: You also saw some BTF data being loaded into the kernel, and I mentioned that
    `bpftool` uses this information to understand the format of data structures so
    that it can print them out nicely. I didn’t explain yet what BTF data looks like
    or how it’s used to make eBPF programs portable across kernel versions. That’s
    coming up in the next chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到了一些BTF数据被加载到内核中，我提到`bpftool`使用这些信息来理解数据结构的格式，以便能够漂亮地打印出它们。我还没有解释BTF数据的外观或者它如何用于使eBPF程序在内核版本之间可移植。这将在下一章中详细介绍。
- en: Exercises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are a few things you can try if you’d like to explore the `bpf()` syscall
    further:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步探索`bpf()`系统调用，可以尝试以下几件事情：
- en: Confirm that the `insn_cnt` field from a `BPF_PROG_LOAD` system call corresponds
    to the number of instructions that are output if you dump the translated eBPF
    bytecode for that program using `bpftool`. (This is as documented on the [manpage
    for the `bpf()` system call](https://oreil.ly/NJdIM).)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认通过`bpftool`转储已加载程序的翻译后的eBPF字节码时，`BPF_PROG_LOAD`系统调用的`insn_cnt`字段是否对应于输出的指令数量（如`bpf()`系统调用的手册页所述）。
- en: Run two instances of the example program so that there are two maps called `config`.
    If you run `bpftool map dump name config`, the output will include information
    about the two different maps as well as their contents. Run this under `strace`,
    and follow the use of different file descriptors through the syscall output. Can
    you see where it’s retrieving information about a map and where it’s retrieving
    the key–value pairs stored within it?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行两个示例程序的实例，以便有两个名为`config`的映射。如果运行`bpftool map dump name config`，输出将包括关于两个不同映射以及它们内容的信息。在`strace`下运行，并通过系统调用输出跟踪不同的文件描述符使用情况。您能看到它从哪里检索映射信息以及从中检索键-值对存储的地方吗？
- en: Use `bpftool map update` to modify the `config` map while one of the example
    programs is running. Use `sudo -u username` to check that these configuration
    changes are picked up by the eBPF program.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`bpftool map update`来修改正在运行的示例程序之一中的`config`映射。使用`sudo -u username`来检查这些配置更改是否被eBPF程序接受。
- en: 'While *hello-buffer-config.py* is running, use `bpftool` to pin the program
    to the BPF filesystem, like this:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*hello-buffer-config.py*正在运行时，使用`bpftool`将程序固定到BPF文件系统，方法如下：
- en: '[PRE33]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Quit the running program, and check that the *hello* program is still loaded
    in the kernel using `bpftool prog list`. You can clean up the link by removing
    the pin with `rm /sys/fs/bpf/hi`.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 退出运行中的程序，并检查内核中是否仍加载了*hello*程序，使用`bpftool prog list`。您可以通过`rm /sys/fs/bpf/hi`来清理链接。
- en: 'Attaching to a raw tracepoint is considerably more straightforward at the syscall
    level than attaching to a kprobe, as it simply involves a `bpf()` syscall. Try
    converting *hello-buffer-config.py* to attach to the raw tracepoint for `sys_enter`,
    using BCC’s `RAW_TRACEPOINT_PROBE` macro (if you did the exercises in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    you’ll already have a suitable program you can use). You won’t need to explicitly
    attach the program in the Python code, as BCC will take care of it for you. Running
    this under `strace`, you should see a syscall similar to this:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统调用级别上，与挂载到 kprobe 相比，直接附加到原始 tracepoint 要简单得多，因为它只涉及一个 `bpf()` 系统调用。尝试将 *hello-buffer-config.py*
    转换为使用 BCC 的 `RAW_TRACEPOINT_PROBE` 宏来附加到 `sys_enter` 的原始 tracepoint （如果你在 [第 2
    章](ch02.html#ebpfapostrophes_quotation_markhello_wor) 中完成了练习，你已经有一个适合的程序可以使用）。你不需要在
    Python 代码中显式附加程序，因为 BCC 会替你处理。在 `strace` 下运行，你应该会看到类似这样的系统调用：
- en: '[PRE34]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The tracepoint in the kernel has the name `sys_enter`, and the eBPF program
    with file descriptor `6` is being attached to it. From now on, whenever execution
    in the kernel reaches that tracepoint, it will trigger the eBPF program.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内核中的 tracepoint 名称为 `sys_enter`，文件描述符为 `6` 的 eBPF 程序被附加到它。从现在开始，每当内核中的执行达到该
    tracepoint 时，它都会触发 eBPF 程序。
- en: 'Run the opensnoop application from [BCC’s set of *libbpf tools*](https://oreil.ly/D31R4).
    This tool sets up some BPF links that you can see with `bpftool`, like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行来自 [BCC 的 *libbpf 工具集*](https://oreil.ly/D31R4) 中的 opensnoop 应用程序。该工具会设置一些你可以用
    `bpftool` 看到的 BPF 链接，如下所示：
- en: '[PRE35]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Confirm that the program IDs (1849 and 1851 in my example output here) match
    the output from listing the loaded eBPF programs:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确认程序 ID（1849 和 1851 在我这里的示例输出中）与列出的加载的 eBPF 程序的输出相匹配：
- en: '[PRE36]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While opensnoop is running, try pinning one of these links with `bpftool link
    pin id 116 /sys/fs/bpf/mylink` (using one of the link IDs you see output from
    `bpftool link list`). You should see that even after you terminate opensnoop,
    both the link and the corresponding program remain loaded in the kernel.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 opensnoop 在运行时，尝试使用 `bpftool link pin id 116 /sys/fs/bpf/mylink` 将其中一个链接固定住（使用
    `bpftool link list` 输出的链接 ID 之一）。你应该看到，即使终止 opensnoop，链接和相应的程序仍然加载在内核中。
- en: If you skip ahead to the example code for [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    you’ll find a version of *hello-buffer-config.py* written using the *libbpf* library.
    This library automatically sets up a BPF link to the program that it loads into
    the kernel. Use `strace` to inspect the `bpf()` system calls that it makes, and
    see `bpf(BPF_LINK_CREATE)` system calls.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你跳到 [第 5 章](ch05.html#co_recomma_btfcomma_and_libbpf) 的示例代码，你会发现使用 *libbpf*
    库编写的 *hello-buffer-config.py* 版本。这个库会自动为加载到内核中的程序设置一个 BPF 链接。使用 `strace` 检查它所做的
    `bpf()` 系统调用，以及查看 `bpf(BPF_LINK_CREATE)` 系统调用。
- en: ^([1](ch04.html#ch04fn1-marker)) If you want to see the full set of BPF commands,
    they’re documented in the [*linux/bpf.h*](https://oreil.ly/Pyy7U) header file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#ch04fn1-marker)) 如果你想查看完整的 BPF 命令集，它们在 [*linux/bpf.h*](https://oreil.ly/Pyy7U)
    头文件中有文档。
- en: ^([2](ch04.html#ch04fn2-marker)) BTF was introduced upstream in the 5.1 kernel,
    but it has been back-ported on some Linux distributions, as you can see from [this
    discussion](https://oreil.ly/LjcPN).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#ch04fn2-marker)) BTF 在 5.1 内核中被引入，但已在一些 Linux 发行版上进行了回移，你可以从
    [这个讨论](https://oreil.ly/LjcPN) 中看到。
- en: ^([3](ch04.html#ch04fn3-marker)) These are defined in the `bpf_attach_type`
    enumerator in [*linux/bpf.h*](https://oreil.ly/AO1rc)*.*
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#ch04fn3-marker)) 这些在 [*linux/bpf.h*](https://oreil.ly/AO1rc)*.*
    中的 `bpf_attach_type` 枚举中定义。
- en: ^([4](ch04.html#ch04fn4-marker)) A reminder that for more information on the
    difference, read Andrii Nakryiko’s [“BPF ring buffer”](https://oreil.ly/XkpUF)
    blog post.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.html#ch04fn4-marker)) 提醒你，如果想了解更多差异的信息，请阅读安德烈·纳克里科的 [“BPF 环形缓冲区”](https://oreil.ly/XkpUF)
    博客文章。
