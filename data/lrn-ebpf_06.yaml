- en: Chapter 6\. The eBPF Verifier
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。eBPF验证器
- en: I’ve mentioned the verification step a few times, so you already know that when
    you load an eBPF program into the kernel, this verification process ensures that
    the program is safe. In this chapter we’ll dive into how the verifier works to
    achieve this goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到验证步骤，所以你已经知道当你将eBPF程序加载到内核时，这个验证过程确保程序是安全的。在本章中，我们将深入探讨验证器如何工作以实现这一目标。
- en: Verification involves checking every possible execution path through the program
    and ensuring that every instruction is safe. The verifier also makes some updates
    to the bytecode to ready it for execution. In this chapter I’ll show some examples
    of verification failures, by starting from an example that works and making modifications
    that render that code invalid to the verifier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 验证涉及检查程序的每个可能的执行路径，并确保每条指令都是安全的。验证器还对字节码进行一些更新，以准备执行。在本章中，我将展示一些验证失败的例子，从一个有效的示例开始，逐步进行修改，使该代码对验证器无效。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The example code for this chapter is in the *chapter6* directory of the repository
    at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于存储库的*chapter6*目录中，该存储库位于[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)。
- en: This chapter doesn’t attempt to cover every possible check the verifier makes.
    It’s intended to be an overview, with illustrative examples that will help you
    deal with verification errors that you might run into when writing your own eBPF
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不试图涵盖验证器进行的每一种可能的检查。它旨在提供一个概述，具有说明性的例子，这些例子将帮助您处理编写自己的eBPF代码时可能遇到的验证错误。
- en: One thing to bear in mind is that the verifier works on eBPF bytecode, not directly
    on the source. That bytecode depends on the output from the compiler. Because
    of things like compiler optimization, a change in the source code might not always
    result in exactly what you expect in the bytecode, so correspondingly it might
    not give you the result you expect in the verifier’s verdict. For example, the
    verifier will reject unreachable instructions, but the compiler might optimize
    them away before the verifier sees them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，验证器在eBPF字节码上工作，而不是直接在源代码上工作。该字节码依赖于编译器的输出。由于编译器优化等因素，源代码的更改可能不会始终产生您在字节码中期望的结果，因此相应地，它可能不会给您验证器的预期结果。例如，验证器将拒绝不可达的指令，但编译器在验证器看到它们之前可能会将它们优化掉。
- en: The Verification Process
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证过程
- en: 'The verifier analyzes the program to assess all possible execution paths. It
    steps through the instructions in order, evaluating them rather than actually
    executing them. As it goes along it keeps track of the state of each register
    in a structure called `bpf_reg_state`. (The registers I’m referring to here are
    the registers from the eBPF virtual machine that you met in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).)
    This structure includes a field called `bpf_reg_type`, which describes what type
    of value is held in that register. There are several possible types, including
    these:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器分析程序以评估所有可能的执行路径。它按顺序逐步执行指令，评估而非实际执行它们。在执行过程中，它通过一种称为`bpf_reg_state`的结构来跟踪每个寄存器的状态。（这里提到的寄存器是指你在[第三章](ch03.html#anatomy_of_an_ebpf_program)中遇到的eBPF虚拟机的寄存器。）该结构包括一个称为`bpf_reg_type`的字段，描述该寄存器中保存的值的类型。有几种可能的类型，包括以下几种：
- en: '`NOT_INIT`, indicating that the register has not yet been set to a value.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT_INIT`，表示寄存器尚未被设置为值。'
- en: '`SCALAR_VALUE`, indicating that the register has been set to a value that doesn’t
    represent a pointer.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCALAR_VALUE`，表示寄存器被设置为不表示指针的值。'
- en: 'Several `PTR_TO_*` types, indicating that the register holds a pointer to something.
    That something could be, for example:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种`PTR_TO_*`类型，指示寄存器保存指向某物的指针。例如：
- en: '`PTR_TO_CTX`: The register holds a pointer to the context passed as the argument
    to a BPF program.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTR_TO_CTX`：寄存器保存指向传递给BPF程序的上下文的指针。'
- en: '`PTR_TO_PACKET`: The register points to a network packet (held in the kernel
    as `skb->data`).'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTR_TO_PACKET`：寄存器指向网络数据包（在内核中作为`skb->data`保存）。'
- en: '`PTR_TO_MAP_KEY` or `PTR_TO_MAP_VALUE`: I’m sure you can guess what these mean.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTR_TO_MAP_KEY`或`PTR_TO_MAP_VALUE`：我相信你可以猜到这些是什么意思。'
- en: There are several other `PTR_TO_*` types, and you can find the full set enumerated
    in the [*linux/bpf.h* header file](https://oreil.ly/aWb50).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种`PTR_TO_*`类型，你可以在[*linux/bpf.h*头文件](https://oreil.ly/aWb50)中找到完整的枚举集合。
- en: The `bpf_reg_state` structure also keeps track of the range of possible values
    the register might hold. This information is used by the verifier to determine
    when invalid actions are being attempted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpf_reg_state`结构还跟踪寄存器可能持有的可能值范围。验证器利用这些信息来确定是否正在尝试无效操作。'
- en: Each time the verifier comes to a branch, where a decision has to be made on
    whether to carry on in sequence or jump to a different instruction, the verifier
    pushes a copy of the current state of all the registers onto a stack and explores
    one of the possible paths. It continues evaluating the instructions until it reaches
    the return at the end of the program (or reaches the limit on the number of instructions
    it will process, which is currently one million instructions^([1](ch06.html#ch06fn1))),
    at which point it pops a branch off the stack to evaluate next. If it finds an
    instruction that could result in an invalid operation, it fails verification.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每当验证器遇到一个分支时，在这里需要决定是按顺序继续还是跳转到不同的指令时，验证器都会将当前所有寄存器的当前状态复制推送到堆栈上，并探索其中一条可能的路径。它继续评估指令，直到达到程序末尾的返回指令（或达到它将处理的指令数限制，当前为一百万条指令^([1](ch06.html#ch06fn1))），然后弹出堆栈上的分支以评估下一个。如果找到可能导致无效操作的指令，则验证失败。
- en: Verifying every single possibility could get computationally expensive, so in
    practice there are optimizations called *state pruning* that avoid reevaluating
    paths through the program that are essentially equivalent. As it works through
    the program, the verifier records the state of all the registers at certain instructions
    within the program. If it later arrives at the same instruction with registers
    in a matching state, there is no need to continue to verify the rest of that path,
    as it’s already known to be valid.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 验证每一种可能性都可能导致计算成本过高，因此在实践中有称为*状态修剪*的优化方法，它避免重新评估程序中实质上等效的路径。当验证器通过程序时，在程序的某些指令处记录所有寄存器的状态。如果它后来再次到达相同的指令，并且寄存器处于匹配状态，那么就没有必要继续验证该路径的其余部分，因为已知其有效。
- en: '[Lots of work has gone into optimizing the verifier](https://oreil.ly/pQDES)
    and its pruning process. The verifier used to store pruning state before and after
    each jump instruction, but analysis showed that this results in storing state
    on average every four instructions or so, and the vast majority of these pruning
    states would never get matched. It turned out that it’s more efficient to store
    pruning state every 10 instructions, regardless of branching.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[对验证器进行了大量的优化工作](https://oreil.ly/pQDES)以及其修剪过程。验证器以前在每个跳转指令之前和之后存储修剪状态，但分析表明，这样做导致平均每四条指令左右存储一次状态，并且绝大多数这些修剪状态都不会被匹配。结果证明，无论分支情况如何，每10条指令存储一次修剪状态更有效率。'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more details on how verification works in the [kernel documentation](https://oreil.ly/atNda).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[内核文档](https://oreil.ly/atNda)中详细了解验证工作的更多细节。
- en: The Verifier Log
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证器日志
- en: When the verification of a program fails, the verifier generates a log showing
    how it reached the conclusion that the program is invalid. If you’re using `bpftool
    prog load`, the verifier log gets output to stderr. When you’re writing a program
    with *libbpf*, you can use the function `libbpf_set_print()` to set a handler
    that will display (or do something else useful with) any errors. (You’ll see an
    example of this in the *hello-verifier.c* source code for this chapter.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序的验证失败时，验证器会生成一个日志，显示它是如何得出程序无效的结论的。如果您使用`bpftool prog load`，则验证器日志将输出到stderr。当您使用*libbpf*编写程序时，可以使用函数`libbpf_set_print()`设置一个处理程序，它将显示（或执行其他有用的操作）任何错误。（您将在本章的*hello-verifier.c*源代码中看到此示例。）
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you really want to dig into what the verifier is doing, you can get it to
    generate the log on success as well as on failure. There is a basic example of
    this in the *hello-verifier.c* file too. It involves passing a buffer that will
    hold verifier log contents into the *libbpf* call that loads the program into
    the kernel and then writing the contents of that log to screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想深入了解验证器的工作原理，您可以要求它在成功和失败时生成日志。在*hello-verifier.c*文件中也有一个基本的示例。它涉及将用于保存验证器日志内容的缓冲区传递到加载程序到内核的*libbpf*调用中，然后将该日志的内容写入屏幕。
- en: 'The verifier log includes a summary of how much work the verifier did, which
    looks something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器日志包含验证器执行的工作量摘要，类似于以下内容：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the verifier processed 61 instructions, including potentially
    processing the same instruction multiple times by arriving at it through different
    paths. Note that the complexity limit of one million is an upper bound on the
    number of instructions in a program; in practice, if there are branches in the
    code, the verifier will process some instructions more than once.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，验证器处理了61条指令，可能通过不同的路径多次处理了同一条指令。请注意，100万的复杂性限制是程序中指令数量的上限；实际上，如果代码中有分支，验证器将多次处理某些指令。
- en: The total number of states stored was four, which for this simple program matches
    the peak number of stored states. If some of the states had been pruned, the peak
    number might be lower than the total.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的总状态数为四，对于这个简单的程序来说，这与存储状态的峰值数量匹配。如果某些状态被剪枝了，峰值数量可能会低于总数。
- en: 'The log output includes the BPF instructions the verifier has analyzed, along
    with the corresponding C source code lines (if the object file was built with
    the `-g` flag to include debug information) and summaries of verifier state information.
    Here is an example extract of the verifier log relating to the first few lines
    of the program in *hello-verifier.bpf.c*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 日志输出包括验证器分析的BPF指令，以及相应的C源代码行（如果目标文件使用了`-g`标志包含了调试信息），以及验证器状态信息的摘要。以下是与*hello-verifier.bpf.c*程序的前几行相关的验证器日志的示例摘录：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#code_id_6_1)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_6_1)'
- en: The log includes source code lines to make it easier to understand how the output
    relates to the source. This source code is available because the `-g` flag was
    used to build in debug information during the compilation step.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 日志包括源代码行，以便更容易理解输出与源代码的关系。这些源代码可用，因为在编译步骤中使用了`-g`标志以包含调试信息。
- en: '[![2](assets/2.png)](#code_id_6_2)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_6_2)'
- en: Here’s an example of some register state information being output in the log.
    It tells us that at this stage Register 1 contains a map value, Register 6 holds
    the context, and Register 10 is the frame (or stack) pointer where local variables
    are held.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是日志中输出的一些寄存器状态信息的示例。它告诉我们，在这个阶段，寄存器1包含一个映射值，寄存器6保存上下文，寄存器10是帧（或堆栈）指针，用于保存局部变量。
- en: '[![3](assets/3.png)](#code_id_6_3)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_6_3)'
- en: This is another example of register state information. Here you can see not
    only the types of values that are held in each (initialized) register, but also
    the range of possible values for Register 2 and Register 3.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是寄存器状态信息的另一个例子。在这里，您不仅可以看到每个（初始化的）寄存器中保存的值的类型，还可以看到寄存器2和寄存器3可能值的范围。
- en: Let’s dig further into the details of this. I said that Register 6 holds the
    context, and the verifier log indicates this with `R6_w=ctx(id=0,off=0,imm=0)`.
    This was set up in the very first line of the bytecode, where Register 1 was copied
    to Register 6\. When an eBPF program is called, Register 1 always holds the context
    argument passed to the program. Why copy it to Register 6? Well, when a BPF helper
    function is called, the arguments to that call are passed in Registers 1 through
    5\. Helper functions don’t modify the contents of Registers 6 through 9, so saving
    the context off into Register 6 means the code can call a helper function without
    losing access to the context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这一点的详细信息。我说寄存器6保存上下文，验证器日志通过`R6_w=ctx(id=0,off=0,imm=0)`表示了这一点。这是在字节码的第一行中设置的，其中寄存器1被复制到寄存器6。当调用eBPF程序时，寄存器1始终保存传递给程序的上下文参数。为什么将其复制到寄存器6？嗯，当调用BPF助手函数时，该调用的参数通过寄存器1到5传递。助手函数不会修改寄存器6到9的内容，因此将上下文保存到寄存器6意味着代码可以调用助手函数而不会失去对上下文的访问。
- en: Register 0 is used for the return value from a helper function and also for
    the return value from an eBPF program. Register 10 always holds a pointer to the
    eBPF stack frame (and the eBPF program can’t modify it).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器0用于助手函数的返回值，也用于eBPF程序的返回值。寄存器10始终保存指向eBPF堆栈帧的指针（eBPF程序不能修改它）。
- en: 'Let’s look at the register state information for Registers 2 and 3 after instruction
    6:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第6条指令后寄存器2和寄存器3的寄存器状态信息：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Register 2 doesn’t have a minimum value, and the `umax_value` shown here in
    decimal corresponds to 0xFFFFFFFF, which is the largest value that can be held
    in an 8-byte register. In other words, at this point the register could hold any
    of its possible values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器2没有最小值，这里显示的`umax_value`对应于十进制的0xFFFFFFFF，这是可以存储在8字节寄存器中的最大值。换句话说，在这一点上，寄存器可以存储任何可能的值。
- en: In instruction 4, the contents of Register 2 are copied into Register 3, and
    then instruction 5 adds one to that value. Therefore, Register 3 could have any
    value that’s 1 or greater. You can see this in the state information for Register
    3, which has `umin_value` set to `1`, and a `umax_value` of `0xFFFFFFFF`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令4中，将寄存器2的内容复制到寄存器3，然后指令5对该值加1。因此，寄存器3的值可以是任何大于1的值。您可以在寄存器3的状态信息中看到这一点，其中`umin_value`设为`1`，而`umax_value`为`0xFFFFFFFF`。
- en: 'The verifier uses the information about not just the states of each register,
    but also the range of values each can contain, to determine the possible paths
    through the program. This is also used for the state pruning that I mentioned
    before: if the verifier has been in the same position in the code, with the same
    types and possible ranges of values for each register, there’s no need to evaluate
    this path further. What’s more, if the current state is a subset of a state that
    was seen earlier, it can also be pruned.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器使用有关每个寄存器的状态以及每个寄存器可能包含的值范围的信息，以确定程序的可能路径。这也用于我之前提到的状态修剪：如果验证器在代码中的同一位置，具有相同类型和每个寄存器可能值范围的状态，则无需进一步评估此路径。此外，如果当前状态是稍早前看到的状态的子集，则也可以进行修剪。
- en: Visualizing Control Flow
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化控制流
- en: 'The verifier explores all the possible paths through the eBPF program, and
    if you’re trying to debug an issue, it can be helpful to see those paths for yourself.
    The `bpftool` utility can help with this by producing a control flow graph of
    the program in [DOT format](https://oreil.ly/V-1WN), which you can then convert
    into an image format, like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器探索eBPF程序的所有可能路径，如果您试图调试问题，查看这些路径对自己会有帮助。`bpftool`实用程序可以帮助您通过生成程序的DOT格式的控制流图，然后将其转换为图像格式，如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This produces a visual representation of the control flow like that shown in
    [Figure 6-1](#extract_from_control_flow_graph_left_pa).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了一个类似[图6-1](#extract_from_control_flow_graph_left_pa)所示的控制流的可视化表示。
- en: '![Extract from control flow graph (the full image can be found as chapter6/kprobe_exec.png
    in the GitHub repo for this book)](assets/lebp_0601.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![控制流图中的剪辑（完整图像可在该书的 GitHub 仓库的 chapter6/kprobe_exec.png 找到）](assets/lebp_0601.png)'
- en: Figure 6-1\. Extract from control flow graph (the full image can be found as
    chapter6/kprobe_exec.png in the [GitHub repo](http://github.com/lizrice/learning-ebpf)
    for this book)
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 控制流图中的剪辑（完整图像可在该书的[GitHub 仓库](http://github.com/lizrice/learning-ebpf)的
    chapter6/kprobe_exec.png 找到）
- en: Validating Helper Functions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证助手函数的有效性
- en: You’re not allowed to call directly from eBPF programs to any kernel function
    (unless it has been registered as a kfunc, which you’ll meet in the next chapter),
    but eBPF provides a number of helper functions that enable programs to access
    information from the kernel. There’s a [bpf-helpers manpage](https://oreil.ly/pdLGW)
    that attempts to document them all.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许从eBPF程序直接调用任何内核函数（除非已将其注册为kfunc，您将在下一章中了解到），但是eBPF提供了许多助手函数，使程序能够从内核中访问信息。有一个[bpf-helpers
    手册页](https://oreil.ly/pdLGW)试图记录所有这些函数。
- en: 'Different helper functions are valid for different BPF program types. For example,
    the helper function `bpf_get_current_pid_tgid()` retrieves the current user space
    process ID and thread ID, but it doesn’t make sense to call this from an XDP program
    that is triggered by the receipt of a packet at a network interface, because there
    is no user space process involved. You can see an example of this by changing
    the `SEC()` definition for the *hello* eBPF program in *hello-verifier.bpf.c*
    from `kprobe` to `xdp`. On attempting to load this program the verifier output
    gives the following message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的助手函数适用于不同的BPF程序类型。例如，助手函数`bpf_get_current_pid_tgid()`用于获取当前用户空间的进程ID和线程ID，但是从由网络接口接收数据包触发的XDP程序中调用此函数是没有意义的，因为这里没有涉及到用户空间进程。您可以通过将*hello*
    eBPF程序中的`SEC()`定义从`kprobe`改为`xdp`来看到这个示例。尝试加载该程序时，验证器的输出会给出以下消息：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `unknown func` doesn’t mean the function is completely unknown, just that
    it is unknown *for this BPF program type*. (BPF program types are a topic for
    the next chapter; for now you can just think of them as being programs that are
    suitable for attaching to different types of event.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown func`并不意味着该函数完全未知，而只是在*此BPF程序类型*中未知。 （BPF程序类型是下一章的一个话题；目前，您可以将它们视为适合附加到不同类型事件的程序。）'
- en: Helper Function Arguments
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 助手函数参数
- en: 'If you look, for example, in [*kernel/bpf/helpers.c*](https://oreil.ly/tjjVR),^([2](ch06.html#ch06fn2))
    you’ll find that each helper function has a `bpf_func_proto` structure similar
    to this example for the helper function `bpf_map_lookup_elem()`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您查看[*kernel/bpf/helpers.c*](https://oreil.ly/tjjVR)^([2](ch06.html#ch06fn2))，您会发现每个助手函数都有类似于此示例中`bpf_map_lookup_elem()`助手函数的`bpf_func_proto`结构：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This structure defines the constraints for arguments to and return values from
    the helper function. Because the verifier is keeping track of the type of value
    held in each register, it can spot if you try to pass the wrong kind of argument
    to a helper function. For example, try changing the argument to the call to `bpf_map_lookup_elem()`
    in the *hello* program, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构定义了向助手函数传递的参数和返回值的约束条件。由于验证器跟踪每个寄存器中保存的值的类型，它可以发现您尝试向助手函数`bpf_map_lookup_elem()`调用中传递错误类型的参数。例如，尝试更改*hello*程序中对`bpf_map_lookup_elem()`调用的参数，如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Instead of passing `&my_config`, which is a pointer to a map, this now passes
    `&data`, which is a pointer to a local variable structure. This is valid from
    the compiler’s point of view, so you can build the BPF object file *hello-verifier.bpf.o*,
    but when you try to load the program into the kernel, you’ll see an error like
    this in the verifier log:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再传递指向映射的指针`&my_config`，而是传递了指向本地变量结构的指针`&data`。从编译器的角度来看，这是有效的，因此可以构建BPF对象文件*hello-verifier.bpf.o*，但当您尝试将程序加载到内核时，您会在验证器日志中看到如下错误：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `fp` stands for *frame pointer*, and it’s the area of memory on the stack
    where local variables are stored. Register 1 was loaded with the address of the
    local variable called `data`, but the function expects a pointer to a map (as
    indicated by the `arg1_type` field in the `bpf_func_proto` structure shown earlier).
    By tracking the types of value stored in each register, the verifier was able
    to spot this discrepancy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fp`代表*帧指针*，它是存储本地变量的堆栈内存区域。寄存器 1 装载了名为`data`的本地变量的地址，但函数期望一个指向映射的指针（如前面`bpf_func_proto`结构的`arg1_type`字段所示）。通过跟踪每个寄存器中存储的值的类型，验证器能够发现这种差异。
- en: Checking the License
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查许可证
- en: 'The verifier also checks that if you are using a BPF helper function that’s
    licensed under GPL, your program also has a GPL-compatible license. The last line
    in the [Chapter 6](#the_ebpf_verifier) example code *hello-verifier.bpf.c* defines
    a “license” section that holds the string `Dual BSD/GPL`. If you remove this line,
    the output from the verifier will end like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器还检查，如果您使用了GPL许可的BPF助手函数，您的程序也必须具有GPL兼容的许可证。在*hello-verifier.bpf.c*的第六章的最后一行定义了一个“license”部分，其中包含字符串`Dual
    BSD/GPL`。如果您删除此行，则验证器的输出将以如下方式结束：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s because the `gpl_only` field is set to `true` for the `bpf_probe_read_kernel()`
    helper function. There are other helper functions called earlier in this eBPF
    program, but they are not GPL licensed, so the verifier doesn’t object to their
    use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`bpf_probe_read_kernel()`助手函数的`gpl_only`字段设置为`true`。在此eBPF程序中早些时候调用了其他助手函数，但它们没有GPL许可证，因此验证器不会反对它们的使用。
- en: The BCC project maintains a [list of helper functions](https://oreil.ly/mCpvB),
    indicating whether they are GPL licensed or not. If you’re interested in more
    details on how helper functions are implemented, there’s a section on this in
    the [BPF and XDP reference guide](https://oreil.ly/kVd6j).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: BCC项目维护着一个[助手函数列表](https://oreil.ly/mCpvB)，指示它们是否具有GPL许可证。如果您对助手函数的实现细节更感兴趣，可以在[BPF和XDP参考指南](https://oreil.ly/kVd6j)中的相关部分找到更多详细信息。
- en: Checking Memory Access
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查内存访问
- en: The verifier performs a number of checks to make sure BPF programs only access
    memory they are supposed to have access to.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器执行多个检查，以确保BPF程序只能访问它们应该访问的内存。
- en: 'For example, when processing a network packet, an XDP program is only permitted
    to access the memory locations that make up that network packet. Most XDP programs
    start with something very similar to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在处理网络数据包时，XDP程序只允许访问构成该网络数据包的内存位置。大多数XDP程序从以下非常相似的内容开始：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `xdp_md` structure passed as the context to the program describes the network
    packet that has been received. The `ctx->data` field within that structure is
    the location in memory where the packet starts, and `ctx->data_end` is the last
    location in the packet. The verifier will ensure that the program doesn’t exceed
    these bounds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`xdp_md` 结构体作为上下文传递给程序，描述了接收到的网络数据包。该结构体内的 `ctx->data` 字段是数据包开始的内存位置，而 `ctx->data_end`
    是数据包的最后位置。验证器将确保程序不会超出这些边界。'
- en: 'For example, the following program in *hello_verifier.bpf.c* is valid:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 *hello_verifier.bpf.c* 中的以下程序是有效的：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The variables `data` and `data_end` are very similar, but the verifier is smart
    enough to recognize that `data_end` relates to the end of a packet. Your program
    is required to check that any values read from the packet aren’t from beyond that
    location, and it won’t let you “cheat” by modifying the `data_end` value. Try
    adding the following line just before the `bpf_printk()` call:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `data` 和 `data_end` 非常相似，但验证器足够智能，能识别 `data_end` 关联到数据包的末端。你的程序需要检查从数据包读取的任何值是否超出该位置，并且它不允许通过修改
    `data_end` 的值来“作弊”。尝试在 `bpf_printk()` 调用之前添加以下行：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The verifier will complain, like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器会报错，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In another example, when accessing an array you need to make sure there’s no
    possibility of accessing an index that is beyond the bounds of that array. In
    the example code there is a section that reads a character out of the `message`
    array, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例中，在访问数组时，你需要确保不会访问超出数组边界的索引。在示例代码中有一段代码从 `message` 数组中读取字符，如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is fine because of the explicit check to ensure that the counter variable
    `c` is no bigger than the size of the message array. Making a simple “off by one”
    error like the following renders it invalid:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是没问题的，因为有显式检查确保计数变量 `c` 不会超过消息数组的大小。而像下面这样的简单“差一”的错误会使其无效：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The verifier will fail this with an error message similar to this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器将以类似以下的错误消息失败：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It’s fairly clear from this message that there is an invalid access to a map
    value because Register 2 might hold a value that’s too large for indexing the
    map. If you were debugging this error, you’d want to dig into the log to see what
    line in the source code was responsible. The log ends like this just before emitting
    the error message (I have removed some of the state information for clarity):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从这条消息很明显可以看出，由于寄存器 2 可能保存一个对地图索引过大的值，导致对地图值的无效访问。如果你正在调试此错误，你需要深入日志，查看源代码中哪一行负责这个错误。日志在发出错误消息前如下结束（为了清晰起见，我已删除部分状态信息）：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#code_id_6_6)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_6_6)'
- en: Working backward from the error, the last register state information shows that
    Register 2 could have a maximum value of `12`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误处回溯，最后的寄存器状态信息显示寄存器 2 的最大值可能是 `12`。
- en: '[![2](assets/2.png)](#code_id_6_5)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_6_5)'
- en: At instruction 31, Register 2 is set to an address in memory and then is incremented
    by the value of Register 1\. The output shows that this corresponds to the line
    of code accessing `message[c]`, so it stands to reason that Register 2 is set
    to point to the message array and then to be incremented by the value of `c`,
    which is held in the Register 1 register.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 31 指令处，寄存器 2 被设置为内存中的一个地址，然后按寄存器 1 的值递增。输出显示这对应于访问 `message[c]` 的代码行，因此合理推测寄存器
    2 被设置为指向消息数组，然后按寄存器 1 中的 `c` 值递增。
- en: '[![3](assets/3.png)](#code_id_6_4)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_6_4)'
- en: Working further back to find the value of Register 1, the log shows that it
    has a maximum value of `12` (which is hex 0x0c). However, `message` is defined
    as a 12-byte character array, so only indexes 0 through 11 are within its bounds.
    From this, you can see that the error springs from the source code testing for
    `c <= sizeof(message)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查找寄存器 1 的值，日志显示其最大值为 `12`（即十六进制的 `0x0c`）。然而，`message` 被定义为一个 12 字节的字符数组，因此只有索引
    0 到 11 在其范围内。由此可见，错误来自于源代码中测试 `c <= sizeof(message)`。
- en: At step 2, I have inferred the relationship between some registers and the source
    code variables they represent, from the lines of source code the verifier has
    helpfully included in the log. You could work back through the verifier log to
    check that this is true, and indeed you might have to if the code was compiled
    without debug information. Given the debug information is present, it makes sense
    to use it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 步，我已经从验证器包含在日志中的源代码行中推断了一些寄存器与它们表示的源代码变量之间的关系。如果代码是没有调试信息编译的，您可能需要通过验证器日志来检查这一点。鉴于存在调试信息，使用它是有意义的。
- en: The `message` array is declared as a global variable, and you might recall from
    [Chapter 3](ch03.html#anatomy_of_an_ebpf_program) that global variables are implemented
    using maps. This explains why the error message talks about “invalid access to
    a map value.”
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`message` 数组声明为全局变量，您可能还记得来自 [第 3 章](ch03.html#anatomy_of_an_ebpf_program)
    的全局变量是使用映射实现的。这解释了为什么错误消息提到“无效访问映射值”。'
- en: Checking Pointers Before Dereferencing Them
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在解引用指针之前检查指针
- en: One easy way to make a C program crash is to dereference a pointer when the
    pointer has a zero value (also known as *null*). Pointers indicate where in memory
    a value is being held, and zero is not a valid memory location. The eBPF verifier
    requires all pointers to be checked before they are dereferenced so that this
    type of crash can’t happen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个让 C 程序崩溃的简单方法是在指针的值为零（也称为*null*）时解引用指针。指针指示内存中值的位置，而零不是有效的内存位置。eBPF 验证器要求在解引用指针之前检查所有指针，以防止这种崩溃发生。
- en: 'The example code in *hello-verifier.bpf.c* looks for a custom message that
    might exist in the `my_config` hash table map for a user, with the following line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello-verifier.bpf.c* 中的示例代码寻找可能存在于 `my_config` 散列表映射中的自定义消息，代码如下：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If there’s no entry in this map corresponding to `uid`, this will set `p` (which
    is a pointer to the message structure `msg_t`) to zero. Here’s a little bit of
    additional code that attempts to dereference this potentially null pointer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有与 `uid` 对应的条目，则将 `p`（指向消息结构 `msg_t` 的指针）设置为零。这里有一小段额外的代码，试图解引用这个可能为空的指针：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This compiles fine, but the verifier rejects it as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译，但验证器会拒绝如下：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#code_id_6_7)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_6_7)'
- en: The return value from a helper function call gets stored in Register 0\. Here,
    that value is being stored in Register 7\. This means Register 7 now holds the
    value of the local variable `p`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数调用的返回值存储在寄存器 0 中。在这里，该值被存储在寄存器 7 中。这意味着寄存器 7 现在保存了局部变量 `p` 的值。
- en: '[![2](assets/2.png)](#code_id_6_8)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_6_8)'
- en: This instruction attempts to dereference the pointer value `p`. The verifier
    has been keeping track of the state of Register 7 and knows that it may hold a
    pointer to a map value, or it might be null.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令尝试解引用指针值 `p`。验证器一直跟踪寄存器 7 的状态，并知道它可能保存指向映射值的指针，或者可能为空。
- en: 'The verifier rejects this attempt to dereference a null pointer, but the program
    will pass if there is an explicit check, like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器会拒绝尝试解引用空指针的尝试，但如果有显式检查，例如：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Some helper functions incorporate the pointer check for you. For example, if
    you look at the manpage for bpf-helpers, you’ll find the function signature for
    `bpf_probe_read_kernel()` is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些辅助函数会为您集成指针检查。例如，如果您查看 bpf-helpers 的 man 页面，您将找到 `bpf_probe_read_kernel()`
    的函数签名如下：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The third argument to this function is called `unsafe_ptr`. This is an example
    of a BPF helper function that helps programmers write safe code by handling checks
    for you. You’re allowed to pass a potentially null pointer—but only as the third
    argument called `unsafe_ptr`—and the helper function will check that it’s not
    null before attempting to deference it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的第三个参数称为 `unsafe_ptr`。这是一个 BPF 辅助函数的示例，通过为您处理检查，帮助程序员编写安全代码。您可以传递一个潜在的空指针，但只能作为名为
    `unsafe_ptr` 的第三个参数，并且在尝试解引用之前，辅助函数会检查它不为空。
- en: Accessing Context
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问上下文
- en: Every eBPF program is passed some context information as an argument, but depending
    on the program and attachment type, it may be allowed to access only some of that
    context information. For example, [tracepoint programs](https://oreil.ly/6RFFI)
    receive a pointer to some tracepoint data. The format of that data depends on
    the particular tracepoint, but they all start with some common fields—yet those
    common fields are not accessible to eBPF programs. Only the tracepoint-specific
    fields that follow can be accessed. Attempting to read or write the wrong fields
    leads to an `invalid bpf_context access` error. There is an example of this in
    the exercises at the end of this chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 eBPF 程序作为参数传递一些上下文信息，但根据程序和附加类型的不同，可能只允许访问其中的一部分上下文信息。例如，[跟踪点程序](https://oreil.ly/6RFFI)
    接收一个指向某些跟踪点数据的指针。该数据的格式取决于特定的跟踪点，但它们都以一些共同字段开头——然而，这些共同字段对 eBPF 程序是不可访问的。只能访问后续的特定于跟踪点的字段。试图读取或写入错误的字段会导致
    `invalid bpf_context access` 错误。本章末尾的练习中有一个例子。
- en: Running to Completion
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行至完成
- en: The verifier ensures that the eBPF program will run to completion; otherwise,
    there is a risk that it might consume resources indefinitely. It does this by
    having a limit on the total number of instructions that it will process, which,
    as I mentioned earlier, is set at one million instructions at the time of this
    writing. That limit is [hard-coded into the kernel](https://oreil.ly/IucYm); it’s
    not a configurable option. If the verifier hasn’t reached the end of the BPF program
    before it has processed this many instructions, it rejects the program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器确保 eBPF 程序能够完成运行；否则，可能会无限消耗资源。为了达到这个目的，它限制了它将处理的总指令数，就像我之前提到的，在撰写本文时设定为一百万条指令。这个限制是
    [硬编码进内核](https://oreil.ly/IucYm) 的，不是一个可配置的选项。如果验证器在处理这么多指令之前未到达 BPF 程序的末尾，则会拒绝该程序。
- en: One easy way to create a program that never completes is to write a loop that
    never ends. Let’s see how loops can be created in eBPF programs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个永不完成的程序的简单方法是编写一个永不结束的循环。让我们看看如何在 eBPF 程序中创建循环。
- en: Loops
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: To guarantee completion, until kernel version 5.3 there was a restriction on
    loops.^([3](ch06.html#ch06fn3)) Looping through the same instructions requires
    a jump backward to earlier instructions, and it used to be the case that the verifier
    would not permit this. eBPF programmers worked around this by using the `#pragma
    unroll` compiler directive to tell the compiler to write out a set of identical
    (or very similar) bytecode instructions for each time around the loop. This saved
    the programmer typing in the same lines many times, but you would see repeated
    instructions in the emitted bytecode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证完成，直到内核版本 5.3，对循环有一个限制。[^3] 循环通过相同的指令需要向后跳转到较早的指令，过去验证器不允许这种情况发生。eBPF 程序员通过使用
    `#pragma unroll` 编译器指令来绕过此问题，告诉编译器为每次循环写出一组相同（或非常相似）的字节码指令。这样节省了程序员重复输入相同代码的时间，但在生成的字节码中会看到重复的指令。
- en: From version 5.3 onward the verifier follows branches backward as well as forward
    as part of its process of checking all the possible execution paths. This means
    it can accept some loops, provided the execution path remains within the limit
    of one million instructions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从 5.3 版本开始，验证器在检查所有可能的执行路径时向后跟随分支，而不仅仅是向前。这意味着它可以接受一些循环，只要执行路径保持在一百万条指令的限制内。
- en: 'You can see an example of a loop in the example *xdp_hello* program. A version
    of the loop that passes verification looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在示例 *xdp_hello* 程序中看到一个循环的示例。通过验证的循环版本看起来像这样：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The (successful) verifier log will show that it has followed the execution path
    around this loop 10 times. In doing so, it doesn’t hit the complexity limit of
    one million instructions. In the exercises for this chapter, there’s another version
    of this loop that will hit that limit and will fail verification.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: （成功的）验证器日志将显示它已经围绕此循环执行路径 10 次。通过这样做，它不会达到一百万条指令的复杂性限制。在本章的练习中，还有另一个版本的循环将达到该限制并且无法通过验证。
- en: In version 5.17 a new helper function, `bpf_loop()`, was introduced that makes
    it much easier for the verifier not only to accept loops but also to do it in
    a much more efficient way. This helper takes the maximum number of iterations
    as its first argument, and it is also passed a function that is called for each
    iteration. The verifier only has to validate the BPF instructions in that function
    once, however many times it might be called. That function can return a nonzero
    value to indicate that there is no need to call it again, which is used to terminate
    a loop early once the desired result is achieved.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本5.17中引入了一个新的助手函数`bpf_loop()`，它使得验证器不仅更容易接受循环，而且以更高效的方式执行。这个助手函数以其第一个参数作为最大迭代次数，并传递一个在每次迭代中调用的函数。验证器只需验证该函数中的BPF指令一次，无论它可能被调用多少次。该函数可以返回一个非零值，以指示无需再次调用它，这用于在达到所需结果后提前终止循环。
- en: There’s also a helper function [`bpf_for_each_map_elem()`](https://oreil.ly/Yg_oQ)
    that calls a provided callback function for each item in a map.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个助手函数[`bpf_for_each_map_elem()`](https://oreil.ly/Yg_oQ)，它调用映射中每个项目的提供的回调函数。
- en: Checking the Return Code
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查返回代码
- en: 'The return code from an eBPF program is stored in Register 0 (`R0`). If the
    program leaves `R0` uninitialized, the verifier will fail, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序的返回代码存储在寄存器0（`R0`）中。如果程序离开`R0`未初始化，验证器会失败，就像这样：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can try this by commenting out all the code in a function; for example,
    modify the `xdp_hello` example to be like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过注释掉一个函数中的所有代码来尝试这个功能；例如，将`xdp_hello`示例修改如下：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will fail the verifier. However, if you put the line with the helper function
    `bpf_printf()` back in, the verifier won’t complain, even though there’s no explicit
    return value set by the source code!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致验证器失败。然而，如果你把含有助手函数`bpf_printf()`的行放回去，验证器就不会抱怨，即使源代码中没有明确的返回值设置！
- en: This is because Register 0 is also used to hold the return code from a helper
    function. After returning from a helper function in an eBPF program, Register
    0 is no longer uninitialized.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为寄存器0还用于保存来自助手函数的返回代码。从eBPF程序的助手函数返回后，寄存器0不再是未初始化的。
- en: Invalid Instructions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无效指令
- en: As you know from the discussion of the eBPF (virtual) machine in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    eBPF programs consist of a set of bytecode instructions. The verifier checks that
    the instructions in a program are valid bytecode instructions—for example, using
    only known opcodes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从第[3章](ch03.html#anatomy_of_an_ebpf_program)中对eBPF（虚拟）机器的讨论中了解到的，eBPF程序由一组字节码指令组成。验证器检查程序中的指令是否是有效的字节码指令，例如，只使用已知的操作码。
- en: It would be considered a bug in the compiler if it emitted invalid bytecode,
    so you’re not likely to see this kind of verifier error unless you choose (for
    some reason best known to yourself) to write eBPF bytecode by hand. However, there
    have been some instructions added more recently, such as the atomic operations.
    If your compiled bytecode uses these instructions, they would fail verification
    on an older kernel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器生成了无效的字节码，这将被视为编译器的一个错误，因此，除非你选择（出于某种你自己知道的原因）手动编写eBPF字节码，否则你不太可能看到这种类型的验证器错误。然而，最近添加了一些指令，如原子操作。如果你的编译字节码使用这些指令，它们将在较旧的内核上验证失败。
- en: Unreachable Instructions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可达指令
- en: The verifier also rejects programs that have unreachable instructions. Oftentimes,
    these will get optimized out by the compiler anyway.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器还会拒绝具有不可达指令的程序。通常情况下，这些指令在编译器优化时会被剔除。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: When I first got interested in eBPF, getting code through the verifier seemed
    like a dark art, where seemingly valid code would get rejected, throwing up what
    seemed to be arbitrary errors. Over time there have been *lots* of improvements
    to the verifier, and in this chapter you’ve seen several examples where the verifier
    log gives hints to help you figure out what the problem is.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次对eBPF产生兴趣时，通过验证器的代码看起来像是一门黑暗艺术，看似有效的代码会被拒绝，抛出看似随意的错误。随着时间的推移，验证器有了*许多*改进，在本章中你已经看到了几个示例，验证器日志提供了帮助，帮助你找出问题所在。
- en: These hints are more helpful when you have a mental model of how the eBPF (virtual)
    machine works, using a set of registers for temporary value storage as it steps
    through an eBPF program. The verifier keeps track of the types and possible range
    of values for each register to ensure that eBPF programs are safe to run.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对 eBPF（虚拟）机器如何工作有一个心理模型时，这些提示会更有帮助，它使用一组寄存器作为临时值存储，在执行 eBPF 程序时步进。验证器跟踪每个寄存器的类型和可能的值范围，以确保
    eBPF 程序可以安全运行。
- en: If you try writing some eBPF code of your own, you might find yourself needing
    assistance to resolve verifier errors. The [eBPF community Slack channel](http://ebpf.io/slack)
    is a good place to ask for help, and lots of people have also found advice on
    [StackOverflow](https://oreil.ly/nu_0v).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编写自己的 eBPF 代码，可能会需要帮助来解决验证器错误。[eBPF 社区 Slack 频道](http://ebpf.io/slack)
    是一个寻求帮助的好地方，许多人也在 [StackOverflow](https://oreil.ly/nu_0v) 上找到了建议。
- en: Exercises
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are some more ways to cause a verifier error. See if you can correlate
    the verifier log output to the errors you get:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多导致验证器错误的方式。看看你能否将验证器日志输出与你收到的错误相关联：
- en: 'In [“Checking Memory Access”](#checking_memory_access), you saw the verifier
    rejecting access beyond the end of the global `message` array. In the example
    code there’s a section that accesses the local variable `data.message` in a similar
    way:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [“检查内存访问”](#checking_memory_access) 中，你看到验证器拒绝超出全局 `message` 数组末尾的访问。在示例代码中，有一个类似方式访问局部变量
    `data.message` 的部分：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Try adjusting the code to make the same out-by-one mistake by replacing the
    `<` with `<=`, and you’ll see an error message about `invalid variable-offset
    read from stack R2`.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试调整代码，通过用 `<=` 替换 `<` 来制造相同的越界错误，你会看到关于 `invalid variable-offset read from
    stack R2` 的错误消息。
- en: 'Find the commented-out loops in *xdp_hello* in the example code. Try adding
    in the first loop that looks like this:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例代码的 *xdp_hello* 中找到被注释掉的循环。尝试添加第一个看起来像这样的循环：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see in the verifier log a repeated series of lines that look something
    like this:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在验证器日志中看到一系列重复的类似以下内容的行：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the log, work out which register is tracking the loop variable `i`.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从日志中找出跟踪循环变量 `i` 的哪个寄存器。
- en: 'Now try adding in a loop that will fail, which looks like this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试添加一个将失败的循环，看起来像这样：
- en: '[PRE28]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should see that the verifier tries to explore this loop to its conclusion,
    but it reaches the instruction complexity limit before it completes (because there
    is no upper bound on the global variable `c`).
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到验证器尝试探索这个循环直到结束，但在完成之前达到了指令复杂性限制（因为全局变量 `c` 没有上限）。
- en: 'Write a program that attaches to a tracepoint. (You may have done this already
    for the exercises in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).)
    Looking ahead to [“Tracepoints”](ch07.html#tracepoints), you can see a structure
    definition for the context argument that starts with these fields:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个附加到跟踪点的程序。（你可能已经在 [第 4 章](ch04.html#the_bpfleft_parenthesisright_parenthesi)
    中完成了练习。）预览 [“跟踪点”](ch07.html#tracepoints) 时，你可以看到一个从这些字段开始的上下文参数的结构定义：
- en: '[PRE29]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create your own version of a structure that starts like this, and make the context
    argument in your program a pointer to this structure. In the program, try accessing
    any of these fields and see that the verifier fails with `invalid bpf_context
    access`.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个类似这样开始的结构体的版本，并使程序中的上下文参数指向这个结构体的指针。在程序中，尝试访问任何这些字段，并看到验证器因为 `invalid bpf_context
    access` 失败。
- en: ^([1](ch06.html#ch06fn1-marker)) For a long time the limit was 4,096 instructions,
    which imposed significant restrictions on the complexity of eBPF programs. This
    limit still applies to unprivileged users running BPF programs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#ch06fn1-marker)) 长期以来，指令数限制为 4,096 条，这给 eBPF 程序的复杂性带来了显著限制。对于运行
    BPF 程序的非特权用户，此限制仍然适用。
- en: ^([2](ch06.html#ch06fn2-marker)) Helper functions are also defined in some other
    places in the source code, for example, [*kernel/trace/bpf_trace.c*](https://oreil.ly/cY8y9)
    and [*net/core/filter.c*](https://oreil.ly/qww-b).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#ch06fn2-marker)) 辅助函数也在源代码的其他地方定义，例如，[*kernel/trace/bpf_trace.c*](https://oreil.ly/cY8y9)
    和 [*net/core/filter.c*](https://oreil.ly/qww-b)。
- en: ^([3](ch06.html#ch06fn3-marker)) This release brought a number of significant
    optimizations and improvements to the BPF verifier, which are summarized nicely
    in the LWN article [“Bounded loops in BPF for the 5.3 kernel”](https://oreil.ly/50BoD).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#ch06fn3-marker)) 该版本为 BPF 验证器带来了许多重要的优化和改进，这些内容在 LWN 文章 [“BPF
    在 5.3 内核中的有界循环”](https://oreil.ly/50BoD) 中有详细总结。
