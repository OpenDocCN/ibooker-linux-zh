# 第六章：eBPF 验证器

我已经多次提到验证步骤，所以你已经知道当你将 eBPF 程序加载到内核时，这个验证过程确保程序是安全的。在本章中，我们将深入探讨验证器如何工作以实现这一目标。

验证涉及检查程序的每个可能的执行路径，并确保每条指令都是安全的。验证器还对字节码进行一些更新，以准备执行。在本章中，我将展示一些验证失败的例子，从一个有效的示例开始，逐步进行修改，使该代码对验证器无效。

###### 注意

本章的示例代码位于存储库的*chapter6*目录中，该存储库位于[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)。

本章不试图涵盖验证器进行的每一种可能的检查。它旨在提供一个概述，具有说明性的例子，这些例子将帮助您处理编写自己的 eBPF 代码时可能遇到的验证错误。

需要记住的一件事是，验证器在 eBPF 字节码上工作，而不是直接在源代码上工作。该字节码依赖于编译器的输出。由于编译器优化等因素，源代码的更改可能不会始终产生您在字节码中期望的结果，因此相应地，它可能不会给您验证器的预期结果。例如，验证器将拒绝不可达的指令，但编译器在验证器看到它们之前可能会将它们优化掉。

# 验证过程

验证器分析程序以评估所有可能的执行路径。它按顺序逐步执行指令，评估而非实际执行它们。在执行过程中，它通过一种称为`bpf_reg_state`的结构来跟踪每个寄存器的状态。（这里提到的寄存器是指你在第三章中遇到的 eBPF 虚拟机的寄存器。）该结构包括一个称为`bpf_reg_type`的字段，描述该寄存器中保存的值的类型。有几种可能的类型，包括以下几种：

+   `NOT_INIT`，表示寄存器尚未被设置为值。

+   `SCALAR_VALUE`，表示寄存器被设置为不表示指针的值。

+   几种`PTR_TO_*`类型，指示寄存器保存指向某物的指针。例如：

    +   `PTR_TO_CTX`：寄存器保存指向传递给 BPF 程序的上下文的指针。

    +   `PTR_TO_PACKET`：寄存器指向网络数据包（在内核中作为`skb->data`保存）。

    +   `PTR_TO_MAP_KEY`或`PTR_TO_MAP_VALUE`：我相信你可以猜到这些是什么意思。

这里有几种`PTR_TO_*`类型，你可以在[*linux/bpf.h*头文件](https://oreil.ly/aWb50)中找到完整的枚举集合。

`bpf_reg_state`结构还跟踪寄存器可能持有的可能值范围。验证器利用这些信息来确定是否正在尝试无效操作。

每当验证器遇到一个分支时，在这里需要决定是按顺序继续还是跳转到不同的指令时，验证器都会将当前所有寄存器的当前状态复制推送到堆栈上，并探索其中一条可能的路径。它继续评估指令，直到达到程序末尾的返回指令（或达到它将处理的指令数限制，当前为一百万条指令^(1)），然后弹出堆栈上的分支以评估下一个。如果找到可能导致无效操作的指令，则验证失败。

验证每一种可能性都可能导致计算成本过高，因此在实践中有称为*状态修剪*的优化方法，它避免重新评估程序中实质上等效的路径。当验证器通过程序时，在程序的某些指令处记录所有寄存器的状态。如果它后来再次到达相同的指令，并且寄存器处于匹配状态，那么就没有必要继续验证该路径的其余部分，因为已知其有效。

[对验证器进行了大量的优化工作](https://oreil.ly/pQDES)以及其修剪过程。验证器以前在每个跳转指令之前和之后存储修剪状态，但分析表明，这样做导致平均每四条指令左右存储一次状态，并且绝大多数这些修剪状态都不会被匹配。结果证明，无论分支情况如何，每 10 条指令存储一次修剪状态更有效率。

###### 注意

您可以在[内核文档](https://oreil.ly/atNda)中详细了解验证工作的更多细节。

# 验证器日志

当程序的验证失败时，验证器会生成一个日志，显示它是如何得出程序无效的结论的。如果您使用`bpftool prog load`，则验证器日志将输出到 stderr。当您使用*libbpf*编写程序时，可以使用函数`libbpf_set_print()`设置一个处理程序，它将显示（或执行其他有用的操作）任何错误。（您将在本章的*hello-verifier.c*源代码中看到此示例。）

###### 注意

如果您真的想深入了解验证器的工作原理，您可以要求它在成功和失败时生成日志。在*hello-verifier.c*文件中也有一个基本的示例。它涉及将用于保存验证器日志内容的缓冲区传递到加载程序到内核的*libbpf*调用中，然后将该日志的内容写入屏幕。

验证器日志包含验证器执行的工作量摘要，类似于以下内容：

```
processed 61 insns (limit 1000000) max_states_per_insn 0 total_states 4
peak_states 4 mark_read 3
```

在这个示例中，验证器处理了 61 条指令，可能通过不同的路径多次处理了同一条指令。请注意，100 万的复杂性限制是程序中指令数量的上限；实际上，如果代码中有分支，验证器将多次处理某些指令。

存储的总状态数为四，对于这个简单的程序来说，这与存储状态的峰值数量匹配。如果某些状态被剪枝了，峰值数量可能会低于总数。

日志输出包括验证器分析的 BPF 指令，以及相应的 C 源代码行（如果目标文件使用了`-g`标志包含了调试信息），以及验证器状态信息的摘要。以下是与*hello-verifier.bpf.c*程序的前几行相关的验证器日志的示例摘录：

```
0: (bf) r6 = r1
; data.counter = c;                                              ![1](img/1.png)
1: (18) r1 = 0xffff800008178000
3: (61) r2 = *(u32 *)(r1 +0)
 R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=ctx(id=0,off=0,imm=0) 
 R10=fp0                                                         ![2](img/2.png)
; c++; 
4: (bf) r3 = r2
5: (07) r3 += 1
6: (63) *(u32 *)(r1 +0) = r3
 R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R2_w=inv(id=1,umax_value=4294967295,
 var_off=(0x0; 0xffffffff)) R3_w=inv(id=0,umin_value=1,umax_value=4294967296,
 var_off=(0x0; 0x1ffffffff)) R6_w=ctx(id=0,off=0,imm=0) R10=fp0  ![3](img/3.png)
```

![1](img/#code_id_6_1)

日志包括源代码行，以便更容易理解输出与源代码的关系。这些源代码可用，因为在编译步骤中使用了`-g`标志以包含调试信息。

![2](img/#code_id_6_2)

下面是日志中输出的一些寄存器状态信息的示例。它告诉我们，在这个阶段，寄存器 1 包含一个映射值，寄存器 6 保存上下文，寄存器 10 是帧（或堆栈）指针，用于保存局部变量。

![3](img/#code_id_6_3)

这是寄存器状态信息的另一个例子。在这里，您不仅可以看到每个（初始化的）寄存器中保存的值的类型，还可以看到寄存器 2 和寄存器 3 可能值的范围。

让我们进一步探讨这一点的详细信息。我说寄存器 6 保存上下文，验证器日志通过`R6_w=ctx(id=0,off=0,imm=0)`表示了这一点。这是在字节码的第一行中设置的，其中寄存器 1 被复制到寄存器 6。当调用 eBPF 程序时，寄存器 1 始终保存传递给程序的上下文参数。为什么将其复制到寄存器 6？嗯，当调用 BPF 助手函数时，该调用的参数通过寄存器 1 到 5 传递。助手函数不会修改寄存器 6 到 9 的内容，因此将上下文保存到寄存器 6 意味着代码可以调用助手函数而不会失去对上下文的访问。

寄存器 0 用于助手函数的返回值，也用于 eBPF 程序的返回值。寄存器 10 始终保存指向 eBPF 堆栈帧的指针（eBPF 程序不能修改它）。

让我们看看第 6 条指令后寄存器 2 和寄存器 3 的寄存器状态信息：

```
R2_w=inv(id=1,umax_value=4294967295,var_off=(0x0; 0xffffffff))
R3_w=inv(id=0,umin_value=1,umax_value=4294967296,var_off=(0x0; 0x1ffffffff))
```

寄存器 2 没有最小值，这里显示的`umax_value`对应于十进制的 0xFFFFFFFF，这是可以存储在 8 字节寄存器中的最大值。换句话说，在这一点上，寄存器可以存储任何可能的值。

在指令 4 中，将寄存器 2 的内容复制到寄存器 3，然后指令 5 对该值加 1。因此，寄存器 3 的值可以是任何大于 1 的值。您可以在寄存器 3 的状态信息中看到这一点，其中`umin_value`设为`1`，而`umax_value`为`0xFFFFFFFF`。

验证器使用有关每个寄存器的状态以及每个寄存器可能包含的值范围的信息，以确定程序的可能路径。这也用于我之前提到的状态修剪：如果验证器在代码中的同一位置，具有相同类型和每个寄存器可能值范围的状态，则无需进一步评估此路径。此外，如果当前状态是稍早前看到的状态的子集，则也可以进行修剪。

# 可视化控制流

验证器探索 eBPF 程序的所有可能路径，如果您试图调试问题，查看这些路径对自己会有帮助。`bpftool`实用程序可以帮助您通过生成程序的 DOT 格式的控制流图，然后将其转换为图像格式，如下所示：

```
$ bpftool prog dump xlated name kprobe_exec visual > out.dot
$ dot -Tpng out.dot > out.png
```

这产生了一个类似图 6-1 所示的控制流的可视化表示。

![控制流图中的剪辑（完整图像可在该书的 GitHub 仓库的 chapter6/kprobe_exec.png 找到）](img/lebp_0601.png)

###### 图 6-1\. 控制流图中的剪辑（完整图像可在该书的[GitHub 仓库](http://github.com/lizrice/learning-ebpf)的 chapter6/kprobe_exec.png 找到）

# 验证助手函数的有效性

不允许从 eBPF 程序直接调用任何内核函数（除非已将其注册为 kfunc，您将在下一章中了解到），但是 eBPF 提供了许多助手函数，使程序能够从内核中访问信息。有一个[bpf-helpers 手册页](https://oreil.ly/pdLGW)试图记录所有这些函数。

不同的助手函数适用于不同的 BPF 程序类型。例如，助手函数`bpf_get_current_pid_tgid()`用于获取当前用户空间的进程 ID 和线程 ID，但是从由网络接口接收数据包触发的 XDP 程序中调用此函数是没有意义的，因为这里没有涉及到用户空间进程。您可以通过将*hello* eBPF 程序中的`SEC()`定义从`kprobe`改为`xdp`来看到这个示例。尝试加载该程序时，验证器的输出会给出以下消息：

```
...
16: (85) call bpf_get_current_pid_tgid#14
unknown func bpf_get_current_pid_tgid#14
```

`unknown func`并不意味着该函数完全未知，而只是在*此 BPF 程序类型*中未知。 （BPF 程序类型是下一章的一个话题；目前，您可以将它们视为适合附加到不同类型事件的程序。）

# 助手函数参数

例如，如果您查看[*kernel/bpf/helpers.c*](https://oreil.ly/tjjVR)^(2)，您会发现每个助手函数都有类似于此示例中`bpf_map_lookup_elem()`助手函数的`bpf_func_proto`结构：

```
const struct `bpf_func_proto` `bpf_map_lookup_elem_proto` = {
    .`func`      = `bpf_map_lookup_elem`,
    .`gpl_only` = `false`,
    .`pkt_access`     = `true`,
    .`ret_type` = `RET_PTR_TO_MAP_VALUE_OR_NULL`,
    .`arg1_type` = `ARG_CONST_MAP_PTR`,
    .`arg2_type` = `ARG_PTR_TO_MAP_KEY`,
};
```

此结构定义了向助手函数传递的参数和返回值的约束条件。由于验证器跟踪每个寄存器中保存的值的类型，它可以发现您尝试向助手函数`bpf_map_lookup_elem()`调用中传递错误类型的参数。例如，尝试更改*hello*程序中对`bpf_map_lookup_elem()`调用的参数，如下所示：

```
p = bpf_map_lookup_elem(&data, &uid);
```

现在，不再传递指向映射的指针`&my_config`，而是传递了指向本地变量结构的指针`&data`。从编译器的角度来看，这是有效的，因此可以构建 BPF 对象文件*hello-verifier.bpf.o*，但当您尝试将程序加载到内核时，您会在验证器日志中看到如下错误：

```
27: (85) call bpf_map_lookup_elem#1
R1 type=fp expected=map_ptr
```

在这里，`fp`代表*帧指针*，它是存储本地变量的堆栈内存区域。寄存器 1 装载了名为`data`的本地变量的地址，但函数期望一个指向映射的指针（如前面`bpf_func_proto`结构的`arg1_type`字段所示）。通过跟踪每个寄存器中存储的值的类型，验证器能够发现这种差异。

# 检查许可证

验证器还检查，如果您使用了 GPL 许可的 BPF 助手函数，您的程序也必须具有 GPL 兼容的许可证。在*hello-verifier.bpf.c*的第六章的最后一行定义了一个“license”部分，其中包含字符串`Dual BSD/GPL`。如果您删除此行，则验证器的输出将以如下方式结束：

```
...
37: (85) call bpf_probe_read_kernel#113
cannot call GPL-restricted function from non-GPL compatible program
```

这是因为`bpf_probe_read_kernel()`助手函数的`gpl_only`字段设置为`true`。在此 eBPF 程序中早些时候调用了其他助手函数，但它们没有 GPL 许可证，因此验证器不会反对它们的使用。

BCC 项目维护着一个[助手函数列表](https://oreil.ly/mCpvB)，指示它们是否具有 GPL 许可证。如果您对助手函数的实现细节更感兴趣，可以在[BPF 和 XDP 参考指南](https://oreil.ly/kVd6j)中的相关部分找到更多详细信息。

# 检查内存访问

验证器执行多个检查，以确保 BPF 程序只能访问它们应该访问的内存。

例如，在处理网络数据包时，XDP 程序只允许访问构成该网络数据包的内存位置。大多数 XDP 程序从以下非常相似的内容开始：

```
SEC("xdp")
int xdp_load_balancer(struct xdp_md *ctx)
{
   void *data = (void *)(long)ctx->data;
   void *data_end = (void *)(long)ctx->data_end;
...
```

`xdp_md` 结构体作为上下文传递给程序，描述了接收到的网络数据包。该结构体内的 `ctx->data` 字段是数据包开始的内存位置，而 `ctx->data_end` 是数据包的最后位置。验证器将确保程序不会超出这些边界。

例如，在 *hello_verifier.bpf.c* 中的以下程序是有效的：

```
SEC("xdp")
int xdp_hello(struct xdp_md *ctx) {
  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;
  bpf_printk("%x", data_end);
  return XDP_PASS;
}
```

变量 `data` 和 `data_end` 非常相似，但验证器足够智能，能识别 `data_end` 关联到数据包的末端。你的程序需要检查从数据包读取的任何值是否超出该位置，并且它不允许通过修改 `data_end` 的值来“作弊”。尝试在 `bpf_printk()` 调用之前添加以下行：

```
data_end++;
```

验证器会报错，如下所示：

```
; data_end++;
1: (07) r3 += 1
R3 pointer arithmetic on pkt_end prohibited
```

另一个示例中，在访问数组时，你需要确保不会访问超出数组边界的索引。在示例代码中有一段代码从 `message` 数组中读取字符，如下所示：

```
if (c < sizeof(message)) {
   char a = message[c];
   bpf_printk("%c", a);
}
```

这是没问题的，因为有显式检查确保计数变量 `c` 不会超过消息数组的大小。而像下面这样的简单“差一”的错误会使其无效：

```
if (c <= sizeof(message)) {
   char a = message[c];
   bpf_printk("%c", a);
}
```

验证器将以类似以下的错误消息失败：

```
invalid access to map value, value_size=16 off=16 size=1
R2 max value is outside of the allowed memory range
```

从这条消息很明显可以看出，由于寄存器 2 可能保存一个对地图索引过大的值，导致对地图值的无效访问。如果你正在调试此错误，你需要深入日志，查看源代码中哪一行负责这个错误。日志在发出错误消息前如下结束（为了清晰起见，我已删除部分状态信息）：

```
; if (c <= sizeof(message)) {
30: (25) if r1 > 0xc goto pc+10                                ![3](img/3.png)
 R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0) R1_w=inv(id=0,
 umax_value=12,var_off=(0x0; 0xf)) R6=ctx(id=0,off=0,imm=0) ...
; char a = message[c];
31: (18) r2 = 0xffff800008e00004                               ![2](img/2.png)
33: (0f) r2 += r1                                               
last_idx 33 first_idx 19
regs=2 stack=0 before 31: (18) r2 = 0xffff800008e00004
regs=2 stack=0 before 30: (25) if r1 > 0xc goto pc+10
regs=2 stack=0 before 29: (61) r1 = *(u32 *)(r8 +0)
34: (71) r3 = *(u8 *)(r2 +0)                                   ![1](img/1.png)
 R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0) R1_w=invP(id=0,
 umax_value=12,var_off=(0x0; 0xf)) R2_w=map_value(id=0,off=4,ks=4,vs=16,
 umax_value=12,var_off=(0x0; 0xf),s32_max_value=15,u32_max_value=15)
 R6=ctx(id=0,off=0,imm=0) ...
```

![1](img/#code_id_6_6)

从错误处回溯，最后的寄存器状态信息显示寄存器 2 的最大值可能是 `12`。

![2](img/#code_id_6_5)

在第 31 指令处，寄存器 2 被设置为内存中的一个地址，然后按寄存器 1 的值递增。输出显示这对应于访问 `message[c]` 的代码行，因此合理推测寄存器 2 被设置为指向消息数组，然后按寄存器 1 中的 `c` 值递增。

![3](img/#code_id_6_4)

进一步查找寄存器 1 的值，日志显示其最大值为 `12`（即十六进制的 `0x0c`）。然而，`message` 被定义为一个 12 字节的字符数组，因此只有索引 0 到 11 在其范围内。由此可见，错误来自于源代码中测试 `c <= sizeof(message)`。

在第 2 步，我已经从验证器包含在日志中的源代码行中推断了一些寄存器与它们表示的源代码变量之间的关系。如果代码是没有调试信息编译的，您可能需要通过验证器日志来检查这一点。鉴于存在调试信息，使用它是有意义的。

`message` 数组声明为全局变量，您可能还记得来自 第三章 的全局变量是使用映射实现的。这解释了为什么错误消息提到“无效访问映射值”。

# 在解引用指针之前检查指针

一个让 C 程序崩溃的简单方法是在指针的值为零（也称为*null*）时解引用指针。指针指示内存中值的位置，而零不是有效的内存位置。eBPF 验证器要求在解引用指针之前检查所有指针，以防止这种崩溃发生。

*hello-verifier.bpf.c* 中的示例代码寻找可能存在于 `my_config` 散列表映射中的自定义消息，代码如下：

```
p = bpf_map_lookup_elem(&my_config, &uid);
```

如果没有与 `uid` 对应的条目，则将 `p`（指向消息结构 `msg_t` 的指针）设置为零。这里有一小段额外的代码，试图解引用这个可能为空的指针：

```
char a = p->message[0];
bpf_printk("%c", a);
```

这段代码可以编译，但验证器会拒绝如下：

```
; p = bpf_map_lookup_elem(&my_config, &uid); 
25: (18) r1 = 0xffff263ec2fe5000
27: (85) call bpf_map_lookup_elem#1
28: (bf) r7 = r0                                ![1](img/1.png)
; char a = p->message[0];
29: (71) r3 = *(u8 *)(r7 +0)                    ![2](img/2.png)
R7 invalid mem access 'map_value_or_null'
```

![1](img/#code_id_6_7)

辅助函数调用的返回值存储在寄存器 0 中。在这里，该值被存储在寄存器 7 中。这意味着寄存器 7 现在保存了局部变量 `p` 的值。

![2](img/#code_id_6_8)

此指令尝试解引用指针值 `p`。验证器一直跟踪寄存器 7 的状态，并知道它可能保存指向映射值的指针，或者可能为空。

验证器会拒绝尝试解引用空指针的尝试，但如果有显式检查，例如：

```
if (p != 0) {
   char a = p->message[0];
   bpf_printk("%d", cc);
}
```

一些辅助函数会为您集成指针检查。例如，如果您查看 bpf-helpers 的 man 页面，您将找到 `bpf_probe_read_kernel()` 的函数签名如下：

```
long bpf_probe_read_kernel(void **`dst`*, u32 *`size`*, const void **`unsafe_ptr`*)
```

此函数的第三个参数称为 `unsafe_ptr`。这是一个 BPF 辅助函数的示例，通过为您处理检查，帮助程序员编写安全代码。您可以传递一个潜在的空指针，但只能作为名为 `unsafe_ptr` 的第三个参数，并且在尝试解引用之前，辅助函数会检查它不为空。

# 访问上下文

每个 eBPF 程序作为参数传递一些上下文信息，但根据程序和附加类型的不同，可能只允许访问其中的一部分上下文信息。例如，[跟踪点程序](https://oreil.ly/6RFFI) 接收一个指向某些跟踪点数据的指针。该数据的格式取决于特定的跟踪点，但它们都以一些共同字段开头——然而，这些共同字段对 eBPF 程序是不可访问的。只能访问后续的特定于跟踪点的字段。试图读取或写入错误的字段会导致 `invalid bpf_context access` 错误。本章末尾的练习中有一个例子。

# 运行至完成

验证器确保 eBPF 程序能够完成运行；否则，可能会无限消耗资源。为了达到这个目的，它限制了它将处理的总指令数，就像我之前提到的，在撰写本文时设定为一百万条指令。这个限制是 [硬编码进内核](https://oreil.ly/IucYm) 的，不是一个可配置的选项。如果验证器在处理这么多指令之前未到达 BPF 程序的末尾，则会拒绝该程序。

创建一个永不完成的程序的简单方法是编写一个永不结束的循环。让我们看看如何在 eBPF 程序中创建循环。

# 循环

为了保证完成，直到内核版本 5.3，对循环有一个限制。[³] 循环通过相同的指令需要向后跳转到较早的指令，过去验证器不允许这种情况发生。eBPF 程序员通过使用 `#pragma unroll` 编译器指令来绕过此问题，告诉编译器为每次循环写出一组相同（或非常相似）的字节码指令。这样节省了程序员重复输入相同代码的时间，但在生成的字节码中会看到重复的指令。

从 5.3 版本开始，验证器在检查所有可能的执行路径时向后跟随分支，而不仅仅是向前。这意味着它可以接受一些循环，只要执行路径保持在一百万条指令的限制内。

您可以在示例 *xdp_hello* 程序中看到一个循环的示例。通过验证的循环版本看起来像这样：

```
for (int i=0; i < 10; i++) {
   bpf_printk("Looping %d", i);
}
```

（成功的）验证器日志将显示它已经围绕此循环执行路径 10 次。通过这样做，它不会达到一百万条指令的复杂性限制。在本章的练习中，还有另一个版本的循环将达到该限制并且无法通过验证。

在版本 5.17 中引入了一个新的助手函数`bpf_loop()`，它使得验证器不仅更容易接受循环，而且以更高效的方式执行。这个助手函数以其第一个参数作为最大迭代次数，并传递一个在每次迭代中调用的函数。验证器只需验证该函数中的 BPF 指令一次，无论它可能被调用多少次。该函数可以返回一个非零值，以指示无需再次调用它，这用于在达到所需结果后提前终止循环。

还有一个助手函数[`bpf_for_each_map_elem()`](https://oreil.ly/Yg_oQ)，它调用映射中每个项目的提供的回调函数。

# 检查返回代码

eBPF 程序的返回代码存储在寄存器 0（`R0`）中。如果程序离开`R0`未初始化，验证器会失败，就像这样：

```
R0 !read_ok
```

你可以通过注释掉一个函数中的所有代码来尝试这个功能；例如，将`xdp_hello`示例修改如下：

```
SEC("xdp")
int xdp_hello(struct xdp_md *ctx) {
 void *data = (void *)(long)ctx->data;
 void *data_end = (void *)(long)ctx->data_end;

 // bpf_printk("%x", data_end);
 // return XDP_PASS;
}
```

这将导致验证器失败。然而，如果你把含有助手函数`bpf_printf()`的行放回去，验证器就不会抱怨，即使源代码中没有明确的返回值设置！

这是因为寄存器 0 还用于保存来自助手函数的返回代码。从 eBPF 程序的助手函数返回后，寄存器 0 不再是未初始化的。

# 无效指令

正如你从第三章中对 eBPF（虚拟）机器的讨论中了解到的，eBPF 程序由一组字节码指令组成。验证器检查程序中的指令是否是有效的字节码指令，例如，只使用已知的操作码。

如果编译器生成了无效的字节码，这将被视为编译器的一个错误，因此，除非你选择（出于某种你自己知道的原因）手动编写 eBPF 字节码，否则你不太可能看到这种类型的验证器错误。然而，最近添加了一些指令，如原子操作。如果你的编译字节码使用这些指令，它们将在较旧的内核上验证失败。

# 不可达指令

验证器还会拒绝具有不可达指令的程序。通常情况下，这些指令在编译器优化时会被剔除。

# 总结

当我第一次对 eBPF 产生兴趣时，通过验证器的代码看起来像是一门黑暗艺术，看似有效的代码会被拒绝，抛出看似随意的错误。随着时间的推移，验证器有了*许多*改进，在本章中你已经看到了几个示例，验证器日志提供了帮助，帮助你找出问题所在。

当你对 eBPF（虚拟）机器如何工作有一个心理模型时，这些提示会更有帮助，它使用一组寄存器作为临时值存储，在执行 eBPF 程序时步进。验证器跟踪每个寄存器的类型和可能的值范围，以确保 eBPF 程序可以安全运行。

如果你尝试编写自己的 eBPF 代码，可能会需要帮助来解决验证器错误。[eBPF 社区 Slack 频道](http://ebpf.io/slack) 是一个寻求帮助的好地方，许多人也在 [StackOverflow](https://oreil.ly/nu_0v) 上找到了建议。

# 练习

这里有更多导致验证器错误的方式。看看你能否将验证器日志输出与你收到的错误相关联：

1.  在 “检查内存访问” 中，你看到验证器拒绝超出全局 `message` 数组末尾的访问。在示例代码中，有一个类似方式访问局部变量 `data.message` 的部分：

    ```
    if (c < sizeof(data.message)) {
       char a = data.message[c];
       bpf_printk("%c", a);
    }
    ```

    尝试调整代码，通过用 `<=` 替换 `<` 来制造相同的越界错误，你会看到关于 `invalid variable-offset read from stack R2` 的错误消息。

1.  在示例代码的 *xdp_hello* 中找到被注释掉的循环。尝试添加第一个看起来像这样的循环：

    ```
    for (int i=0; i < 10; i++) {
       bpf_printk("Looping %d", i);
    }
    ```

    你应该在验证器日志中看到一系列重复的类似以下内容的行：

    ```
    42: (18) r1 = 0xffff800008e10009
    44: (b7) r2 = 11
    45: (b7) r3 = 8
    46: (85) call bpf_trace_printk#6
     R0=inv(id=0) R1_w=map_value(id=0,off=9,ks=4,vs=26,imm=0) R2_w=inv11
     R3_w=inv8 R6=pkt_end(id=0,off=0,imm=0) R7=pkt(id=0,off=0,r=0,imm=0) 
     R10=fp0
    last_idx 46 first_idx 42
    regs=4 stack=0 before 45: (b7) r3 = 8
    regs=4 stack=0 before 44: (b7) r2 = 11
    ```

    从日志中找出跟踪循环变量 `i` 的哪个寄存器。

1.  现在尝试添加一个将失败的循环，看起来像这样：

    ```
    for (int i=0; i < c; i++) {
       bpf_printk("Looping %d", i);
    }
    ```

    你应该看到验证器尝试探索这个循环直到结束，但在完成之前达到了指令复杂性限制（因为全局变量 `c` 没有上限）。

1.  编写一个附加到跟踪点的程序。（你可能已经在 第四章 中完成了练习。）预览 “跟踪点” 时，你可以看到一个从这些字段开始的上下文参数的结构定义：

    ```
    unsigned short common_type;
    unsigned char common_flags;
    unsigned char common_preempt_count;
    int common_pid;
    ```

    创建一个类似这样开始的结构体的版本，并使程序中的上下文参数指向这个结构体的指针。在程序中，尝试访问任何这些字段，并看到验证器因为 `invalid bpf_context access` 失败。

^(1) 长期以来，指令数限制为 4,096 条，这给 eBPF 程序的复杂性带来了显著限制。对于运行 BPF 程序的非特权用户，此限制仍然适用。

^(2) 辅助函数也在源代码的其他地方定义，例如，[*kernel/trace/bpf_trace.c*](https://oreil.ly/cY8y9) 和 [*net/core/filter.c*](https://oreil.ly/qww-b)。

^(3) 该版本为 BPF 验证器带来了许多重要的优化和改进，这些内容在 LWN 文章 [“BPF 在 5.3 内核中的有界循环”](https://oreil.ly/50BoD) 中有详细总结。
