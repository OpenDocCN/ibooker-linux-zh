# 第九章：eBPF 用于安全

您已经看到了 eBPF 如何被用来观察系统中的事件，并向用户空间工具报告有关这些事件的信息。在本章中，您将考虑如何基于事件检测构建基于 eBPF 的安全工具，这些工具可以检测甚至防止恶意活动。我将首先帮助您了解安全与其他类型的可观察性之间的区别。

###### 注意

本章的示例代码位于[GitHub 存储库](http://github.com/lizrice/learning-ebpf)的*chapter9*目录中。

# 安全可观察性需要政策和上下文

安全工具和报告事件的可观察性工具之间的区别在于，安全工具需要能够区分在正常情况下预期的事件和表明可能发生恶意活动的事件。例如，假设您有一个应用程序，作为其正常处理的一部分将数据写入本地文件。假设该应用程序预期写入*/home/<username>/<filename>*，因此从安全角度来看，这种活动并不是您感兴趣的事情。但是，如果应用程序写入 Linux 中的许多敏感文件位置之一，您将希望收到通知。例如，它不太可能需要修改*/etc/passwd*中存储的密码信息。

政策必须考虑的不仅是系统完全正常运行时的正常行为，还有预期的错误路径行为。例如，如果物理磁盘变满，应用程序可能会开始发送网络消息以警告这种情况。这些网络消息不应被视为安全事件——尽管它们不寻常，但并不可疑。考虑错误路径可能会使创建有效政策变得具有挑战性，我们将在本章后面回到这个挑战。

定义预期行为和非预期行为的工作是政策的职责。安全工具将活动与政策进行比较，并在活动超出政策范围时采取某些行动，使其变得可疑。该行动通常涉及生成安全事件日志，通常会发送到安全信息事件管理（SIEM）平台。这可能还会导致向需要调查发生了什么的人发出警报。

调查人员可以获得的上下文信息越多，他们就越有可能找出事件的根本原因，并确定它是否是一次攻击，哪些组件受到影响，攻击是如何发生的，以及谁负责。如图 9-1 所示，能够回答这类问题将使工具从仅仅是日志记录变得值得被称为“安全可观察性”。

![安全可观察性需要政策和上下文](img/lebp_0901.png)

###### 图 9-1：安全可观察性需要上下文信息来检测超出政策范围的事件

让我们探讨一些使用 eBPF 程序来检测和执行安全事件的方法。正如您所知，eBPF 程序可以附加到各种事件，多年来一直被广泛用于安全的一组事件是系统调用。我们将从系统调用开始讨论，但正如您将看到的那样，系统调用可能不是使用 eBPF 实施安全工具的最有效方式。在本章的后面部分，我们将看到一些更新和更复杂的方法。

# 使用系统调用进行安全事件

系统调用（或 syscalls）是用户空间应用程序和内核之间的接口。如果您可以限制应用程序可以进行的系统调用集，那将限制它能够做什么。例如，如果您阻止应用程序进行`open*（）`系列的系统调用，它将无法打开文件。如果您有一个您从未期望打开文件的应用程序，您可能希望创建这种限制，以便即使应用程序受到损害，它也无法恶意打开文件。如果您在过去几年中一直在使用 Docker 或 Kubernetes，那么您很有可能已经遇到了一种使用 BPF 来限制系统调用的安全工具：seccomp*.*

## Seccomp

*seccomp*的名称是“SECure COMPuting”的缩写。在其原始或“严格”形式中，seccomp 用于将进程可以使用的系统调用集限制为非常小的子集：`read()`、`write()`、`_exit()`和`sigreturn()`。这种严格模式的目的是允许用户运行不受信任的代码（也许是从互联网下载的程序），而不可能让该代码执行恶意操作。

严格模式非常严格，许多应用程序需要使用更大的系统调用集——但这并不意味着它们需要全部 400 多个系统调用。允许更灵活的方法来限制任何给定应用程序可以使用的系统调用集是有道理的。这就是我们大多数来自容器世界的人遇到的 seccomp 的理由，更准确地说是 seccomp-bpf。与允许的系统调用的固定子集不同，seccomp 的这种模式使用 BPF 代码来过滤允许和不允许的系统调用。

在 seccomp-bpf 中，加载了一组 BPF 指令，充当过滤器。每次调用系统调用时，都会触发过滤器。过滤器代码可以访问传递给系统调用的参数，以便根据系统调用本身和传递给它的参数做出决策。结果是一组可能的操作，包括：

+   允许系统调用继续进行

+   向用户空间应用程序返回错误代码

+   终止线程

+   通知用户空间应用程序（seccomp-unotify*）*（截至内核版本 5.0）

###### 注意

如果您想探索编写自己的 BPF 过滤器代码，Michael Kerrisk 在[*https://oreil.ly/cJ6HL*](https://oreil.ly/cJ6HL)上有一些很好的例子。

传递给系统调用的一些参数是指针，而 seccomp-bpf 中的 BPF 代码无法解引用这些指针。这限制了 seccomp 配置文件的灵活性，因为它只能在决策过程中使用值参数。此外，它必须在进程启动时应用——您无法修改应用于给定应用程序进程的配置文件。

您很可能已经使用了 seccomp-bpf，而没有编写 BPF 代码，因为该代码通常是从可读的 seccomp 配置文件派生的。[Docker 的默认配置文件](https://oreil.ly/IT_Bf)就是一个很好的例子。这是一个通用配置文件，旨在几乎可以与任何正常的容器化应用程序一起使用。这不可避免地意味着它允许大多数系统调用，并且只禁止了一些不太可能适用于任何应用程序的系统调用，`reboot()`就是一个很好的例子。

[根据 Aqua Security](https://oreil.ly/1xWmn)，大多数容器化应用程序使用大约 40 到 70 个系统调用。为了更好的安全性，最好使用一个更受限制的配置文件，针对每个特定应用程序，并且只允许它实际使用的系统调用。

## 生成 Seccomp 配置文件

如果您要求普通应用程序开发人员告诉您他们的程序所做的系统调用，您可能会得到一种茫然的表情。这并不是要冒犯。只是大多数开发人员使用的编程语言给予他们远离系统调用细节的更高级抽象。例如，他们可能知道他们的应用程序打开了哪些文件，但他们不太可能告诉您它们是使用`open()`还是`openat()`。这使得如果您要求开发人员手工制作适当的 seccomp 配置文件，可能不太可能得到积极的回应。

自动化是未来的发展方向：使用工具记录应用程序所做的系统调用集。在早期，seccomp 配置文件通常是使用`strace`编译的，以收集应用程序调用的系统调用集。¹在云原生时代，这不是一个很好的解决方案，因为没有简单的方法将`strace`指向特定的容器或 Kubernetes pod。将配置文件生成为系统调用列表不仅作为输入，而且还以 Kubernetes 和 OCI 兼容的容器运行时可以接受的 JSON 格式更有帮助。有一些工具可以做到这一点，使用 eBPF 收集有关所有被调用的系统调用的信息：

+   [Inspektor Gadget](https://www.inspektor-gadget.io)包括一个 seccomp 性能分析器，允许您为 Kubernetes pod 中的容器生成自定义 seccomp 配置文件。²

+   Red Hat 创建了一个 seccomp 性能分析器，以[OCI 运行时挂钩](https://oreil.ly/nC8vM)的形式呈现。

使用这些性能分析器，您需要运行应用程序一段任意的时间来生成包含其可能合法调用的系统调用列表的配置文件。正如本章前面讨论的那样，此列表需要包括错误路径。如果您的应用程序在错误条件下无法正确行为，因为它需要调用的系统调用被阻止，这可能会导致更大的问题。由于 seccomp 配置文件处理的抽象级别低于大多数开发人员熟悉的抽象级别，因此很难手动审查它们以查看它们是否涵盖了所有正确的情况。

以 OCI 运行时挂钩为例，一个 eBPF 程序被[附加到`syscall_enter`原始跟踪点](https://oreil.ly/sbWSc)，并维护一个 eBPF 映射，跟踪[已见过的系统调用](https://oreil.ly/czUM7)。该工具的用户空间部分是用 Go 编写的，并使用[*iovisor/gobpf*库](https://oreil.ly/sYCT3)。（我将在第十章中讨论这个以及其他用于 eBPF 的 Golang 库。）

以下是加载 eBPF 程序到内核并将其附加到 tracepoint 的 OCI 运行时挂钩的[代码行](https://oreil.ly/DOShA)（为简洁起见，有几行被省略）：

```cpp
src := strings.Replace(source, "$PARENT_PID", strconv.Itoa(pid), -1)           // ①
m := bcc.NewModule(src, []string{})
defer m.Close()

...
enterTrace, err := m.LoadTracepoint("enter_trace")                             // ②
...
if err := m.AttachTracepoint("raw_syscalls:sys_enter", enterTrace); err != nil // ③
    {                                                                       
    return fmt.Errorf("error attaching to tracepoint: %v", err)
}
```

①

这行代码做了一件非常有趣的事情：它用数字进程 ID 替换了 eBPF 源代码中名为`$PARENT_PID`的变量。这是一个常见的模式，它表明该工具将为每个被检测的进程加载单独的 eBPF 程序。

②

在这里，一个名为`enter_trace`的 eBPF 程序被加载到内核中。

③

`enter_trace`程序被附加到 tracepoint`raw_syscalls:sys_enter`。这是进入任何系统调用的跟踪点，在先前的示例中已经遇到过。每当任何用户空间代码进行系统调用时，都会触发此跟踪点。

这些性能分析器使用附加到`sys_enter`的 eBPF 代码来跟踪已使用的系统调用集，并生成一个用于 seccomp 的 seccomp 配置文件，该配置文件执行实际的强制性工作。我们将考虑的下一个 eBPF 工具类别也附加到`sys_enter`，但它们使用系统调用来跟踪应用程序的行为并将其与安全策略进行比较。

## 系统调用跟踪安全工具

属于系统调用跟踪安全工具这一类别的最知名的工具是 CNCF 项目[Falco](https://falco.org)，它提供安全警报。默认情况下，Falco 安装为内核模块，但也有 eBPF 版本。用户可以定义[规则](https://oreil.ly/enufu)来确定哪些事件与安全相关，当发生不符合这些规则定义的事件时，Falco 可以以各种格式生成警报。

内核模块驱动程序和基于 eBPF 的驱动程序都连接到系统调用。如果您检查 GitHub 上的[Falco eBPF 程序](https://oreil.ly/Q_cBD)，您会看到类似以下内容的行，它们将探针连接到原始系统调用入口和退出点（以及一些其他事件，例如页面错误）：

```cpp
BPF_PROBE("raw_syscalls/", sys_enter, sys_enter_args) `BPF_PROBE``(``"raw_syscalls/"``,` `sys_exit``,` `sys_exit_args``)`
```

“由于 eBPF 程序可以动态加载并且可以检测由预先存在的进程触发的事件，因此像 Falco 这样的工具可以将策略应用于已经运行的应用工作负载。用户可以修改正在应用的规则集，而无需修改应用程序或其配置。这与 seccomp 配置文件形成对比，后者必须在启动应用程序时应用于应用程序进程。”

不幸的是，使用系统调用入口点进行安全工具的方法存在一个问题：存在时间检查到使用时间（TOCTOU）问题。

当 eBPF 程序在系统调用的入口点触发时，它可以访问用户空间传递给该系统调用的参数。如果这些参数是指针，内核将需要将指向的数据复制到自己的数据结构中，然后再对该数据进行操作。如图 9-2 所示，攻击者有机会在 eBPF 程序检查数据后但内核复制数据之前修改这些数据。因此，正在操作的数据可能与 eBPF 程序捕获的数据不同。³

![攻击者可以在内核访问之前更改系统调用参数](img/lebp_0902.png)

###### 图 9-2：攻击者可以在内核访问之前更改系统调用参数

对于 seccomp-bpf 来说，同样的窗口也适用，因为在 seccomp-bpf 中，程序不允许对用户空间指针进行解引用，因此根本无法检查数据。

TOCTOU 问题也适用于 seccomp_unotify，这是 seccomp 的最近添加的模式，其中可以向用户空间报告违规行为。[seccomp_unotify 的 manpage](https://oreil.ly/cwpki)明确指出“因此，应该绝对清楚，seccomp 用户空间通知机制*不能*用于实施安全策略！”

系统调用入口点可能非常方便用于可观察性目的，但对于严肃的安全工具来说，这确实是不够的。

[Linux 工具 Sysmon](https://oreil.ly/pbtF3)通过连接到系统调用的入口和退出点来解决 TOCTOU 窗口问题。一旦调用完成，它会查看内核的数据结构以获得准确的视图。例如，如果系统调用返回文件描述符，附加到退出的 eBPF 程序可以通过查看相关进程的文件描述符表来检索有关文件描述符表示的对象的正确信息。虽然这种方法可以产生与安全相关的活动的准确记录，但它无法阻止动作发生，因为在进行检查时系统调用已经完成。

为了确保它检查的是内核将要执行的相同信息，eBPF 程序应该附加到在参数被复制到内核内存之后发生的事件上。不幸的是，在内核中没有一个统一的地方可以这样做，因为数据在特定于系统调用的代码中处理方式不同。但是，有一个明确定义的接口可以安全地附加 eBPF 程序：Linux 安全模块（LSM）API。这需要一个相对较新的 eBPF 功能：BPF LSM。``  ``# BPF LSM

LSM 接口提供了一组钩子，每个钩子都在内核即将对内核数据结构采取行动之前发生。由钩子调用的函数可以决定是否允许继续执行操作。最初提供此接口是为了允许以[内核模块](https://oreil.ly/mF_OD)的形式实现安全工具；[BPF LSM](https://oreil.ly/KzaMT)扩展了此功能，以便 eBPF 程序可以附加到相同的钩子点，如图 9-3 所示。

![使用 LSM BPF，eBPF 程序可以通过 LSM 钩子事件触发](img/lebp_0903.png)

###### 图 9-3：使用 LSM BPF，eBPF 程序可以通过 LSM 钩子事件触发

有数百个 LSM 钩子，并且它们在内核源代码中[有很好的文档记录](https://oreil.ly/dO8jT)。要明确的是，系统调用和 LSM 钩子之间并没有一对一的映射，但是如果系统调用有可能从安全的角度做一些有趣的事情，处理该系统调用将触发一个或多个钩子。

以下是一个附加到 LSM 钩子的 eBPF 程序的简单示例。此示例在处理`chmod`命令（“chmod”代表“更改模式”，主要用于更改文件的访问权限）时被调用：

```cpp
SEC("lsm/path_chmod") `int` `BPF_PROG``(``path_chmod``,` `const` `struct` `path` `*``path``,` `umode_t` `mode``)` ``{` ``bpf_printk``(``"Change mode of file name %s``\n``"``,` `path``->``dentry``->``d_iname``);` ``return` `0``;` ``}`````

```cpp

 ```此示例只是跟踪文件的名称并始终返回`0`，但您可以想象一个真实的实现，该实现将利用参数来决定是否允许更改模式。返回一个非零值将拒绝更改权限，因此内核将不会继续执行。值得注意的是，像这样在内核内部完全进行策略检查是非常高效的。

`BPF_PROG()`的`path`参数是表示文件的内核数据结构，`mode`参数是期望的新模式值。您可以从字段`path->dentry->d_iname`中看到正在访问的文件的名称。

LSM BPF 是在内核版本 5.7 中添加的，这意味着（至少在撰写本文时）它尚未在许多受支持的 Linux 发行版上可用，但我预计在接下来的几年里，许多供应商将开发使用此接口的安全工具。在 LSM BPF 被广泛使用之前，还有另一种可能的方法，就像 Cilium Tetragon 的开发人员所使用的那样。```cpp  ```# Cilium Tetragon

[Tetragon](https://oreil.ly/p-bdc)是 Cilium 项目的一部分（也是 CNCF 的一部分）。Tetragon 的方法不是附加到 LSM API 钩子，而是构建一个框架，用于将 eBPF 程序附加到 Linux 内核中的任意函数。

Tetragon 是为 Kubernetes 环境设计的，并且该项目定义了一种称为*TracingPolicy*的自定义 Kubernetes 资源类型。这用于定义应该附加 eBPF 程序的一组事件、需要由 eBPF 代码检查的条件以及如果满足条件应该采取的操作。以下是从示例 TracingPolicy 中提取的内容：

```cpp
spec:
 kprobes:
 - call: "fd_install"
...
     matchArgs:
     - index: 1
       operator: "Prefix"
       values:
       - "/etc/"
...
```

此策略定义了一组 kprobe，用于附加程序，其中第一个是内核函数`fd_install`。这是内核中的一个内部函数。让我们探讨为什么您可能选择附加到这样的函数。

## 附加到内部内核函数

系统调用接口和 LSM 接口在 Linux 内核中被定义为稳定接口；也就是说，它们不会以不兼容的方式进行更改。如果你今天编写使用这些接口中的函数的代码，它们将在将来的内核版本中继续工作。这些接口只代表了构成 Linux 内核的 3000 万行代码中的一小部分。即使它们没有被正式声明为这样，这部分代码库是事实上稳定的；它们已经很长时间没有改变，未来也不太可能改变。

编写附加到官方稳定性不确定的内核函数的 eBPF 程序是完全合理的，可以期望它们在相当长的时间内能够正常工作。此外，考虑到新内核版本通常需要几年时间才能被广泛部署，可以肯定会有足够的时间来解决可能出现的任何不兼容性问题。

Tetragon 的贡献者包括一些内核开发人员，他们利用对内核内部的了解，确定了一些可以附加 eBPF 程序以实现有用安全目的的良好且安全的位置。有几个[示例 TracingPolicy 定义](https://oreil.ly/51yRN)利用了这些知识。这些示例监视涵盖文件操作、网络活动、程序执行和权限更改的安全事件，这些都是恶意行为者在攻击中可能会做的事情。

让我们回到附加到`fd_install`的示例策略定义。这里的“fd”代表“文件描述符”，而[此函数的源代码注释](https://oreil.ly/Tm6MN)告诉我们这个函数“在 fd 数组中安装一个文件指针”。这发生在打开文件时，并且在文件的数据结构在内核中被填充后调用。这是一个安全的地方来检查文件的名称，并且在早期的 TracingPolicy 示例中，只有当文件名以“/etc/”开头时才感兴趣。

与 LSM BPF 程序一样，Tetragon 的 eBPF 程序可以访问上下文信息，使它们能够完全在内核内做出安全决策。与将给定类型的所有事件报告给用户空间不同，安全相关事件可以在内核内进行过滤，以便只有违反策略的事件才会报告给用户空间。

## 预防安全

大多数基于 eBPF 的安全工具都使用 eBPF 程序来检测恶意事件，然后通知用户空间应用程序采取行动。正如你在图 9-4 中所看到的，用户空间应用程序采取的任何行动都是异步发生的，这时可能为时已晚——也许数据已经被外泄，或者攻击者已经将恶意代码持久化到磁盘上。

![内核到用户空间的异步通知允许攻击继续一段时间](img/lebp_0904.png)

###### 图 9-4：内核到用户空间的异步通知允许攻击继续一段时间

在内核版本 5.3 及更高版本中，有一个名为`b⁠p⁠f⁠_⁠s⁠e⁠n⁠d⁠_​s⁠i⁠g⁠n⁠a⁠l⁠(⁠)`的 BPF 辅助函数。Tetragon 使用这个函数来实现预防安全。如果策略定义了 Sigkill 动作，任何匹配的事件都会导致 Tetragon 的 eBPF 代码生成一个 SIGKILL 信号，终止试图执行违反策略动作的进程。如图 9-5 所示，这是同步发生的；也就是说，内核正在执行的活动被 eBPF 代码确定为违反策略，将被阻止完成。

![Tetragon 通过从内核发送 SIGKILL 信号同步地杀死恶意进程](img/lebp_0905.png)

###### 图 9-5：Tetragon 通过从内核发送 SIGKILL 信号同步地杀死恶意进程

Sigkill 策略需要谨慎使用，因为配置不正确的策略可能导致不必要地终止应用程序，但这是 eBPF 用于安全目的的一种非常强大的用途。您可以从运行“审计”模式开始，生成安全事件但不应用 SIGKILL 执行，直到您确信该策略不会破坏任何东西。

如果您对使用 Cilium Tetragon 来检测安全事件感兴趣，可以参考 Natália Réka Ivánkó和 Jed Salazar 撰写的报告“[使用 eBPF 进行安全可观察性](https://www.oreilly.com/library/view/security-observability-with/9781492096719/)”，其中有更详细的内容。

# 网络安全

第八章讨论了如何有效地使用 eBPF 来实施网络安全机制。总之：

+   防火墙和 DDoS 保护非常适合在网络数据包的入口路径早期附加 eBPF 程序。并且，通过将 XDP 程序卸载到硬件，恶意数据包甚至可能根本不会到达 CPU！

+   为了实施更复杂的网络策略，例如 Kubernetes 策略确定允许哪些服务相互通信，eBPF 程序可以附加到网络堆栈中的某些点，如果确定数据包违反策略，可以丢弃数据包。

网络安全工具往往以预防模式使用，而不仅仅是审计恶意活动。这是因为恶意行为者很容易发动与网络相关的攻击；如果您给设备一个暴露在互联网上的公共 IP 地址，很快就会开始看到可疑的流量，因此组织被迫采取预防措施。

相比之下，许多组织在审计模式下使用入侵检测工具，并依靠取证来确定可疑事件是否真的恶意以及需要采取什么补救措施。如果某个安全工具过于粗糙并容易检测出误报，那么它需要在审计模式下运行而不是预防模式下运行并不奇怪。我相信 eBPF 正在实现更复杂的安全工具，具有更精细、准确的控制。就像我们今天认为防火墙足够准确以用于预防模式一样，我们将看到更多的预防性工具被用于处理其他非网络事件。这甚至可能包括将基于 eBPF 的控制作为应用产品的一部分打包，以便它可以提供自己的运行时安全性。

# 总结

在本章中，您看到了 eBPF 在安全领域的应用是如何从对系统调用的低级检查发展到更复杂的 eBPF 程序用于安全策略检查、内核事件过滤和运行时执行的。

在使用 eBPF 进行安全目的方面仍然有很多积极的发展。我相信在未来几年内，我们将看到这一领域的工具不断发展并得到广泛应用。

¹ 例如，Jess Frazelle 开发了 Docker 的默认 seccomp 配置文件，可以参考她的这篇文章：[“如何使用新的 Docker Seccomp 配置文件”](https://oreil.ly/EcpnM)。

² Inspektor Gadget 的 seccomp 分析器的文档非常枯燥，但[Jose Blanquicet 的这个视频概述](https://oreil.ly/0bYaa)更易于理解。

³ 在 DEFCON 29 的一次名为“[幻影攻击：规避系统调用监控](https://oreil.ly/WguKq)”的演讲中讨论了利用这一窗口，演讲者是 Rex Guo 和 Junyuan Zeng，而其对 Falco 的影响在 Leo Di Donato 和 KP Singh 的演讲“[LSM BPF 改变一切](https://oreil.ly/17c-3)”中有更详细的介绍。
