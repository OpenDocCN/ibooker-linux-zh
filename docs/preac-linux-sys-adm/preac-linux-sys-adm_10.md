# 第十章：脚本编写与自动化

系统管理员尽力自动化他们所能自动化的任务。但并非所有事情都可以自动化。自动化是好事，但也有其局限性。在本章中，我讨论了自动化的利与弊。有些任务难以自动化，因为涉及太多变量。自动化也带来一些安全风险，因为自动化需要提升特权的任务会产生安全漏洞，这可能导致系统被入侵。其他妨碍自动化的因素包括时间同步和时间漂移、系统故障、脚本错误条件和人类交互。

创建脚本并自动化任务既具有挑战性又有趣。观察一系列脚本和计划按计划运行，模仿人类的击键、决策和活动，是令人满足的。每个系统管理员都必须掌握如何创建基本的 Shell 脚本，并应自动化所有可能的非特权、重复性任务。本章介绍了脚本编写与自动化的概念，但不涉及脚本的低级机制（循环、文件 I/O 等），这些内容在网络上有详细的文档。

# 回答这个问题：为什么要自动化？

我曾有几位系统管理员问我，为什么要自动化任何事情。答案很简单：这样你就可以专注于更高级别的任务，而你的计算机系统可以处理日常繁琐的工作，这些工作你必须完成，但 CPU 和一些内存可以在没有错误的情况下处理。你想让你的一天充满手动创建备份、将备份复制到存档位置、检查每个系统的容量、安装更新、检查日志文件是否有错误以及检查运行时间，还是更愿意专注于系统安全、测试新软件和提高脚本技能？

你只有有限的时间来完成必须做的工作。而你手边可能有几乎不计其数的计算能力。利用它吧。那些需要你花费几个小时的任务可以交给系统，这些系统可以无误地完成这些重复性任务，而且不会感到疲倦或沮丧，并且几乎没有额外开销。这就是你应该自动化每一个可能的任务的原因。

# 自动化将你自动化出职业

剧透警告：你永远不可能通过自动化失去工作，但你应该尝试。说真的，你可以自动化你面对的每一个重复乏味的任务，但你永远不会因为自动化而失业。硬件、软件、网络，尤其是用户，有太多变量和可能出错的地方，无法因为你成功自动化了太多而终结你的就业。

下面是我相信能为你解惑的五个关于自动化的常见问题的答案：

应该自动化哪些任务？

任何可以可靠地脚本化的任务，即使需要用户输入。

有哪些任务是无法自动化的？

是的，有很多这样的任务。大多数需要复杂、多步决策的事情不能被自动化（尽管有些可以）。你可以使用各种技术来自动化它们，包括`expect`、shell 脚本、Perl、PHP 和其他脚本语言和编译语言。

有哪些任务是不应该自动化的？

是的。你不应该自动化那些需要你在文本文件中存储未加密密码的任务。有多种方法可以自动化任务，你可以使用加密密码、密钥文件、限制的`sudo`或非特权账户。

我应该首先自动化哪些任务？

备份。例如，创建*/etc*目录的备份，并使用安全复制（SCP）将其归档到另一个系统上。

我应该购买商业自动化解决方案吗？

你可以，但在花钱购买之前，应该先使用自己的脚本并耗尽你的选择。但是，如果主机数量使之合理，当然可以购买商业解决方案。

基本的自动化很容易做到，它节省时间和金钱，避免了人为错误。

自动化还涉及心理因素——自动化的系统管理员比手动执行每个任务的人经历更少的倦怠感。想想备份的重复性质，将其转移到归档位置，检查备份，删除旧的归档。如果你管理的系统超过少数几个，手动输入每个命令将占据你一天（或晚上）的大部分时间。这种工作方式对人的心理影响很大，导致倦怠和工作不满意。多项研究表明，自动化确实提高了工作满意度。Alex Edelstein 的博客文章[“你的员工中 89%可以从这一变化中受益”](https://oreil.ly/5-iR9)进一步解释了这个概念。

# 创建脚本

如果你需要一个脚本来执行特定的任务，那么很有可能可以通过简单的在线搜索找到一个。你不必从头开始编写一个。根据你的需求调整脚本并使用它们而无需内疚。其他系统管理员会将他们的脚本放在网上供你使用。然而，你应该学习脚本编写的基础知识，比如从文件中读取，写入文件，grep，管道，重定向，循环和在脚本内调用其他脚本。你不必成为脚本编写专家，但学习这些基础知识有助于你找到你需要的东西，并允许你根据你的情况进行调整。

编写备份脚本是一个很好的起点。备份是必需的，在故障或人为错误（可能是你自己的）时你将成为英雄。我知道一些有超过十年经验的系统管理员曾经意外删除了整个*/etc*目录，因此良好的备份对于作为系统管理员的愉快生活至关重要。以下部分将教你脚本编写的概念。其中最重要的是概述你的脚本。

## 概述你的脚本

在编写脚本之前，请先概述脚本的功能。不，你不必创建流程图，但应列出希望在脚本运行期间发生的步骤。这里有一个示例脚本，我称之为*backup_server1.sh*：

+   创建*/etc*目录的`tar`文件。

+   压缩`tar`文件。

+   将文件传输到服务器*archive1*。

这很简单。该脚本是一个简单的自上而下的过程，没有决策树或分支。

## 从概述编写脚本

现在您有了脚本概述，也有了脚本的文档。您必须记录脚本，因为在六个月或一年后，您可能不会记得脚本的目的，甚至不记得您编写过它。

*backup_server1.sh*的内容如下：

```
#!/bin/bash

# Create a tar file of /etc.
sudo tar cvf server1_etc.tar /etc

# Compress the tar file
gzip -9 server1_etc.tar

# Transfer the file to archive1 into the /server1/backups directory
scp server1_etc.tar.gz archive1:/server1/backups
```

保存文件，赋予执行权限，然后就可以使用了。*archive1*系统上*/server1/backups*目录应由将备份放入其中的用户可执行和可写。为了更好的安全性，您应指定一个备份用户，并创建仅该用户具有权限的备份目录。

在所有系统上创建一个名为 Backup and Restore (`bur`)的用户，并为`bur`用户设置无密码 SSH 密钥文件。为所有系统上的`bur`用户设置`cron`作业：

```
drwx------    2 bur  bur         64 Oct  4 08:01 backups
```

这是*server1*上`bur`用户的`crontab`：

```
0 2 * * * /home/bur/backup_server1.sh
```

`bur`用户的`crontab`将在每天凌晨 2 点备份*server1*的*/etc*目录。备份将传输到*archive1*中的*/server1/backup*目录。您需要在每个系统上设置这种情况。*archive1*的备份应发送到另一个系统。

*/etc*目录不是您需要备份的唯一目录。这只是一个例子。在安全事件或故障之前恢复系统可能需要备份*/home*、*/var/www/html*、*/opt*等目录。`crontab`（定时任务）将在下一节详细解释。

# 定时任务

`cron`实用程序安排命令在特定时间运行。它有助于自动执行必须在特定时间、多次或人类难以方便执行的重复任务。

多年来，开发人员尝试替换`cron`实用程序，但成功甚少。`cron`难以替换，因为它工作良好，并且足够灵活，可以处理大多数计划活动。`cron`可靠，因为它使用计算机的系统时钟执行计划活动。如果您的自动化任务涉及多个系统并且它们的时间偏移超出同步，则会遇到问题。解决方法是引用中央时间服务器。我将在本节后面介绍网络时间协议。

## 使用 cron 调度任务

`cron`实用程序在所有 Linux 系统上都可用，并且它可以正常工作。无需调整或配置。它是一个经过时间考验的应用程序，专门用于在特定时间运行命令，并且它执行得非常好。学习`cron`的最佳方式是通过示例，因为其语法不一定直观。

`cron`具有简单的“语法”或格式：

```
# ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of the month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;
# │ │ │ │ │                         7 is also Sunday on some systems)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * command to execute
```

这里没有显示的是，您可以仅使用一个计划或`cron`“作业”多次运行脚本或命令。例如，您需要运行一个检查文件存在性的脚本，每天每 5 分钟运行一次。该条目的格式如下：

```
0,5,10,15,20,25,30,35,40,45,50,55 * * * * /path/to/script.sh
```

如果您希望脚本在每周一、三和五下午 2 点运行，`cron`调度的格式如下：

```
0 14 * * 1,3,5 /path/to/script.sh
```

如果您希望您的脚本在每个月的 15 日上午 6 点运行：

```
0 6 15 * * /path/to/script.sh
```

您在`cron`调度中有很多可能性。

###### 警告

不要为** * * * * /path/to/script.sh*在`cron`中设置一个计划，除非您希望您的脚本每天每分钟运行一次。对于大多数监视场景，每五分钟运行一次足以捕获您试图捕获或跟踪的任何进程、错误或文件。

## 使用网络时间协议防止时间漂移

编写操作多个系统的脚本时的一个问题是同步它们之间的系统时间。例如，想象一下，您有一个从*服务器 A*收集文件并将其复制到*服务器 B*的脚本，一旦这些文件被复制，*服务器 B*会检查它们，然后创建一个 tar 包并将它们复制到 NAS 进行归档。如果这需要每天多次发生并按时序列进行，您可以看到在服务器系统之间同步时间的重要性。

保持所有系统时间同步的方法是参考一个互联网时间服务器和网络内部的时间服务器（以防止遇到互联网连接故障）。

安装`ntp`或`chrony`以允许您的系统与外部（互联网）时间服务器同步。安装`chrony`很简单，并且作为客户端不需要配置。在这里，我演示了如何安装和配置`chrony`。在 Debian 发行版上，它的工作方式类似，只是您的`chrony`配置文件位于*/etc/chrony/*而不仅仅是*/etc*：

```
$ sudo yum -y install chrony

$ sudo apt install chrony

$ sudo systemctl enable chronyd
Created symlink /etc/systemd/system/multi-user.target.wants/chronyd.service 
→ /usr/lib/systemd/system/chronyd.service.

$ sudo systemctl start chronyd
```

`chrony`包提供了`chrony`守护程序`chronyd`以及一个命令行界面实用程序，具有数十个选项，您可以在其手册页中找到。要执行快速检查，请使用以下命令：

```
$ chronyc activity
200 OK
4 sources online
0 sources offline
0 sources doing burst (return to online)
0 sources doing burst (return to offline)
0 sources with unknown address
```

您还可以将`chrony`配置为您本地网络的时间服务器。要这样做，请取消注释系统中*/etc/chrony.conf*文件中的以下两行：

```
# Allow NTP client access from local network.
#allow 192.168.0.0/16

# Serve time even if not synchronized to a time source.
#local stratum 10
```

更改`Allow`行以涵盖您的子网，并重新启动`chronyd`：

```
$ sudo systemctl restart chronyd
```

要设置其他 Linux 系统使用您的`chrony`服务器，请将以下行输入到您的*/etc/chrony.conf*文件中：

```
server  192.168.1.80 prefer iburst
```

`prefer` 指定告诉 `chrony` 应首先查询本地系统以获取正确的时间。重新启动 `chronyd` 以接受新设置，并使用以下命令检查您的 `chronyd` 源：

```
$ chronyc sources
MS Name/IP address         Stratum Poll Reach LastRx Last sample              
===============================================================================
^? server1                       0   6     0     -     +0ns[   +0ns] +/-    0ns
^- mon2.hostin.cc                2   6     7     1    +37ms[  +31ms] +/-  138ms
^+ ntp.netnod.se                 1   6     7     1  +9151us[+2267us] +/-   81ms
^? nobody.yourvserver.net        2   6     1     4  -2309us[-9194us] +/-   65ms
^* nettuno.ntp.irh.it            2   6     7     1  -4454us[  -11ms] +/-   67ms
```

您还可以通过注释 */etc/chrony.conf* 中的“pool”行来配置所有客户端系统仅使用本地服务器。您还可以编辑 *chrony.conf* 文件以设置更具体的设置。我展示的是一个最小但可工作的配置。

###### 警告

虽然 `cron` 和 `chrony` 听起来相似，都处理时间安排，并共同工作，但它们实际上是不同的。`cron` 实用程序安排在特定日期和时间执行作业，而 `chrony` 与外部时间服务器同步系统时钟。`chrony` 保持系统时间稳定，以便 `cron` 作业在正确的时间运行，尤其是在跨多个系统定时作业时尤为重要。

# 摘要

*时机是关键。* 调度作业、同步本地系统的时间、在系统之间定时自动化脚本以及与外部“真实源”同步时间是至关重要的。自动化只是保持系统时间同步的原因之一。安全性是另一个原因。考虑这样的情况：您正试图隔离安全事件，而您的系统时间未同步。要确定事件发生的时间和持续时间将变得困难。

自动化是作为系统管理员工作的重要部分。没有足够的时间手动完成每个必需的任务。您必须将重复的琐碎任务交给系统。它们不会抱怨、疲倦或输入错误命令。自动化是一件好事，您应该接受它。尽量自动化以解脱出手工作业的困境。
