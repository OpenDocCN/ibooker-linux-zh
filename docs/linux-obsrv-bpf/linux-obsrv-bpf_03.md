# 第二章：运行您的第一个 BPF 程序

BPF 虚拟机能够响应内核触发的事件运行指令。然而，并非所有 BPF 程序都能访问内核触发的所有事件。当您将程序加载到 BPF 虚拟机时，您需要决定正在运行的程序类型。这告知内核您的程序将在何处被触发。它还告诉 BPF 验证器，您的程序中将允许哪些辅助功能。选择程序类型还意味着选择您的程序正在实现的接口。此接口确保您可以访问适当类型的数据，以及您的程序是否可以直接访问网络数据包。

在本章中，我们向您展示如何编写您的第一个 BPF 程序。我们还将指导您了解您可以创建的不同类型的 BPF 程序（截至本书编写时）。多年来，内核开发人员一直在添加可以附加 BPF 程序的不同入口点。这项工作尚未完成，他们正在每天发现利用 BPF 的新方法。在本章中，我们将专注于一些最有用的程序类型，并试图让您领略 BPF 的潜力。在未来的章节中，我们还会介绍许多其他的 BPF 程序示例。

本章还将介绍 BPF 验证器在运行您的程序中所起的作用。此组件验证您的代码是否安全执行，并帮助您编写不会导致意外结果的程序，例如内存耗尽或突然的内核崩溃。但让我们从头开始讲述编写您自己的 BPF 程序的基础知识。

# 编写 BPF 程序

编写 BPF 程序的最常见方法是使用 LLVM 编译的 C 语言子集。LLVM 是一个通用编译器，可以生成不同类型的字节码。在本例中，LLVM 将生成 BPF 汇编代码，稍后我们将加载到内核中。我们不会在本书中展示太多 BPF 汇编代码。经过长时间的讨论，我们决定更好地向您展示如何在特定情况下使用它的示例，但您可以轻松在网上或 BPF 手册中找到多个参考资料。在未来的章节中，我们会展示 BPF 汇编的简短示例，在这些章节中，使用汇编比 C 更合适，例如在内核中控制入站系统调用的 Seccomp 过滤器中。我们在第八章中更详细地讨论 Seccomp。

内核提供了`bpf`系统调用，用于在编译后将程序加载到 BPF 虚拟机中。此系统调用除了加载程序外，还用于其他操作，在后续章节中会有更多的使用示例。内核还提供了几种实用工具，用于为您抽象加载 BPF 程序的过程。在本书的第一个代码示例中，我们使用这些辅助工具向您展示了 BPF 的“Hello World”示例：

```
#include <linux/bpf.h>
#define SEC(NAME) __attribute__((section(NAME), used))

SEC("tracepoint/syscalls/sys_enter_execve")
int bpf_prog(void *ctx) {
  char msg[] = "Hello, BPF World!";
  bpf_trace_printk(msg, sizeof(msg));
  return 0;
}

char _license[] SEC("license") = "GPL";
```

这个第一个程序中有一些有趣的概念。我们使用属性`SEC`来告知 BPF VM 何时运行这个程序。在这种情况下，当检测到`execve`系统调用的跟踪点时，我们将运行这个 BPF 程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码以检查内核的执行过程。我们在第四章中详细讨论了跟踪点，但现在你只需要知道`execve`是一个执行其他程序的指令。因此，每当内核检测到程序执行另一个程序时，我们将看到消息`Hello, BPF World!`。

在这个示例的结尾，我们还指定了这个程序的许可证。因为 Linux 内核使用 GPL 许可证，所以只能加载同样以 GPL 许可证发布的程序。如果我们将许可证设置为其他类型，内核将拒绝加载我们的程序。我们使用`bpf_trace_printk`在内核跟踪日志中打印消息；你可以在*/sys/kernel/debug/tracing/trace_pipe*中找到这个日志。

我们将使用`clang`将这个第一个程序编译成一个有效的 ELF 二进制文件。这是内核期望加载的格式。我们将把我们的第一个程序保存在一个叫做`bpf_program.c`的文件中以便编译它：

```
clang -O2 -target bpf -c bpf_program.c -o bpf_program.o
```

你会在[书中代码示例的 GitHub 存储库](https://oreil.ly/lbpf-repo)中找到一些编译这些程序的脚本，因此你不需要记住这个`clang`命令。

现在我们已经编译出了我们的第一个 BPF 程序，接下来需要将其加载到内核中。正如我们提到的，我们使用内核提供的特殊助手来抽象编译和加载程序的样板代码。这个助手叫做`load_bpf_file`，它接受一个二进制文件并尝试将其加载到内核中。你可以在[书中所有示例的 GitHub 存储库](https://oreil.ly/lbpf-repo)中找到这个助手，位于*bpf_load.h*文件中，如下所示：

```
#include <stdio.h>
#include <uapi/linux/bpf.h>
#include "bpf_load.h"

int main(int argc, char **argv) {
  if (load_bpf_file("hello_world_kern.o") != 0) {
    printf("The kernel didn't load the BPF program\n");
    return -1;
  }

  read_trace_pipe();

  return 0;
}
```

我们将使用一个脚本来编译这个程序，并将其链接为一个 ELF 二进制文件。在这种情况下，我们不需要指定一个目标，因为这个程序不会被加载到 BPF VM 中。我们需要使用一个外部库，并编写一个脚本可以很方便地将所有内容整合在一起：

```
TOOLS=../../../tools
INCLUDE=../../../libbpf/include
HEADERS=../../../libbpf/src
clang -o loader -l elf \
  -I${INCLUDE} \
  -I${HEADERS} \
  -I${TOOLS} \
  ${TOOLS}/bpf_load.c \
  loader.c
```

如果你想运行这个程序，你可以使用`sudo`来执行这个最终的二进制文件：`sudo ./loader`。`sudo`是一个 Linux 命令，它会让你在计算机上获得 root 权限。如果你不使用`sudo`来运行这个程序，你将会收到一个错误消息，因为大多数 BPF 程序只能由拥有 root 权限的用户加载到内核中。

当你运行这个程序时，即使你的电脑上什么也不做，几秒钟后你也会开始看到我们的`Hello, BPF World!`消息。这是因为在你的计算机后台运行的程序可能正在执行其他程序。

当你停止这个程序时，消息将不再显示在你的终端上。BPF 程序在加载它们的程序终止后立即从虚拟机中卸载。在接下来的章节中，我们将探讨如何使 BPF 程序持久化，即使它们的加载程序已经终止，但目前我们不打算引入太多的概念。这是一个重要的概念要记住，因为在许多情况下，你会希望你的 BPF 程序在后台运行，收集系统数据，而不管其他进程是否在运行。

现在你已经看到了 BPF 程序的基本结构，我们可以深入探讨你可以编写的各种类型的程序，这将使你能够访问 Linux 内核中的不同子系统。

# BPF 程序类型

尽管在程序内没有明确的分类，你很快会意识到，本节中涵盖的所有类型都根据它们的主要目的分为两类。

第一个类别是*跟踪*。你可以编写的许多程序将帮助你更好地了解系统中正在发生的事情。它们直接提供有关系统行为和其运行的硬件的信息。它们可以访问与特定程序相关的内存区域，并从运行中的进程中提取执行跟踪。它们还直接提供访问分配给每个特定进程的资源，从文件描述符到 CPU 和内存使用情况。

第二类别是*网络*。这些类型的程序允许你检查和操作系统中的网络流量。它们允许你过滤从网络接口接收到的数据包，甚至完全拒绝这些数据包。不同类型的程序可以附加到内核中网络处理的不同阶段。这既有优势也有劣势。例如，你可以将 BPF 程序附加到网络事件，即在你的网络驱动程序接收到数据包时，但这个程序将只能访问关于数据包的较少信息，因为内核目前没有足够的信息提供给你。另一方面，你可以将 BPF 程序附加到网络事件，即将它们传递给用户空间之前的立即阶段。在这种情况下，你将获得关于数据包的更多信息，这将帮助你做出更为明智的决策，但你需要付出完全处理数据包的成本。

我们接下来展示的程序类型列表没有划分成类别；我们按照它们被添加到内核中的时间顺序介绍这些类型。我们将这一部分中最少使用的程序移至末尾，并且目前我们将重点放在对你更有用的程序上。如果你对我们在这里没有详细介绍的任何程序感兴趣，你可以在[`man 2 bpf`](https://oreil.ly/qXl0F)中了解更多信息。

## 套接字过滤程序

`BPF_PROG_TYPE_SOCKET_FILTER` 是添加到 Linux 内核的第一个程序类型。当您将 BPF 程序附加到原始套接字时，您可以访问该套接字处理的所有数据包。套接字过滤程序不允许您修改这些数据包的内容或更改这些数据包的目的地；它们仅允许您观察这些数据包。您的程序接收到的元数据包含与网络堆栈相关的信息，例如用于传递数据包的协议类型。

我们将在第六章中更详细地介绍套接字过滤和其他网络程序。

## Kprobe 程序

正如您将在第四章中看到的那样，在我们讨论跟踪时，kprobe 是您可以动态附加到内核中某些调用点的函数。BPF kprobe 程序类型允许您将 BPF 程序用作 kprobe 处理程序。它们使用类型 `BPF_PROG_TYPE_KPROBE` 定义。BPF VM 确保您的 kprobe 程序始终安全运行，这是传统 kprobe 模块的优势。您仍然需要记住，kprobe 不被视为内核的稳定入口点，因此您需要确保您的 kprobe BPF 程序与您使用的特定内核版本兼容。

当您编写附加到 kprobe 的 BPF 程序时，您需要决定它是在函数调用的第一条指令执行还是在调用完成时执行。您需要在 BPF 程序的节头中声明此行为。例如，如果您希望在内核调用 `exec` 系统调用时检查参数，则需要将程序附加到调用的开始位置。在这种情况下，您需要设置节头 `SEC("kprobe/sys_exec")`。如果您希望检查调用 `exec` 系统调用的返回值，则需要设置节头 `SEC("kretprobe/sys_exec")`。

关于 kprobe，我们在本书的后续章节中会详细讨论。它们是理解使用 BPF 进行跟踪的基本组成部分。

## 跟踪点程序

这种类型的程序允许您将 BPF 程序附加到内核提供的跟踪点处理程序上。跟踪点程序使用类型 `BPF_PROG_TYPE_TRACEPOINT` 定义。正如您将在第四章中看到的那样，跟踪点是内核代码库中的静态标记，允许您为跟踪和调试目的注入任意代码。它们比 kprobe 不太灵活，因为它们需要在内核中预先定义，但是在其引入内核后保证稳定。这在您想要调试系统时提供了更高的可预测性水平。

系统中的所有跟踪点都在目录 */sys/kernel/debug/tracing/events* 中定义。在那里，您会找到包含任何跟踪点的每个子系统，您可以将 BPF 程序附加到这些跟踪点上。一个有趣的事实是，BPF 声明了自己的跟踪点，因此您可以编写检查其他 BPF 程序行为的 BPF 程序。BPF 跟踪点在 */sys/kernel/debug/tracing/events/bpf* 中定义。例如，您可以在那里找到 *bpf_prog_load* 的跟踪点定义。这意味着您可以编写一个 BPF 程序，检查其他 BPF 程序何时被加载。

与 kprobes 类似，跟踪点是理解使用 BPF 进行跟踪的另一个基本组成部分。我们将在接下来的章节中更详细地讨论它们，并向您展示如何编写程序以利用它们。

## XDP 程序

XDP 程序允许您编写在网络数据包到达内核时非常早期执行的代码。它们使用类型 `BPF_PROG_TYPE_XDP` 进行定义。它仅公开来自数据包的有限信息，因为内核尚未处理这些信息。由于数据包在早期被执行，您对如何处理该数据包具有更高的控制水平。

XDP 程序定义了几种您可以控制的操作，这些操作允许您决定如何处理数据包。您可以从您的 XDP 程序返回 `XDP_PASS`，这意味着数据包应该传递给内核中的下一个子系统。您也可以返回 `XDP_DROP`，这意味着内核应完全忽略这个数据包，不做任何其他操作。您还可以返回 `XDP_TX`，这意味着数据包应该转发回首次接收该数据包的网络接口卡（NIC）。

这种控制水平为网络层中许多有趣的程序打开了大门。XDP 已成为 BPF 的主要组成部分之一，这也是为什么我们在本书中专门讨论它的一个章节。在第七章中，我们讨论了 XDP 的许多强大用例，如实施程序以保护您的网络免受分布式拒绝服务（DDoS）攻击。

## Perf 事件程序

这些类型的 BPF 程序允许您将您的 BPF 代码附加到 *Perf 事件* 上。它们使用类型 `BPF_PROG_TYPE_PERF_EVENT` 进行定义。Perf 是内核中的内部性能分析器，用于发出硬件和软件的性能数据事件。您可以使用它监视许多内容，从计算机的 CPU 到系统上运行的任何软件。当您将一个 BPF 程序附加到 Perf 事件时，每次 Perf 生成数据以供分析时，您的代码将被执行。

## Cgroup Socket 程序

此类程序允许您将 BPF 逻辑附加到控制组（cgroups）上。它们使用类型`BPF_PROG_TYPE_CGROUP_SKB`进行定义。它们允许 cgroups 在其包含的进程中控制网络流量。通过这些程序，您可以在传递到 cgroup 中的进程之前决定对网络数据包采取何种操作。内核试图将任何数据包传递到同一 cgroup 中的任何进程时，都将通过这些过滤器。同时，您还可以决定当 cgroup 中的进程通过该接口发送网络数据包时采取何种操作。

正如您所见，它们的行为类似于`BPF_PROG_TYPE_SOCKET_FILTER`程序。主要区别在于`BPF_PROG_TYPE_CGROUP_SKB`程序附加到 cgroup 中的所有进程，而不是特定进程；这种行为适用于给定 cgroup 中创建的当前和未来套接字。附加到 cgroups 的 BPF 程序在容器环境中特别有用，其中进程组受 cgroups 约束，并且您可以在所有进程上应用相同的策略，而无需单独识别每个进程。[Cillium](https://github.com/cilium/cilium)是一个流行的开源项目，为 Kubernetes 提供负载均衡和安全功能，广泛使用 cgroup 套接字程序来应用其策略，而不是在孤立的容器中。

## Cgroup Open Socket Programs

此类程序允许您在 cgroup 中的任何进程打开网络套接字时执行代码。这类行为与附加到 cgroup 套接字缓冲区的程序类似，但不是在网络数据包通过时提供访问权限，而是在进程打开新套接字时控制操作。它们使用类型`BPF_PROG_TYPE_CGROUP_SOCK`进行定义。这对于在不需要单独限制每个进程能力的情况下，提供安全性和访问控制非常有用。

## Socket Option Programs

此类程序允许您在运行时修改套接字连接选项，而数据包通过内核网络堆栈的多个阶段。它们与 cgroups 附加，类似于`BPF_PROG_TYPE_CGROUP_SOCK`和`BPF_PROG_TYPE_CGROUP_SKB`，但与这些程序类型不同的是，在连接生命周期中可以多次调用它们。这些程序使用类型`BPF_PROG_TYPE_SOCK_OPS`进行定义。

当您使用此类型创建 BPF 程序时，您的函数调用将接收一个名为`op`的参数，该参数表示内核即将执行的与套接字连接相关的操作；因此，您可以知道程序在连接生命周期中的哪个点被调用。有了这些信息，您可以访问诸如网络 IP 地址和连接端口之类的数据，并可以修改连接选项以设置超时并改变给定数据包的往返延迟时间。

例如，Facebook 使用这种方式为同一数据中心内的连接设置短恢复时间目标（RTO）。RTO 是系统在失败后预计恢复的时间，或者在这种情况下，是网络连接。该目标还代表系统在遭受不可接受后果之前可以不可用的时间。在 Facebook 的情况下，它假设同一数据中心中的机器应具有较短的 RTO，并通过使用 BPF 程序修改此阈值。

## 套接字映射程序

`BPF_PROG_TYPE_SK_SKB`程序让你可以访问套接字映射和套接字重定向。正如你将在下一章中学到的那样，套接字映射允许你保持对多个套接字的引用。当你拥有这些引用时，你可以使用特殊的帮助程序将从一个套接字收到的数据包重定向到另一个套接字。当你希望使用 BPF 实现负载均衡能力时，这非常有趣。通过跟踪多个套接字，你可以在内核空间中转发网络数据包。像 Cillium 和 [Facebook's Katran](https://oreil.ly/wDtfR) 这样的项目大量使用这些类型的程序来进行网络流量控制。

## cgroup 设备程序

这种类型的程序允许你决定 cgroup 内的操作是否可以针对特定设备执行。这些程序的类型定义为`BPF_PROG_TYPE_CGROUP_DEVICE`。cgroups 的第一个实现（v1）具有一种机制，允许你为特定设备设置权限；然而，cgroups 的第二次迭代缺乏此功能。引入这种类型的程序是为了提供该功能。同时，编写 BPF 程序使你在需要时能够更灵活地设置这些权限。

## 套接字消息传递程序

这些类型的程序让你控制是否应将发送到套接字的消息传递。它们的类型定义为`BPF_PROG_TYPE_SK_MSG`。当内核创建套接字时，它将套接字存储在上述套接字映射中。该映射使内核能够快速访问特定组的套接字。当你将套接字消息 BPF 程序附加到套接字映射时，在将消息传递给套接字之前，所有发送到这些套接字的消息都将通过程序进行过滤。在过滤消息之前，内核会复制消息中的数据，以便你可以读取并决定如何处理它。这些程序有两种可能的返回值：`SK_PASS`和`SK_DROP`。如果你希望内核将消息发送到套接字，则使用第一个值；如果你希望内核忽略消息并且不将其传递到套接字，则使用后者。

## 原始跟踪点程序

我们之前谈到过一种程序类型，该程序访问内核中的跟踪点。内核开发人员添加了一个新的跟踪点程序，以满足访问内核保存的跟踪点参数的需求。此格式使您可以访问内核正在执行的任务的更详细信息；但是，它会带来小的性能开销。大多数情况下，您会希望在程序中使用常规的跟踪点以避免性能开销，但是需要时可以使用原始跟踪点访问原始参数是一个好主意。这些程序使用类型 `BPF_PROG_TYPE_RAW_TRACEPOINT` 进行定义。

## Cgroup Socket Address 程序

这种类型的程序允许您在特定 cgroup 控制的情况下操作用户空间程序附加到的 IP 地址和端口号。当您的系统使用多个 IP 地址时，希望确保特定的用户空间程序使用相同的 IP 地址和端口时，存在使用案例。这些 BPF 程序使您能够在将这些用户空间程序放入同一 cgroup 时操作这些绑定。这确保了所有进入和离开这些应用程序的连接使用 BPF 程序提供的 IP 和端口。这些程序使用以下类型进行定义：`BPF_PROG_TYPE_CGROUP_SOCK_ADDR`。

## Socket Reuseport 程序

`SO_REUSEPORT` 是内核中的一个选项，允许同一主机上的多个进程绑定到同一个端口。当您希望在多个线程之间分布负载时，此选项可以提高接受网络连接的性能。

`BPF_PROG_TYPE_SK_REUSEPORT` 程序类型允许您编写 BPF 程序，以钩入内核用于决定是否重新使用端口的逻辑。如果您的 BPF 程序返回 `SK_DROP`，则可以防止程序重新使用相同的端口；如果返回 `SK_PASS`，则可以通知内核继续按照其自身的重用例程操作。

## 流解剖程序

流解剖器是内核的一个组件，跟踪网络数据包需要通过的不同层次，从其抵达系统到交付给用户空间程序的过程。它允许您使用不同的分类方法控制数据包的流向。内核中的内置解剖器称为*Flower 分类器*，被防火墙和其他过滤设备用于决定如何处理特定的数据包。

`BPF_PROG_TYPE_FLOW_DISSECTOR` 程序旨在钩入流解剖路径中的逻辑。它们提供了内置解剖器无法提供的安全保证，例如始终保证程序终止，这在内置解剖器中可能无法保证。这些 BPF 程序可以修改网络数据包在内核内部遵循的流程。

## 其他 BPF 程序

我们已经讨论了在不同环境中使用的程序类型，但值得注意的是，还有一些其他额外的 BPF 程序类型我们尚未涵盖。以下是我们在这里仅简要提及的几种程序：

流量分类器程序

`BPF_PROG_TYPE_SCHED_CLS`和`BPF_PROG_TYPE_SCHED_ACT`是两种 BPF 程序类型，允许您对网络流量进行分类并修改套接字缓冲区中数据包的某些属性。

轻量级隧道程序

`BPF_PROG_TYPE_LWT_IN`、`BPF_PROG_TYPE_LWT_OUT`、`BPF_PROG_TYPE_LWT_XMIT`和`BPF_PROG_TYPE_LWT_SEG6LOCAL`是允许您将代码附加到内核轻量级隧道基础设施的 BPF 程序类型。

红外设备程序

`BPF_PROG_TYPE_LIRC_MODE2`程序允许您通过连接到红外设备（例如遥控器）来附加 BPF 程序，以增加乐趣。

这些程序是专业化的，它们的使用尚未被社区广泛采纳。

接下来，我们将讨论 BPF 如何确保在内核加载后您的程序不会导致系统灾难性故障。这是一个重要的主题，因为理解程序加载的方式也影响到如何编写这些程序。

# BPF 验证程序

如果没有 BPF 验证程序，任何人都可以在 Linux 内核中执行任意代码，这听起来一开始就像一个糟糕的主意。如果不是因为 BPF 验证程序，运行 BPF 程序在生产系统中的风险将会太高。用内核网络维护者之一 Dave S. Miller 的话来说，“我们的 eBPF 程序与毁灭的深渊之间仅有的东西就是 eBPF 验证程序。”

很显然，BPF 验证程序也是在您的系统上运行的程序，并且它是受到高度审查的对象，以确保其正确执行其职能。在过去的几年中，安全研究人员已经发现了验证程序中的一些漏洞，这些漏洞允许攻击者在内核中访问随机内存，即使是作为非特权用户也可以。您可以在美国国土安全部赞助的公共漏洞和暴露目录（CVE）中了解更多类似的漏洞信息，这是已知安全威胁的列表。例如，CVE-2017-16995 描述了任何用户如何读取和写入内核内存以及绕过 BPF 验证器的详细信息。

在本节中，我们将指导您了解验证程序采取的措施，以防止类似刚刚描述的问题。

审核程序执行的第一个检查是对 VM 即将加载的代码的静态分析。这个首次检查的目标是确保程序有一个预期的结束。为了做到这一点，审核程序创建一个直接无环图（DAG）来表示代码。审核程序分析的每个指令都成为图中的一个节点，并且每个节点链接到下一个指令。审核程序生成此图后，执行深度优先搜索（DFS）以确保程序能够完成并且代码不包含危险路径。这意味着它将遍历图的每个分支，一直到分支的底部，以确保没有递归循环。

这些是审核程序在首次检查期间可能拒绝你的代码的条件：

+   程序不包含控制循环。为了确保程序不会陷入无限循环，审核程序拒绝任何类型的控制循环。已经有提案允许 BPF 程序中的循环，但截至目前尚未采纳。

+   程序不能尝试执行超过内核允许的最大指令数。目前，允许执行的最大指令数为 4,096。这个限制是为了防止 BPF 程序无限运行。在第三章中，我们讨论了如何嵌套不同的 BPF 程序以安全方式绕过这个限制。

+   程序不包含任何无法访问的指令，例如永远不会执行的条件或函数。这可以防止在虚拟机中加载死代码，这也会延迟 BPF 程序的终止。

+   程序不能尝试跳出其界限。

审核程序执行的第二个检查是对 BPF 程序的干行检查。这意味着审核程序将尝试分析程序将要执行的每个指令，以确保它不执行任何无效的指令。此外，此执行还检查所有内存指针是否被正确访问和解引用。最后，干行检查还通知审核程序有关程序控制流的信息，以确保无论程序采用哪种控制路径，它最终都会到达`BPF_EXIT`指令。为了做到这一点，审核程序在一个栈中跟踪所有访问的分支路径，在采用新路径之前评估这些路径，以确保不会多次访问特定路径。这两个检查通过后，审核程序认为程序可以安全执行。

`bpf`系统调用允许你调试审核程序的检查，如果你有兴趣查看程序的分析过程。使用这个系统调用加载程序时，你可以设置多个属性，这些属性将使审核程序打印其操作日志：

```
union bpf_attr attr = {
  .prog_type = type,
  .insns     = ptr_to_u64(insns),
  .insn_cnt  = insn_cnt,
  .license   = ptr_to_u64(license),
  .log_buf   = ptr_to_u64(bpf_log_buf),
  .log_size  = LOG_BUF_SIZE,
  .log_level = 1,
};

bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
```

`log_level` 字段告诉验证器是否打印任何日志。当您将其设置为 1 时，它将打印其日志；如果设置为 0，则不打印任何内容。如果您想要打印验证器日志，则还需要提供日志缓冲区及其大小。此缓冲区是一个多行字符串，您可以打印以检查验证器所做的决策。

BPF 验证器在您在内核中运行任意程序时发挥着重要作用，以确保系统安全和可用性，尽管有时候它的某些决策可能难以理解。如果在尝试加载您的程序时遇到验证问题，请不要绝望。本书的其余部分将通过安全示例指导您，这将帮助您了解如何以安全的方式编写自己的程序。

下一节将介绍 BPF 如何在内存中结构化程序信息。程序结构化的方式将有助于清楚地访问 BPF 内部，帮助您调试和了解程序的行为方式。

# BPF 类型格式

BPF 类型格式（BTF）是一组元数据结构，用于增强 BPF 程序、映射和函数的调试信息。BTF 包括源信息，因此像我们在第五章中讨论的 BPFTool 这样的工具可以为您展示更丰富的 BPF 数据解释。这些元数据存储在二进制程序的特殊“.BFT”元数据部分下。BTF 信息有助于使您的程序更易于调试，但会显著增加二进制文件的大小，因为它需要跟踪程序中声明的所有类型信息。BPF 验证器还使用此信息来确保程序定义的结构类型是正确的。

BTF 专门用于注释 C 类型。像 LLVM 这样的 BPF 编译器知道如何为您包含这些信息，因此您不需要通过耗时的任务向每个结构添加信息。然而，在某些情况下，工具链仍然需要一些注释来增强您的程序。在后续章节中，我们将描述这些注释的作用以及像 BPFTool 这样的工具如何显示这些信息。

# BPF 尾调用

BPF 程序可以使用*尾调用*来调用其他 BPF 程序。这是一个强大的特性，因为它允许您通过组合较小的 BPF 函数来组装更复杂的程序。在 5.2 版本之前的内核版本中，BPF 程序可以生成的机器指令数有一个硬限制。为了确保程序能够在合理的时间内终止，这个限制被设置为 4,096 条。然而，随着人们构建更复杂的 BPF 程序，他们需要一种扩展内核所施加的指令限制的方法，这就是尾调用发挥作用的地方。从内核 5.2 版本开始，指令限制增加到一百万条指令。在这种情况下，尾调用嵌套也受到限制，最多可以组合 32 个程序形成一个链条，以生成更复杂的问题解决方案。

当您从另一个 BPF 程序调用 BPF 程序时，内核会完全重置程序上下文。记住这一点很重要，因为您可能需要一种在程序之间共享信息的方式。每个 BPF 程序作为其参数接收的上下文对象将无法帮助我们解决这个数据共享问题。在接下来的章节中，我们将讨论 BPF 映射作为在程序之间共享信息的一种方式。在那里，我们还会向您展示如何使用尾调用从一个 BPF 程序跳转到另一个程序。

# 结论

在本章中，我们引导您通过第一个代码示例来理解 BPF 程序。我们还描述了您可以使用 BPF 编写的所有类型的程序。如果这里介绍的一些概念还不清楚，不要担心；随着我们在本书中的进展，我们会向您展示更多这些程序的示例。我们还介绍了 BPF 所采取的重要验证步骤，以确保您的程序可以安全运行。

在接下来的章节中，我们将更深入地探讨这些程序并展示更多示例。我们还将讨论 BPF 程序如何与用户空间中的对应程序进行通信，以及它们如何共享信息。
