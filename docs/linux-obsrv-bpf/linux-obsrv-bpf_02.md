# 第一章：介绍

在过去几十年里，计算系统的复杂性不断增长。理解软件行为的推理已经创造了多个业务类别，所有这些类别都试图解决获得复杂系统洞察的挑战。获取这种可见性的一种方法是分析计算系统中所有应用程序生成的数据日志。日志是信息的重要来源。它们可以为您提供关于应用程序行为的精确数据。但是，它们也限制您，因为您只能获取应用程序构建工程师在这些日志中公开的信息。以日志格式收集任何额外信息可能与反编译程序并查看执行流程一样具有挑战性。另一种流行的方法是使用指标来推理程序行为的原因。指标在数据格式上与日志不同；日志提供显式数据，而指标聚合数据以衡量程序在特定时间点的行为方式。

*可观察性* 是一种从不同角度解决此问题的新兴实践。人们定义可观察性为我们能够从任何给定系统中提出任意问题并获得复杂答案的能力。可观察性、日志和指标聚合之间的一个关键区别在于您收集的数据。通过实践可观察性，您需要在任何时间点回答任意问题，因此推理数据的唯一方式是收集系统可以生成的所有数据，并在必要时进行聚合以回答您的问题。

纳西姆·尼古拉斯·塔勒布（Nassim Nicholas Taleb），畅销书作者，如《反脆弱：从混乱中获益的事物》（Penguin Random House），他为意外事件，具有重大后果，如果在其发生之前观察到它们则可以预料到的术语*黑天鹅*提出了流行。在他的书《黑天鹅》（Penguin Random House）中，他理性地阐述了如何通过拥有相关数据来帮助减少这些罕见事件的风险。黑天鹅事件在软件工程中比我们想象的更常见，并且是不可避免的。因为我们可以假设无法防止这些事件，我们唯一的选择就是尽可能多地获取关于它们的信息，以在不影响业务系统的情况下解决它们。可观察性帮助我们构建强大的系统并减少未来的黑天鹅事件，因为它基于这样一个前提：您正在收集可以回答任何未来问题的任何数据。研究黑天鹅事件和实践可观察性在一个中心点汇聚，即您从系统中收集的数据。

Linux 容器是 Linux 内核上一组功能的抽象，用于隔离和管理计算机进程。传统上负责资源管理的内核还提供了任务隔离和安全性。在 Linux 中，容器基于的主要功能是命名空间和控制组（cgroups）。命名空间是将任务彼此隔离的组件。从某种意义上说，当您在命名空间内部时，就像在计算机上没有其他任务在运行。控制组是提供资源管理的组件。从操作角度来看，它们为您提供了对 CPU、磁盘 I/O、网络等任何资源使用的精细控制。在过去的十年中，随着 Linux 容器的流行，软件工程师设计大型分布式系统和计算平台的方式发生了变化。多租户计算已完全依赖于内核中的这些特性。

通过如此依赖于 Linux 内核的低级能力，我们已经利用了一个新的复杂性和信息来源，这些都是我们在设计可观测系统时需要考虑的。内核是一个事件驱动系统，这意味着所有的工作都是基于事件描述和执行的。打开文件是一种事件，CPU 执行任意指令是一个事件，接收网络数据包也是一个事件，等等。伯克利数据包过滤器（BPF）是内核中可以检查这些新信息来源的子系统。BPF 允许你编写程序，在内核触发任何事件时安全执行。BPF 提供强大的安全保证，防止你在这些程序中引入系统崩溃和恶意行为。BPF 正在推动一批新工具的出现，帮助系统开发人员观察和处理这些新平台。

在本书中，我们展示了 BPF 为您提供的能力，使任何计算系统更易于观察。我们还展示了如何利用多种编程语言编写 BPF 程序。我们已经将程序代码放在 GitHub 上，所以您无需复制粘贴。您可以在 Git 仓库中找到它，[本书的伴随资源](https://oreil.ly/lbpf-repo)。

但在我们开始专注于 BPF 的技术方面之前，让我们看看一切是如何开始的。

# BPF 的历史

1992 年，Steven McCanne 和 Van Jacobson 撰写了论文《BSD 数据包过滤器：用于用户级数据包捕获的新架构》。在这篇论文中，作者描述了如何为 Unix 内核实现一个网络数据包过滤器，其速度比当时的最新技术快 20 倍。数据包过滤器有一个特定的目的：为监视系统网络的应用程序提供来自内核的直接信息。有了这些信息，应用程序可以决定如何处理这些数据包。BPF 在数据包过滤中引入了两个重要的创新：

+   设计用于与基于寄存器的 CPU 高效工作的新虚拟机（VM）。

+   使用每个应用程序缓冲区来过滤数据包，而无需复制所有数据包信息。这最小化了 BPF 需要进行决策的数据量。

这些显著改进使得所有 Unix 系统都采用了 BPF 作为网络数据包过滤的首选技术，放弃了消耗更多内存且性能较差的旧实现。这种实现仍然存在于包括 Linux 内核在内的许多 Unix 内核衍生系统中。

在 2014 年初，Alexei Starovoitov 引入了扩展 BPF 实现。这种新设计针对现代硬件进行了优化，使其生成的指令集比旧 BPF 解释器生成的机器码更快。扩展版本还将 BPF 虚拟机中的寄存器数量从两个 32 位寄存器增加到十个 64 位寄存器。寄存器数量的增加以及它们的宽度打开了编写更复杂程序的可能性，因为开发人员可以通过函数参数交换更多信息。这些变化及其他改进使扩展 BPF 版本比原始 BPF 实现快了多达四倍。

这种新实现的最初目标是优化处理网络过滤器的内部 BPF 指令集。在这一点上，BPF 仍然局限于内核空间，只有少数用户空间程序可以编写 BPF 过滤器供内核处理，例如 Tcpdump 和 Seccomp，我们将在后面的章节中讨论。如今，这些程序仍然为旧 BPF 解释器生成字节码，但内核将这些指令转换为大大改进的内部表示形式。

在 2014 年 6 月，扩展版 BPF 暴露给了用户空间。这是 BPF 未来的一个转折点。正如 Alexei 在引入这些更改的补丁中所写道：“这个补丁集展示了 eBPF 的潜力。”

BPF 成为顶级内核子系统，并不再局限于网络堆栈。BPF 程序开始看起来更像内核模块，非常注重安全性和稳定性。与内核模块不同，BPF 程序不需要重新编译内核，并且保证在不崩溃的情况下完成执行。

我们在下一章中将讨论的 BPF 验证器添加了这些必需的安全性保证。它确保任何 BPF 程序都能在不崩溃的情况下完成执行，并确保程序不会尝试访问超出范围的内存。然而，这些优势也带来了一些限制：程序有最大允许的大小，并且循环必须是有界的，以确保系统内存永远不会被糟糕的 BPF 程序耗尽。

随着使 BPF 从用户空间可访问的更改，内核开发人员还添加了一个新的系统调用（syscall），`bpf`。这个新的 syscall 将成为用户空间和内核之间通信的中心组成部分。我们将在本书的第 2 和 3 章中讨论如何使用这个 syscall 来处理 BPF 程序和映射。

BPF 映射将成为内核和用户空间之间交换数据的主要机制。第二章 展示了如何使用这些专门的结构从内核收集信息，以及向已在内核中运行的 BPF 程序发送信息。

扩展 BPF 版本是本书的起点。在过去的五年中，自从引入这个扩展版本以来，BPF 已经有了显著的进展，我们详细介绍了 BPF 程序、BPF 映射以及受这一进展影响的内核子系统的演变。

# 架构

BPF 内核中的架构是非常迷人的。我们会在整本书中深入探讨其具体细节，但在本章中，我们想为您快速概述其工作原理。

正如我们之前提到的，BPF 是一个高度先进的虚拟机，在隔离环境中运行代码指令。在某种意义上，您可以将 BPF 看作是 Java 虚拟机（JVM）的工作方式，一个专门运行从高级编程语言编译而成的机器码的程序。编译器如 LLVM 和 GNU Compiler Collection（GCC）在不久的将来将提供对 BPF 的支持，允许您将 C 代码编译为 BPF 指令。在编译完成后，BPF 使用验证器确保程序在内核中运行时安全。它通过阻止可能会导致内核崩溃的代码运行来保护您的系统。如果您的代码是安全的，BPF 程序将加载到内核中。Linux 内核还整合了用于 BPF 指令的即时编译器（JIT）。JIT 将在程序验证后直接将 BPF 字节码转换为机器码，避免执行时间上的额外开销。这种架构的一个有趣之处在于，您不需要重新启动系统来加载 BPF 程序；您可以按需加载它们，并且您还可以编写自己的 init 脚本，在系统启动时加载 BPF 程序。

在内核运行任何 BPF 程序之前，它需要知道程序连接到哪个执行点。内核中有多个连接点，并且该列表正在增长。执行点由 BPF 程序类型定义；我们将在下一章中讨论它们。当您选择一个执行点时，内核还会提供特定的函数助手，您可以使用这些助手来处理程序接收到的数据，从而使执行点和 BPF 程序紧密耦合。

BPF 架构中的最后一个组件负责在内核和用户空间之间共享数据。这个组件称为 BPF *map*，我们在第三章中讨论了关于地图的内容。BPF 地图是双向结构，用于共享数据。这意味着你可以从内核和用户空间两方面写入和读取它们。有几种类型的结构，从简单的数组和哈希映射到专门的映射，允许你在其中保存整个 BPF 程序。

随着本书的进展，我们将更详细地介绍 BPF 架构中的每个组件。您还将学习如何利用 BPF 的可扩展性和数据共享，具体示例涵盖从堆栈跟踪分析到网络过滤和运行时隔离的主题。

# 结论

我们编写这本书是为了帮助你熟悉与 Linux 子系统 BPF 日常工作中需要的基本概念。BPF 仍然是一项发展中的技术，随着我们写作本书，新的概念和范式也在不断增长。理想情况下，这本书将通过为你提供 BPF 基础组件的坚实基础来轻松扩展你的知识。

下一章直接深入探讨了 BPF 程序的结构以及内核如何运行它们。它还涵盖了你可以附加这些程序的内核中的各个点。这将帮助你熟悉你的程序可以消耗的所有数据及其使用方法。
