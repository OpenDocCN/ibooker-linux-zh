# 第六章：管理文件和目录

Linux 提供了强大的基本控制来访问可配置权限的文件和目录。每个文件和目录都有三个所有权级别，包括用户、组和其他；以及多个访问级别，包括读取、写入和执行。您可以保护个人文件并控制谁可以访问它们，而根用户可以管理对命令、脚本、共享文件和系统文件的访问。

即使您正在使用更强的访问控制工具——如 SELinux 或 AppArmor，正确掌握基本原理仍然很重要。

在 Linux 系统上，人类用户和系统服务都有用户账户。一些系统服务需要用户账户来控制权限，就像人类用户一样。

每个文件都有三种类型的所有权：所有者、组和其他（有时*其他*表示为*全球*）。所有者是单个用户，组所有者是单个组，其他是所有能够访问文件的其他人。

每个文件有六种权限模式——读取、写入和可执行——以及三种特殊模式：*粘性位*、*设置用户 ID*和*设置组 ID*。

文件权限控制哪些用户可以创建、读取、编辑或删除文件，以及哪些用户可以执行命令。特殊模式控制谁可以移动、删除或重命名文件，以及谁可以以提升的权限执行命令。

目录权限控制哪些用户可以编辑或进入目录，以及谁可以读取、编辑、添加或删除目录中的文件。

记住基本的 Linux 安全原则：使用最小必要的权限来完成工作。

# 特权的限制

任何能够读取文件的人都可以复制它。

您无法阻止根用户或具有足够权限的*sudo*用户访问您的文件。

权限和所有权是文件系统的功能，并可以通过从另一个 Linux 实例读取存储设备来绕过，例如通过从可移动介质引导 Live Linux 来访问主机系统，或者将硬盘移除并连接到不同的机器。您只需要在挂载存储设备的系统上拥有根权限，并不需要了解原始文件的所有者和权限。

在 Linux 系统中，根用户，也称为超级用户，拥有至高无上的权力。根用户几乎可以做任何事情，包括编辑和删除其他用户的文件，进入任何目录和运行任何命令。普通或非特权用户可以通过*sudo*或*su*命令临时拥有根权限（见 Recipe 5.17 和 5.18）。

每个用户都有唯一的标识符（UID），并且至少属于一个组（见 Recipe 5.1）。组内的每个用户共享该组的权限。

要查看这一切是什么样子，请看*/etc*，其中包含系统配置文件：

```
 $ stat --format=%a:%A:%U:%G /etc
755:drwxr-xr-x:root:root

```

命令输出显示目录的*模式*，或者说权限集合，有两种表示方式，*755:drwxr-xr-x*。*755* 是八进制表示法，*drwxr-xr-x* 是符号表示法。这两种方式表示相同的模式，在这个例子中，表示目录所有者有无限制权限，而组和其他用户只能进入该目录。文件模式在本章节中有详细讨论。

*root:root* 是所有者和组。文件和目录可以有不同的所有者和组；例如，*/etc/cups* 的所有者是*root:lp*。

在本章中，你将学习特殊模式：*粘滞位*、*setuid* 和 *setgid*。setuid 和 setgid 模式将用户和组权限提升到与文件所有者相同的级别。这些只在特殊情况下使用，并且非常谨慎，因为特权升级可能是潜在的安全风险。粘滞位防止除文件所有者或具有 root 特权外的任何人删除、重命名或移动目录中他们不拥有的文件，比如 */tmp*。

你将学习如何设置所有权和模式，创建和删除文件和目录，配置默认权限，将文件所有权转移到不同的用户或组，以及复制、移动和重命名文件和目录。

# 使用 sudo

本食谱中的大多数示例使用美元符号命令提示符$，表示非特权用户。根据你自己的文件权限，某些操作可能需要使用*sudo*。

# 6.1 创建文件和目录

## 问题

你希望通过将文件放入目录中来组织你的文件。

## 解决方案

使用*mkdir*命令创建目录。以下示例在当前目录中创建一个新的子目录：

```
$ mkdir -v presentations
mkdir: created directory 'presentations'
```

在当前目录下创建一个距离两层的子目录及其父目录，使用*-p*（父级）选项：

```
$ mkdir -p presentations/2020/august
mkdir: created directory 'presentations/2020'
mkdir: created directory 'presentations/2020/august'
```

创建一个新的顶级目录，相对于根目录 /。你需要 root 权限才能执行此操作：

```
$ sudo mkdir -v /charts
mkdir: created directory '/charts'
```

在创建目录时，可以设置权限：

```
$ mkdir -m 0700 /home/duchess/dog-memes
```

文件由应用程序（如文字处理器和图像编辑器）和特殊命令（如*touch*）创建。*touch*命令创建一个新的空文件：

```
$ touch newfile.txt
```

参见食谱 6.2 学习如何使用*touch*快速创建批量文件进行测试。

## 讨论

如果你对文件树的可视化和所有目录如何相对于/而言感到困惑，请尝试*tree*命令。根目录 / 在顶部：

```
$ tree -L 1 /
/
├── backups
├── bin
├── boot
[...]
```

你可能已经注意到这个有些颠倒。在现实世界中，树是从根部分支出来的，但是*tree*命令显示的是目录树向下分支。这有其原因：我们从屏幕顶部向下阅读。

此示例仅列出根目录下的顶级目录。*-L 2* 显示第二级目录，*-L 3* 则显示到第三级，依此类推。

## 参见

+   食谱 6.2

+   *man 1 mkdir*

+   *man 1 touch*

+   *man 1 yes*

+   *man 1 tree*

# 6.2 快速创建批量文件进行测试

## 问题

您想要批量创建文件以测试文件权限，以及任何需要快速大量文件的测试。

## 解决方案

使用*touch*命令。以下示例创建一个新的空文件：

```
$ touch newfile.txt
```

创建 100 个空文件：

```
$ touch file{00..99}
```

这将创建 100 个新文件，命名为*file00*、*file01*、*file02*等。您可以给它们添加文件扩展名，并随意命名它们：

```
$ touch test{00..99}.doc
$ ls
test00.doc
test01.doc
test02.doc
[...]
```

在文件名中首先放置数字以便于排序：

```
$ touch {00..99}test.doc
$ ls
00test.doc
01test.doc
02test.doc
[...]

```

用*yes*命令快速填充文件内容。以下示例创建一个填充了重复行“This is a test file”的 500 MB 文件：

```
$ yes This is a test file | head -c 500 MB > testfile.txt

```

每个文件内容为 1 MB，批量创建 100 个文件：

```
$ for x in {01..100};
> do yes This is a test file | head -c 1MB > $x-testfile.txt;
> done 
```

新文件看起来像这样：

```
001-testfile.txt
002-testfile.txt
003-testfile.txt
[...]
```

## 讨论

您可以根据需要自定义此命令的多种方式：文件名、文件大小、编号以及*yes*的文本。

配方中的示例将文件名中的数字填充 0 以正确排序。大多数图形文件管理器正确处理带编号的文件名排序，但*ls*的默认排序是词典顺序。以下示例演示了一个 1 到 3 位数的数字范围：

```
$ touch {0..150}test.doc
$ ls -C1
0test.doc
100test.doc
101test.doc
102test.doc
103test.doc
104test.doc
105test.doc
106test.doc
107test.doc
108test.doc
109test.doc
10test.doc
110test.doc
111test.doc
112test.doc
113test.doc
114test.doc
115test.doc
116test.doc
117test.doc
118test.doc
119test.doc
11test.doc
120test.doc
121test.doc
[...]

```

词典排序将文件名视为文本字符串而不是整数和字符，并逐个比较每个数字和字母，从左到右。词典排序不知道 10 比 100 小，只知道 101 在 100 之后，102 在 101 之后，以及 10t 在 109 之后，因为字母跟在数字后面，所以*t*跟在*9*后面。

您可以使用前导零使所有数字具有相同的字符数，或者使用*ls -v*列出文件。这将把文件名中的数字视为整数而不是字符，因此它们将按正确的数字顺序列出。

## 参见

+   *man 1 ls*

+   *man 1 touch*

+   *man 1 yes*

# 6.3 使用相对路径和绝对路径

## 问题

您需要理解相对路径和绝对路径的区别，以及如何确定文件系统中的当前位置。

## 解决方案

绝对路径始终从根目录（/*/*）开始，例如*/boot*和*/etc*。相对路径相对于当前目录，没有前导斜杠。假设您在您的主目录中，并且它包含以下子目录：

```
madmax@client2:~$ ls --group-directories-first
 Audiobooks
 bin
 Desktop
 Documents
 Downloads
 games
 Music
 Pictures
 Public
 Templates
 Videos
```

在这个例子中，*Audiobooks*的绝对路径是*/home/madmax/Audiobooks*，相对路径是*Audiobooks*。可以使用*cd*命令以绝对路径或者相对路径进入这个目录：

```
$ cd /home/madmax/Audiobooks
```

或者相对路径：

```
$ cd Audiobooks
```

您所在的目录是当前工作目录（*cwd*）。使用*pwd*（打印工作目录）命令确认您的*cwd*：

```
$ pwd
/home/madmax
```

## 讨论

绝对路径和相对路径常常让人困惑。请记住，当文件路径以斜杠（/）开头时，这是绝对路径。如果没有前导斜杠，则相对于当前工作目录。

某些应用程序和命令要求相对路径；例如，*rsync* *include*和*exclude*列表使用相对于正在复制的目录的文件路径。

## 参见

+   *man 1 pwd*

+   第七章

# 6.4 删除文件和目录

## 问题

你玩得很开心创建了一堆文件和目录，现在想要摆脱它们。

## 解决方案

谨慎使用*rm*（删除）命令，因为*rm*会乐意删除你告诉它的所有内容，所以确保你正确地告诉它要删除的文件或目录。

删除单个文件，并显示详细输出：

```
$ rm -v aria.ogg
removed 'aria.ogg'
```

使用*-i*标志在删除前提示确认：

```
 $ rm -iv intermezzo.wav
rm: remove regular file 'intermezzo.wav'? y
removed 'intermezzo.wav' 
```

添加*-r*（递归）标志以删除目录及其所有文件和子目录。将*-r*与*-i*结合使用将在每次删除之前提示确认：

```
$ rm -rvi rehearsals
rm: descend into directory 'rehearsals'? y
rm: remove regular file 'rehearsals/brass-section'? y
[...]
```

如果你确信不需要为每个删除操作提示确认，请省略*-i*选项。

此示例仅删除*jan*子目录：

```
$ rm -rv rehearsals/2020/jan
```

此示例删除*rehearsals*目录及其所有文件和子目录：

```
$ rm -rv rehearsals
```

使用通配符匹配要删除的文件名，例如按文件扩展名：

```
$ rm -v *.txt
```

或者通过同一文本字符串命名的文件：

```
$ rm -v aria*
```

如果*rm*拒绝删除文件或目录，并且你确定要删除它，请添加*-f*（强制）选项。

## 讨论

*rm -rf /* 将擦除整个根文件系统（如果你有根权限）。有些人认为告诉新手这样做很有趣，但实际上并不好笑。在测试机器或虚拟机上运行它，观察内存中的进程仍在运行，即使文件系统已从磁盘中删除。

## 另请参阅

+   *man 1 rm*

# 6.5 复制、移动和重命名文件和目录

## 问题

你有目录，也有文件。你想将文件移动到目录中，更改文件名并进行复制。

## 解决方案

使用*cp*命令进行复制，*mv*命令进行移动或重命名。

此示例将两个文件从当前工作目录复制到*~/songs2*目录：

```
$ cp -v aria.ogg solo.flac ~/songs2/
'aria.ogg' -> '/home/duchess/songs2/aria.ogg'
'solo.flac' -> '/home/duchess/songs2/solo.flac' 
```

# 波浪号代表你的主目录

波浪号简写为你的主目录，所以在示例中，*~/songs2* 等同于 */home/duchess/songs2/*。

使用*-r*（递归）选项复制目录及其所有内容：

```
$ cp -rv ~/music/songs2 /shared/archives
```

递归示例仅复制目录及其文件。使用*--parents*选项保留父目录。以下示例复制*songs1*及其内容，并保留文件路径*duchess/music/songs2/*：

```
$ cp -rv --parents duchess/music/songs2/ shows/
duchess -> shows/duchess
duchess/music -> shows/duchess/music
'duchess/music/songs2' -> 'shows/duchess/music/songs2'
'duchess/music/songs2/intro.flac' -> 'shows/duchess/music/songs2/intro.flac'
'duchess/music/songs2/reprise.flac' -> 'shows/duchess/music/songs2/reprise.flac'
'duchess/music/songs2/solo.flac' -> 'shows/duchess/music/songs2/solo.flac'
```

*duchess*和*music*的其他内容不会被复制，只有*songs2*及其内容。

使用*mv*命令移动和重命名文件。此示例将两个文件移动到另一个目录：

```
$ mv -v aria.ogg solo.flac ~/songs2/
renamed 'aria.ogg' -> '/home/duchess/songs2/aria.ogg'
renamed 'solo.flac' -> '/home/duchess/songs2/solo.flac' 
```

以下示例将一个目录移动到另一个目录：

```
$ mv -v ~/songs2/ ~/music/
```

## 讨论

一些有用的*cp*选项包括：

+   *-a, --archive* 保留所有文件属性，如模式、所有权和时间戳。

+   *-i, --interactive* 在覆盖目标文件之前提示。

+   *-u, --update* 只有当源文件更新时才覆盖现有的目标文件。这在重新复制一批文件时节省时间，而一些副本未更改。（*rsync* 更适合通过仅复制更改来进行有效文件传输，见第七章。）

*mv* 有一些有用的选项：

+   *-i, --interactive* 在覆盖目标文件之前提示。

+   *-n, --no-clobber* 防止覆盖目标文件。

+   *-u, --update* 只有当您的文件比目标文件更新或首次移动时，它才会移动。

## 参见

+   *man 1 cp*

+   *man 1 mv*

# 6.6 使用 chmod 的八进制表示设置文件权限

## 问题

你知道*chmod*（改变模式）命令支持八进制和符号表示法，你想使用八进制表示法来管理文件权限。

## 解决方案

下面的例子展示了如何使用八进制表示法在文件上设置不同的权限。第一个例子将对*file.txt*文件的所有者授予读写访问权限，并排除组和世界的所有访问权限：

```
$ chmod -v 0600 file.txt
mode of 'file.txt' changed from 0644 (rw-r--r--) to 0600
(rw-------)
```

文件所有者可以读取、编辑和删除文件，而其他用户无法对其进行任何操作，甚至无法读取它，尽管他们可以在文件管理器中看到它列出。

让一个文件对所有人都可读和可写，允许每个人都可以对其进行任意操作：

```
$ chmod 0666 file.txt
```

在下一个例子中，*file.txt* 被更改为对文件所有者可读写，对组和世界只读：

```
$ chmod -v 0644 file.txt
mode of 'file.txt' changed from 0666 (rw-rw-rw-) to 0644 (rw-r--r--)
```

常见的权限设置是给所有者和组相同的权限，比如读写，并排除其他人：

```
$ chmod 0660 file.txt
```

命令和脚本需要设置可执行位。这个例子使*backup.sh*脚本对所有者可执行和读写，对组可执行和可读，而对其他人不可访问：

```
$ chmod 0750 backup.sh
```

八进制表示法有四个字段，但你可能最常使用最后三个字段，很少使用第一个字段。第一个字段保留用于特殊模式（参见配方 6.8）。

## 讨论

八进制表示法使用整数 0-7。表 6-1 显示了所有者和权限之间的关系。

表 6-1\. 八进制字段

| 模式 | 所有者 | 组 | 其他 |
| --- | --- | --- | --- |
| 读取 | 4 | 4 | 4 |
| 写入 | 2 | 2 | 2 |
| 执行 | 1 | 1 | 1 |
| 没有权限 | 0 | 0 | 0 |

一个文件或目录有一个用户所有者和一个组所有者。*其他*是所有其他人。一个无限制对所有人开放的目录或可执行文件是模式 0777，无限制的文件是模式 0666。

当你对 Linux 文件权限不熟悉时，可能帮助你以另一种视角查看它们，比如在表 6-2 中。

表 6-2\. Linux 文件权限

| 权限 | 描述 |
| --- | --- |
| *7* | 读、写、执行。目录与文件不同，因为所有目录都需要设置可执行位。您可以为目录分配任何权限，就像为文件分配权限一样，但如果没有可执行位，没有人可以进入该目录（使用*cd*命令或文件管理器）。脚本和二进制命令必须设置可执行位，否则它们将被视为普通文件。 |
| *6* | 读和写。 |
| *5* | 读和执行。这是命令常见的权限。 |
| *4* | 阅读。 |
| *3* | 写入和执行。 |
| *2* | 写入。 |
| *1* | 执行。 |
| *0* | 无权限。 |

## 另请参阅

+   *man 1 chmod*

+   示例 6.8

# 6.7 使用 chmod 的八进制表示法设置目录权限

## 问题

您知道目录上的权限管理有些不同，并希望使用 chmod 的八进制表示法来管理它们。

## 解决方案

目录必须设置可执行位。这听起来有些奇怪，但是对于使用*cd*命令或文件管理器进入目录是必要的。

以下示例创建了一个共享目录：

```
$ sudo mkdir /shared
```

该示例使*/shared*对所有者为读写，对其他所有人为只读：

```
$ chmod 0755 /shared
```

所有者对目录有无限制的特权。组和全局可以进入目录并读取文件，但不能编辑或添加文件。

该示例使用*-R*（递归）选项将相同的权限应用于目录中现有的内容：

```
$ chmod -R 0755 /shared
```

下一个示例将目录及其现有内容限制为目录所有者。目录内的文件和目录可能具有不同的所有者和权限，但仍然无法访问组和全局：

```
$ chmod 0700 /shared
```

一个常见的权限集是为所有者和组分配相同的权限，例如读-写-执行，并排除其他用户：

```
$ chmod 0770 /shared
```

## 讨论

您可以通过组和目录具有大量权限来控制文件访问。按功能设置组，例如各个团队可以各自拥有独占的共享目录。大多数情况下不需要超精细的控制，而是默认更多的共享。无论您的需求如何，旧的*chmod*命令仍然是控制文件权限的基本工具。

## 另请参阅

+   *man 1 chmod*

# 6.8 使用特殊模式处理特殊用例

## 问题

您想设置一些传统用户-组-其他权限集不支持的权限，例如允许非特权用户运行需要高级权限的命令，保护多用户共享目录中的文件，或者在目录中强制执行某些文件权限。

## 解决方案

特殊模式包括*粘滞位*、*setuid*和*setgid*（见表 6-3）。粘滞位适用于包含多用户拥有文件的目录，以防止用户移动、重命名或删除他们不拥有的文件：

```
$ chmod -v 1770 /home/duchess/shared
mode of '/home/duchess/shared changed from 0770 (rwxrwx---) to 1770 (rwxrwx--T)
```

*setuid* 应用于可执行文件，以将运行该命令的任何用户提升到与所有者相同的权限：

```
$ chmod 4750 backup-script
mode of 'backup-script' changed from 0750 (rwxrw----) to 4770 (rwsrwx---)
```

将 *setgid* 应用于目录，以便在目录中创建的所有新文件都分配给与目录组所有者相同的组。这是在共享目录中强制正确所有权的一个好方法：

```
$ chmod 2770 /home/duchess/shared
mode of '/home/duchess/shared' changed from 0770 (rwxrwx---) to 2770 (rwxrws---)

```

*setgid* 也可以应用于文件，将用户的有效组更改为与文件所有者相同的组。

## 讨论

*setgid* 和 *setuid* 有可能为入侵者或不可信用户创建安全漏洞。最佳实践是只有在无法想到更安全的方法来完成所需操作时，才使用它们，比如使用组分配或 *sudo*。

*setuid* 对可执行文件很有用。

*setgid* 对目录和文件都很有用。

粘性位仅适用于目录。表 6-3 显示了权限与所有者的关系。

表 6-3\. 八进制字段

| 模式 | 特殊模式 | 所有者 | 组 | 世界 |
| --- | --- | --- | --- | --- |
| 读取 |  | 4 | 4 | 4 |
| 写入 |  | 2 | 2 | 2 |
| 执行 |  | 1 | 1 | 1 |
| 设置 UID | 4 |  |  |  |
| setgid | 2 |  |  |  |
| 粘性位 | 1 |  |  |  |
| 无权限 | 0 | 0 | 0 | 0 |

可以组合特殊模式值（参见 表 6-4）。

表 6-4\. 粘性位/setgid/setuid 值

| 选项名称 | 八进制值 |
| --- | --- |
| 无选项设置 | 0 |
| 设置粘性位 | 1 |
| setgid | 2 |
| 粘性位和 setgid | 3 |
| 设置 UID | 4 |
| 粘性位和设置 UID | 5 |
| setgid 和 setuid | 6 |
| 粘性位、setgid 和 setuid | 7 |

粘性位的更具描述性的名称是 *受限删除位*。此位防止非特权用户在目录中删除或重命名文件，除非它们拥有该文件。您可以在 */tmp* 目录上看到这一点，该目录对所有用户都可读和可写，并包含由多个用户拥有的文件。使用粘性位防止用户移动、重命名或删除他们不拥有的文件，即使他们对某些他们不拥有的文件有写权限：

```
 $ stat --format=%a:%A:%U:%G /tmp
1777:drwxrwxrwt:root:root

```

粘性位是 1777 中的 1。

*setgid* 意味着设置组用户标识，而 *setuid* 是设置用户标识。它们用于将非特权用户的权限提升到与用户或组所有者相同的级别。这就是非特权用户如何能够使用 *passwd* 命令更改自己的密码，即使只有 root 对 */etc/passwd* 有写权限，而其他人只有读和执行权限：

```
 $ stat --format=%a:%A:%U:%G /usr/bin/passwd
4755:-rwsr-xr-x:root:root

```

在 */etc/passwd* 中的 4755 中的 4 是 *setuid*，这意味着所有用户在运行命令时具有 root 权限，尽管它们的权限仅限于更改自己的密码。

## 另请参阅

+   *man 1 chmod*

# 6.9 使用八进制表示法删除特殊模式

## 问题

您想要从文件或目录中删除特殊模式。

## 解决方案

删除特殊模式与设置不同，因为您需要使用额外的前导零，如以下示例：

```
$ chmod -v 00770 backup.sh
mode of 'backup.sh' changed from 1770 (rwxrwx--T) to 0770 (rwxrwx---)
```

或者用等号替换前导零：

```
$ chmod -v =770 backup.sh
mode of 'backup.sh' changed from 1770 (rwxrwx--T) to 0770 (rwxrwx---)

```

## 另请参阅

+   *man 1 chmod*

# 6.10 使用 chmod 符号表示设置文件权限

## 问题

你知道 *chmod*（更改模式）命令支持八进制和符号表示法，而你希望使用符号表示法来管理文件权限。

## 解决方案

符号表示法比八进制表示法更复杂，并且根据使用的操作符行为不同。

有三个操作符：+、- 和 =。你可以使用 *a* 标志更改每个人的权限，或者使用 *u* 为文件所有者，*g* 为组，*-o* 为其他人（即所有其他人）逐个更改。

+   *+* 添加到现有权限。

+   *-* 从现有权限中减去。

+   *=* 添加新权限，并删除未列出的任何权限位。

假设 *file.txt* 是所有者读写，组读取，其他人读取，或者 *-rw-r--r--*：

```
$ stat --format=%a:%A:%U:%G file.txt
664:-rw-r--r--:stash:stash

```

你想把它改成 *-rw-rw-rw-*。给组和其他人增加写权限：

```
$ chmod -v g+w,o+w file.txt
mode of 'file.txt' changed from 0644 (rw-r--r--) to 0666 (rw-rw-rw-)
```

你也可以使用 *a=rw*。

在下一个例子中，*file.txt* 的所有者将其从全局可读可写更改为仅文件所有者可编辑，组和全局只能读取：

```
$ chmod -v g-w,o-w file.txt
mode of 'file.txt' changed from 0666 (rw-rw-rw-) to 0644 (rw-r--r--)
```

常见的权限设置是给所有者和组相同的权限，比如读写，并排除其他人：

```
$ chmod -v u=rw,g=rw,o-r file.txt
mode of 'file.txt' changed from 0644 (rw-r-r--) to 0660 (rw-rw----)
```

命令和脚本需要设置可执行位。此示例为文件所有者添加可执行位到现有权限：

```
$ chmod -v u+x file.txt
mode of 'file.sh' changed from 0660 (rw-rw----) to 0760 (rwxrw----)
```

**`=`** 操作符用于覆盖现有权限：

```
$ chmod -v u=rw,g=rw,o=r file.txt
mode of 'file.sh' changed from 0760 (rwxrw----) to 0664 (rw-rw-r--)
```

## 讨论

使用 *chmod* 符号表示法的关键是始终要明确，并且要注意现有权限。添加和减去现有权限（除了使用 = 操作符会覆盖之外），并指定 *u*、*g*、*o* 或 *-a*。

*符号* 表示法设计为助记，*r* 代表读取，*w* 代表写入，*x* 代表执行（参见 表 6-5）。

表 6-5\. 符号表示权限

| 模式 | 值 |
| --- | --- |
| r | 读取 |
| w | 写入 |
| x | 执行 |

用户和组的表示法也是助记的（参见 表 6-6）。

表 6-6\. 符号表示所有者

| 所有者 | 表示 |
| --- | --- |
| 用户 | u |
| 组 | g |
| 其他 | o |
| 所有 | a |

就像八进制表示法一样，符号表示法也支持特殊模式（参见 食谱 6.11）。

符号表示法中有 10 个值，未设置的值（表示没有权限）用破折号表示，例如杜切斯的主目录示例：

```
$ stat --format=%a:%A:%U:%G /home/duchess
755:drwxr-xr-x:duchess:duchess

```

在 *drwxr-xr-x* 中，*d* 表示这是一个目录。在八进制表示法中没有可比值。

剩下的九个值被分为三个三重组，每个三重组中的三个值代表读、写和执行。

## 参见

+   *man 1 chmod*

# 6.11 使用 *chmod* 符号表示法设置特殊模式

## 问题

你想要使用 *chmod* 的符号表示法设置特殊模式。

## 解决方案

特殊模式包括粘着位、*setuid* 和 *setgid*。这些都在可执行字段中设置。（如果您不确定可执行字段是什么，请参阅 Recipe 6.10 讨论的末尾。）

粘着位适用于包含由多个用户拥有的文件的目录，以防止非所有者移动、重命名或删除文件：

```
$ chmod o+t /shared/stickydir
mode of '/shared/stickydir' changed from 0775 (rwxrwxr-x) to 1775 (rwxrwxr-t)
```

将 *setgid* 应用于目录，以使目录中所有新创建的文件的组与目录相同。这是一个很好的技巧，可以强制在共享目录中确保正确的所有权：

```
$ chmod -v g+s /shared
mode of '/shared' changed from 0770 (rwxrwx---) to 2770 (rwxrws---)
```

将 *setuid* 应用于可执行文件，以允许非 root 用户运行该可执行文件：

```
$ chmod -v u+s backup-script
mode of 'backup-script' changed from 0755 (rwxr-xr-x) to 4755 (rwsr-xr-x)
```

*setuid* 和 *setgid* 有可能会存在安全漏洞；请参见讨论了解更多信息。

## 讨论

*setuid* 对可执行文件很有用。

*setgid* 对目录和文件都很有用。

粘着位仅适用于目录。

表 6-7 显示所有者和模式之间的关系。

表 6-7\. 所有符号模式

| 模式 | 用户 | 组 | 其他 |
| --- | --- | --- | --- |
| 读取 | r | r | r |
| 写入 | w | w | w |
| 执行 | x | x | x |
| setuid | s |  |  |
| setgid |  | s |  |
| 粘着位 |  |  | t |

粘着位的一个更具描述性的名称是 *restricted deletion bit*。这可以防止用户在不拥有文件的情况下删除或重命名目录中的文件。您可以在您的 */tmp* 目录中看到这一点，该目录是全局可读写的，并包含多个用户的文件。使用粘着位可以防止用户移动、重命名或删除他们不拥有的文件：

```
$ stat --format=%a:%A:%U:%G /tmp
1777:drwxrwxrwt/:root:root 
```

*setgid* 意味着设置组标识，*setuid* 意味着设置用户标识。这些用于将非特权用户的权限提升到与文件所有者相同的级别。这就是非特权用户如何能够使用*passwd*命令来更改自己的密码，尽管只有 root 用户对 */etc/passwd* 具有写权限，而其他所有用户仅具有读和执行权限：

```
$ stat --format=%a:%A:%U:%G /usr/bin/passwd
4755:-rwsr-xr-x:root:root
```

用户字段中的 *rws* 表示对所有用户具有与文件所有者相同的读、写和执行权限。

*setgid* 和 *setuid* 有可能会造成安全漏洞。最好的做法是只有在无法想出更安全的方法来完成所需操作时才使用它们，例如使用组分配或 *sudo*。

## 参见

+   *man 1 chmod*

# 6.12 使用 chmod 批量设置权限

## 问题

您想要一次设置多个文件的权限。

## 解决方案

*chmod* 支持对文件列表进行操作。您也可以使用 *find* 命令和 shell 通配符选择要更改的文件。

# 您可能需要 sudo

如果看到“权限被拒绝”消息，请使用 *sudo*。

以下示例将以空格分隔的文件列表设置为所有用户均只读：

```
$ chmod -v 444 file1 file2 file3
```

设置目录及其内容（包括子目录）的权限，使用*-R*（递归）标志：

```
$ chmod -vR 755 /shared
```

您可以使用通配符选择文件；例如，使当前目录中的所有*.txt*文件对所有者可读写，并使组和其他人可读：

```
$ chmod -v 644 *.txt
```

使用通配符选择所有以相同字符串开头的文件名：

```
$ chmod -v 644 abcd*
```

此示例使当前目录中的所有文件对所有者和组可读写，而不更改目录权限：

```
$ find . -type f -exec chmod -v 660 {} \;
```

您可以更改属于特定用户的所有文件的模式。您可以使用用户的数字 ID 或用户名命名用户。此示例从文件系统的根目录开始：

```
$ sudo find / -user madmax -exec chmod -v 660 {} \;
$ sudo find / -user 1007 -exec chmod -v 660 {} \;
```

## 讨论

您需要具有根权限才能在所有目录中搜索文件。

点号（*find .*）告诉*find*从当前目录开始搜索。您可以从任何目录开始搜索。

*-type* 将结果限制为文件，而不是目录。

*-user* 查找由指定用户拥有的文件。

*-exec chmod -v 660 {} \;* 是一个神奇的小咒语，它接受*find*搜索的结果并在结果上运行*chmod -v 660*命令。您可以将其用于几乎任何您想要应用于*find*搜索结果的命令。

## 参见

+   *man 1 chmod*

+   *man 1 find*

# 6.13 使用 chown 设置文件和目录所有权

## 问题

您需要更改文件或目录的所有权。

## 解决方案

使用*chown*（更改所有者）命令更改文件所有权。基本命令语法为*chown 用户:组 文件名*。您可以仅更改所有者，*chown 用户: 文件名*，或仅更改组，*chown :组 文件名*。

更改所有者需要根权限：

```
duchess@client1:~$ sudo chown -v madmax: song.wav
changed ownership of 'song.wav' from duchess:duchess to madmax:duchess
```

更改组所有者：

```
$ sudo chown -v :composers song.wav
changed ownership of 'song.wav' from madmax:duchess to :composers
```

更改用户和组所有者：

```
$ sudo chown stash:stash song.wav
```

## 讨论

您需要根权限才能更改您不拥有的文件，并将文件所有权转移给另一个用户。如果您属于原始组和新组，则可以在没有根权限的情况下更改组文件所有权。

当您仅更改所有者时冒号是可选的，而更改组时则是必需的。

## 参见

+   *man 1 chown*

# 6.14 使用 chown 批量更改所有者

## 问题

您希望更改目录及其内容的所有权，或仅更改目录内容，文件列表，或将文件所有权从一个用户更改为另一个用户。

## 解决方案

*chown*支持操作文件列表。您还可以使用*find*命令和 shell 通配符列出要更改的文件。

要使用*chown*同时更改多个文件的所有者，请使用空格分隔的文件列表：

```
$ sudo chown -v madmax:share file1 file2 file3
```

将当前目录中具有特定文件扩展名的文件更改为新组：

```
$ sudo chown -v :share *.txt
```

将一个目录中一个用户的所有文件转移到另一个用户，使用其数字 UID 或用户名：

```
$ chown -Rv --from duchess stash /shared/compositions

$ chown -Rv --from 1001 1005 /shared/compositions
```

使用*-find_*命令遍历整个文件系统，或任何目录及其子目录，将一个用户的所有文件转移到另一个用户：

```
$ sudo find / -user duchess -exec chown -v stash {} \;

$ sudo find / -user 1001 -exec chown -v 1005 {} \;
```

## 讨论

将所有用户文件的所有权转移给另一个用户，或转移到不同的组，对于清理不再在系统上有帐户的用户非常有用。

## 参见

+   *man 1 chown*

# 6.15 使用 umask 设置默认权限

## 问题

你想要理解为什么文件以一定的默认权限创建，以及如何自己配置这些默认设置。

## 解决方案

umask（用户文件创建模式掩码）控制这种行为。要查看你的 umask 是什么，请运行 *umask* 命令：

```
$ umask
0002
```

这是用符号表示法表示的样子：

```
$ umask -S
u=rwx,g=rwx,o=rx
```

这将将你的默认权限设置为目录 0775 和文件 0664，因为 umask “掩盖” 了硬编码的默认权限 0777 和 0666。或者你可以将其看作减法，0777 - 0002 = 0775。

要在当前会话期间临时更改你的 umask，请按以下方式设置：

```
$ umask 0022
```

在你的 *~/.bashrc* 文件中插入一行 *umask 0022* 或你想要的任何值来永久设置 umask。

在 */etc/login.defs* 中为所有用户设置默认的 umask：

```
UMASK 022
```

表 6-8 显示了一些常见的 umask 值。

## 讨论

*umask* 是 Bash shell 的内置命令，不是存储在 */bin*、*/usr/bin* 或任何其他 *bin*（二进制）目录中的可执行程序。

表 6-8 列出了一些常用的 umask 值。

表 6-8\. 常见 umask 值

| umask | 目录 | 文件 |
| --- | --- | --- |
| 0002 | 0775 | 0664 |
| 0022 | 0755 | 0644 |
| 0007 | 0770 | 0660 |
| 0077 | 0700 | 0600 |

## 参见

+   *man 1 chmod*

+   参见 *man 1 bash* 的 Shell 内置命令部分，了解 *umask* 和其他 Bash 内置命令的更多信息。

# 6.16 创建文件和目录的快捷方式（软链接和硬链接）

## 问题

你想要创建文件的快捷方式或链接。

## 解决方案

Linux 中有两种链接类型：软链接和硬链接。软链接适用于文件和目录。硬链接仅适用于文件。

使用 *ln*（链接）命令创建软链接和硬链接。以下示例在 Mad Max 的主目录中创建一个指向外部目录 */files/userstuff* 的软链接：

```
$ ln -s /files/userstuff stuff
```

*/files/userstuff* 是目标，而 *stuff* 是目标或软链接名称。你可以任意命名你的软链接，并且移动或删除它们而不影响它们的目标。当你打开一个软链接时，它的行为与打开目标相同。

硬链接是文件的副本。 *ln* 命令的默认设置是创建硬链接：

```
$ ln /files/config1.txt myconf.txt
```

## 讨论

软链接适用于文件和目录，而硬链接仅适用于文件。

### 软链接

软链接更常被称为 *symlinks*，是 symbolic links 的缩写。

符号链接指向文件和目录。当符号链接的目标被删除、重命名或移动时，符号链接就会断开。如果你用一个与已删除文件同名但内容不同的新文件替换它，符号链接就会恢复。

符号链接可以跨文件系统。你甚至可以创建指向永久不可用的文件或目录（如 USB 存储设备或网络文件共享）的符号链接。

当目标更改（重命名、移动或删除）时，符号链接不会更新。你需要创建一个新的符号链接并删除旧的符号链接。

您不需要管理符号链接的权限或所有权，因为只有目标的权限才重要。

符号链接看起来像这样：

```
$ stat stuff
  File: stuff -> /files/userstuff
  Size: 4               Blocks: 0          IO Block: 4096   symbolic link
Device: 804h/2052d      Inode: 877581      Links: 1
Access: (0777/lrwxrwxrwx)  Uid: ( 1000/ madmax) Gid: ( 1000/ madmax)
```

*File: stuff → /files/userstuff* 显示符号链接指向的目标。

第三行标识这是一个符号链接。

*Access: lrwxrwxrwx* 中的 *l* 标识这是一个符号链接。

文件列表中的符号链接如下所示：

```
$ ls -l
[...]
lrwxrwxrwx 1 madmax madmax  4 Apr 26 12:42 stuff -> /files/userstuff

```

### 硬链接

文件通过*索引节点*唯一标识，而硬链接指向的是索引节点，而不是文件名。*ls* 命令通过 *-i* 选项显示索引节点。在这个例子中，索引节点是 1353，三个硬链接的索引节点相同：

```
$ ls -li
1353 -rw-rw-r--   3 madmax madmax  11208 Apr 26 13:06  config.txt
1353 -rw-rw-r--   3 madmax madmax  11208 Apr 26 13:06  config2.txt
1353 -rw-rw-r--   3 madmax madmax  11208 Apr 26 13:06  config3.txt
```

因为所有三个索引节点指向同一数据块。

硬链接总是有效，因为它们直接指向索引节点。具有多个硬链接的文件可以被移动、重命名和编辑，所有硬链接因指向同一数据块而保持同步。

Linux 系统上的每个文件都以硬链接开始。当您创建一个硬链接时，实际上是为现有数据块创建一个新的文件名。

硬链接不能跨文件系统，而只存在于单个文件系统内。例如，如果您的 */* 和 */home* 在不同的分区上，您不能在 */home* 中为 */* 中的文件创建硬链接。

您可以为文件创建任意多的硬链接，它们指向的数据块的磁盘空间始终相同，不管有多少硬链接。

将硬链接与复制文件进行对比：每个副本都会使用更多磁盘空间，每个副本都是独立的，副本可以存放在任何位置。

直到所有硬链接都被删除，文件才算完全删除。您可以使用 *ls* 查看这一点。以下示例显示了我们的例子索引节点及其三个硬链接的另一视图：

```
$ stat config3.txt
  File: config3.txt
  Size: 11208           Blocks: 24         IO Block: 4096   regular file
Device: 804h/2052d      Inode: 1353        Links: 3
```

将文件、大小和符号链接与硬链接进行比较。硬链接是常规文件，注意 *Links: 3*。这表明有三个硬链接指向同一数据。当您删除具有多个硬链接的文件时，只有在删除所有硬链接之后，该文件才会被删除。使用 *find* 命令定位所有相关的硬链接：

```
$ find */etc* -xdev -samefile *config3.txt*
./config
./config2
./config3
```

在 Linux 中，符号链接被广泛使用，而硬链接则不那么常见。一些备份应用程序使用索引节点进行重复数据删除。在旧时代，当文件系统较小时，索引节点不足并不罕见。在这种情况下，硬链接更可取，因为每个符号链接都有自己的索引节点，而硬链接共享索引节点。

您可以使用 *du* 命令查看文件系统有多少个索引节点，以及使用了多少个：

```
$ df -i /dev/sda4
Filesystem        Inodes  IUsed     IFree IUse% Mounted on
/dev/sda4      384061120 389965 383671155    1% /home
```

由于使用率仅为 1%，我不会很快用完索引节点。

## 参见

+   man 1 ls

# 6.17 隐藏文件和目录

## 问题

您希望隐藏某些文件和目录，以便其他人看不见。

## 解决方案

要隐藏文件，以便其他人看不见，将它们放在只有您访问权限的存储设备上。

要在文件管理器中减少混乱，请使用 *点文件* 来忽略文件。您已经有这些文件。在图形文件管理器中查找类似“显示隐藏文件”的设置，或者对 *ls* 使用 *-a* 选项：

```
$ ls -a
.
..
Audiobooks
.bash_history
.bash_logout
.bashrc
bin
.bogofilter
.cache
Calibre-Library
cat-memes
.cddb
.cert
```

用`.`作为任何文件的前缀，它就成为了隐藏文件，尽管它实际上并不隐藏，但在你想要查看它之前会被忽略。这主要用于用户的主目录，以减少显示配置文件所带来的混乱。这些都是你可以编辑、删除或者做任何想做的正常文件。

## 讨论

注意文件列表顶部的单点和双点。单点代表当前目录，双点代表父目录。试着用*cd*命令操作一下。第一个例子保持在当前目录，第二个例子切换到父目录：

```
stash@client4:~$ cd .
stash@client4:~$

stash@client4:~$ cd ..
stash@client4:/home$
```

运行*cd*而不带选项可以返回到你的主目录，或者运行*cd -*返回到你上次所在的目录。

## 参见

+   查看*man 1 bash*中的 Shell 内建命令部分，了解更多关于*cd*和其他 Bash 内建命令的信息。
