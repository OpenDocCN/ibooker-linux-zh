# 21 使用正则表达式解析文本文件

正则表达式是那些尴尬的话题之一。我们经常有学生要求我们解释它们，结果发现——在谈话进行到一半时——他们根本不需要正则表达式。正则表达式，有时也称为正则表达式，在文本解析中很有用，这是您在 UNIX 和 Linux 操作系统中经常会做的事情。在 PowerShell 中，您通常进行较少的文本解析——您通常不太需要正则表达式。话虽如此，我们当然知道在 PowerShell 中，您需要解析文本内容，例如日志文件的情况。这就是我们本章介绍正则表达式的方式：作为一个解析文本文件的工具。

请不要误解：您可以用正则表达式做很多事情，我们将在本章末尾介绍其中的一些。但为了确保您有一个良好的预期，让我们明确指出，我们在这本书中并没有全面或详尽地介绍正则表达式。正则表达式可以变得非常复杂。它们是一项完整的技术。我们将帮助您入门，并尝试以立即适用于许多生产环境的方式做到这一点，然后如果您需要，我们将为您提供一些深入学习的指导。

我们编写本章的目的是以简化的方式向您介绍正则表达式语法，并展示 PowerShell 如何使用正则表达式。如果您想自己学习更复杂的表达式，欢迎您这样做，您将知道如何在 shell 中使用它们。

## 21.1 正则表达式的作用

正则表达式是用一种特定的语言编写的，其目的是定义文本模式。例如，IPv4 地址由一到三个数字、一个点、一到三个更多的数字、一个点等等组成。正则表达式可以定义这种模式，尽管它也会接受一个无效的地址，如 211.193.299.299。这就是识别文本模式和检查数据有效性的区别。

正则表达式最大的用途之一——我们本章要介绍的就是在较大的文本文件中检测特定的文本模式，例如日志文件。例如，您可能编写一个正则表达式来查找表示 Web 服务器日志文件中 HTTP 500 错误的特定文本，或者查找 SMTP 服务器日志文件中的电子邮件地址。除了检测文本模式外，您可能还会使用正则表达式来捕获匹配的文本，从而让您能够从日志文件中提取这些电子邮件地址。

## 21.2 正则表达式语法入门

最简单的正则表达式是您想要匹配的确切文本字符串。例如，`Car`在技术上是一个正则表达式，在 PowerShell 中它将匹配`CAR`、`car`、`Car`、`CaR`等等；PowerShell 的默认匹配是不区分大小写的。

然而，某些字符在正则表达式中具有特殊含义，它们使您能够检测可变文本的模式。以下是一些示例：

+   `\w` 匹配“单词字符”，意味着字母、数字和下划线，但不包括标点符号和空白。正则表达式 `\won` 会匹配 `Don`、`Ron` 和 `ton`，其中 `\w` 代表任何单个字母、数字或下划线。

+   `\W` 匹配 `\w` 的对立面（因此这是 PowerShell 对大小写敏感的一个例子），意味着它匹配空白和标点符号——“非单词字符”。

+   `\d` 匹配从 `0` 到 `9` 的任何数字。

+   `\D` 匹配任何非数字。

+   `\s` 匹配任何空白字符，包括制表符、空格或换行符。

+   `\S` 匹配任何非空白字符。

+   `.`（一个点）代表任何单个字符。

+   `[abcde]` 匹配该集合中的任何字符。正则表达式 `c[aeiou]r` 会匹配 `car` 和 `cur`，但不会匹配 `caun` 或 `coir`。

+   `[a-z]` 匹配该范围内的一个或多个字符。你可以指定多个范围，用逗号分隔的列表，例如 `[a-f,m-z]`。

+   `[^abcde]` 匹配不在该集合中的一个或多个字符，意味着正则表达式 `d[^aeiou]` 会匹配 `dns` 但不会匹配 `don`。

+   `?` 后跟另一个字面量或特殊字符，并匹配该字符的精确一个实例。因此，正则表达式 `ca?r` 会匹配 `car` 但不会匹配 `coir`。它也会匹配 `ca`，因为 `?` 也可以匹配前面字符的零个实例。

+   `*` 匹配前面字符的任意数量实例。正则表达式 `ca*r` 会匹配 `cair` 和 `car`。它也会匹配 `ca`，因为 `*` 也可以匹配前面字符的零个实例。

+   `+` 匹配前面字符的一个或多个实例。你会在括号中看到很多这种用法，括号创建了一种子表达式。例如，正则表达式 `(ca)+r` 会匹配 `cacacacar`，因为它匹配 `ca` 子表达式的重复实例。

+   `\`（反斜杠）是正则表达式的转义字符。在正则表达式语法中通常有特殊意义的字符之前使用它，使该字符成为字面量。例如，正则表达式 `\.` 会匹配一个字面量的点字符，而不是像通常那样允许点代表任何单个字符。要匹配字面量的反斜杠，用反斜杠转义它：`\\`。

+   `{2}` 匹配前面字符的精确数量。例如，`\d{1}` 会匹配一个数字。使用 `{2,}` 来匹配两个或更多，使用 `{1,3}` 来匹配至少一个但不超过三个。

+   `^` 匹配字符串的开始。例如，正则表达式 `c.r` 会匹配 `car` 以及 `pteranocar`。但正则表达式 `^c.r` 只会匹配 `car`，而不会匹配 `pteranocar`，因为 `^` 使得匹配发生在字符串的开始处。这与前一个示例中的用法不同，在那里它和方括号 `[]` 一起使用，表示负匹配。

+   `$` 匹配字符串的末尾。例如，正则表达式 `.icks` 会匹配 `hicks` 和 `sticks`（在这个例子中，匹配实际上是 `ticks`），还会匹配 `Dickson`。但正则表达式 `.icks$` 不会匹配 `Dickson`，因为 `$` 表示字符串应该在 `s` 之后结束。

这就是我们所看到的——对基本正则表达式语法的快速浏览。正如我们之前所写的，还有很多其他内容，但这已经足够做一些基本工作了。让我们看看一些示例正则表达式：

+   `\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}` 匹配 IPv4 地址的模式，尽管它会接受非法数据，如 `432.567.875.000`，以及合法数据，如 `192.169.15.12`。

+   `\\\\\w+(\\\w+)+` 匹配通用命名约定（UNC）路径。所有的反斜杠使得这个正则表达式难以阅读——这也是为什么在将正则表达式用于生产任务之前测试和调整它们很重要的原因之一。

+   `\w{1}\.\w+@company\.com` 匹配特定类型的电子邮件地址：首字母，一个点，姓氏，然后是 `@company.com`。例如，`sam.smith@company .com` 将是一个有效的匹配。在使用这些时确实需要小心。例如，`Samuel.smith@company.com.org` 或 `Smith@company.com.net` 也会是有效的匹配。正则表达式对匹配部分前后有额外文本的情况没有问题。这就是在许多情况下 `^` 和 `$` 锚点发挥作用的地方。

注意 你可以通过在 PowerShell 中运行 `help` `about_regular _expressions` 来了解更多关于基本正则表达式语法的信息。在本章末尾，我们提供了一些额外的资源，供进一步探索。

## 21.3 使用 -Match 与正则表达式

PowerShell 包含一个比较运算符 `-Match` 和一个大小写敏感的类似项 `-CMatch`，它们与正则表达式一起工作。以下是一些示例：

```
PS C:\> "car" -match "c[aeiou]r"
True
PS C:\> "caaar" -match "c[aeiou]r"
False
PS C:\> "caaar" -match "c[aeiou]+r"
True
PS C:\> "cjinr" -match "c[aeiou]+r"
False
PS C:\> "cear" -match "c[aeiou]r"
False
```

虽然它有很多用途，但我们主要将依赖于 `-Match` 来测试正则表达式并确保它们工作正常。正如你所看到的，它的左操作数是你正在测试的字符串，右操作数是正则表达式。如果存在匹配，它输出 `True`；如果没有，你得到 `False`。

现在试试看 这是一个从阅读中休息一下并尝试使用 `-Match` 操作符的好时机。运行我们刚才提到的几个示例，并确保你在 shell 中使用 `-Match` 操作符时感到舒适。

## 21.4 使用 Select-String 与正则表达式

现在我们来到了本章的真正重点。我们将使用一些网络服务器日志文件作为示例，因为它们正是正则表达式设计用来处理的那种纯文本文件。如果我们能够以面向对象的方式将这些日志读入 PowerShell 那将很棒，但，嗯，我们做不到。所以我们就用正则表达式吧。

让我们先扫描日志文件，寻找任何 40*x*错误。这些错误通常是文件未找到等，我们希望能够为我们组织的网络开发者生成一个坏文件的报告。日志文件包含每个 HTTP 请求的单行，并且每行被分割成空格分隔的字段。我们有一些文件，它们的文件名中包含 401 等，例如，error401.html，我们不希望这些文件包含在我们的结果中。我们指定一个正则表达式，如`\s40[0-9]\s`，因为它指定了 40*x*错误代码两边的空格。它应该找到从 400 到 409 的所有错误。以下是我们的命令：

```
PS C:\logfiles> get-childitem -filter *.log -recurse | 
 select-string -pattern "\s40[0-9]\s" | 
 format-table Filename,LineNumber,Line -wrap
```

注意，我们切换到 C:\LogFiles 目录来运行这个命令。我们首先让 PowerShell 获取所有匹配*.log 文件名模式的文件，并递归子目录。这确保了所有日志文件都包含在输出中。然后我们使用`Select-String`并给它我们的正则表达式作为模式。命令的结果是一个`MatchInfo`对象；我们使用`Format-Table`创建一个显示，包括文件名、行号和包含匹配的文本行。这可以很容易地重定向到文件并交给我们的网络开发者。

注意：你可能已经注意到我们使用了`Format-Table`。我们这样做有两个原因。第一个原因是我们想将屏幕上的文本换行，第二个原因是我们只是让屏幕看起来更整洁，并且我们没有输出任何信息。

接下来，我们想要扫描所有基于 Gecko 的 Web 浏览器的访问文件。我们的开发人员告诉我们，他们的一些客户在使用这些浏览器访问网站时遇到了一些问题，他们想查看哪些特定的文件被请求。他们认为问题已经缩小到在 Windows NT 10.0 下运行的浏览器，这意味着我们正在寻找看起来像这样的用户代理字符串：

```
(Windows+NT+10.0;+WOW64;+rv:11.0)+Gecko
```

我们的开发人员强调，64 位不是特定的，所以他们不希望日志结果仅限于`WOW64`用户代理字符串。我们提出了这个正则表达式：`10.0;[\w\W]+\+Gecko`。让我们分解一下：

+   `10.0;`—这是一个 10.0。请注意，我们转义了点号，使其成为一个字面字符，而不是点号通常表示的单字符通配符。

+   `[\w\W]+`—这是一个或多个单词或非单词字符（换句话说，任何东西）。

+   `\+Gecko`—这是一个字面的`+`，然后是*Gecko*。

以下是从日志文件中查找匹配行的命令，以及输出的前几行：

```
PS C:\logfiles> get-childitem -filter *.log -recurse | 
Select-string -pattern "10\.0;[\w\W]+\+Gecko"
W3SVC1\u_ex120420.log:14:2012-04-20 21:45:04 10.211.55.30 GET /MyApp1/Testpage.asp 
    - 80 - 10.211.55.29 Mozilla/5.0+(Windows+NT+10.0;+WOW64;+rv:11.0)+Gecko/20100101+Firefox/11.0 200 0 0 1125
W3SVC1\u_ex120420.log:15:2012-04-20 21:45:04 10.211.55.30 GET /TestPage.asp 
    - 80 - 10.211.55.29 Mozilla/5.0+(Windows+NT+10.0;+WOW64;+rv:11.0)+Gecko/20100101+Firefox/11.0 200 0 0 1 109
```

我们这次保留了输出的默认格式，而没有将其发送到格式化命令。

作为最后的例子，让我们从 IIS 日志文件转换到 Windows 安全日志。事件日志条目包括一个 `Message` 属性，其中包含有关事件的详细信息。不幸的是，这些信息是为方便人类阅读而格式化的，而不是为方便基于计算机的解析。我们希望查找所有 ID 为 4624 的事件，这表示账户登录（这个数字在不同的 Windows 版本中可能不同；我们的例子来自 Windows Server 2008 R2）。但我们只想看到与以 WIN 开头的账户登录相关的事件，这关系到我们域中的计算机账户，并且账户名称以 TM20$ 通过 TM40$ 结尾，这是我们感兴趣的特定计算机。这个正则表达式可能看起来像 `WIN[\W\w]+TM[234][0-9]\$`。注意我们为什么需要转义最后的美元符号，以免它被解释为字符串结束锚点。我们需要包含 `[\W\w]`（非单词和单词字符），因为我们的账户名称可能包含连字符，这不会与 `\w` 单词字符类匹配。以下是我们的命令：

```
PS C:\> get-eventlog -LogName security | where { $_.eventid -eq 4624 } | 
select -ExpandProperty message | select-string -pattern 
"WIN[\W\w]+TM[234][0-9]\$"
```

我们首先使用 `Where-Object` 来保留具有 ID 4624 的事件。然后我们将 `Message` 属性的内容展开为普通字符串，并将其管道到 `Select-String`。请注意，这将输出匹配的消息文本；如果我们的目标是输出整个匹配的事件，我们将采取不同的方法：

```
PS C:\> get-eventlog -LogName security | where { $_.eventid -eq 4624 -and
➥ $_.message -match "WIN[\W\w]+TM[234][0-9]\$" }
```

在这里，我们不是输出 `Message` 属性的内容，而是简单地查找 `Message` 属性包含与我们的正则表达式匹配的文本的记录，然后输出整个事件对象。这完全取决于你想要的输出内容。

## 21.5 实验答案

注意：对于这个实验，你需要任何运行 PowerShell v7 或更高版本的计算机。

不要误解，正则表达式可能会让你头晕，所以不要一开始就尝试创建复杂的正则表达式——从简单开始。这里有一些练习可以帮助你入门。使用正则表达式和运算符来完成以下任务：

1.  获取你 Windows 或 /usr 目录下所有名称中包含两位数字的文件。

1.  在你的计算机上查找所有来自微软的已加载模块，并显示名称、版本号、作者和公司名称。（提示：将 `Get-module` 管道到 `Get-Member` 以发现属性名称。）

1.  在 Windows 更新日志中，你只想显示代理开始安装文件的行。你可能需要打开记事本来找出你需要选择的字符串。你可能需要运行 `Get-WindowsUpdateLog`，相应的日志将被放置在你的桌面上。

    对于 Linux，找到你的历史记录日志并显示你安装软件包的行。

1.  使用 `Get-DNSClientCache` 命令，显示所有 `Data` 属性是 IPv4 地址的列表。

1.  如果你在一台 Linux（或 Windows）机器上，找到包含 IPV4 地址的 HOSTS 文件中的行。

## 21.6 实验答案

1.  `Get-ChildItem c:\windows | where {$_.name -match "\d{2}"}`

    `Get-ChildItem /usr | where {$_.name -match "\d{2}"}`

1.  `get-module | where {$_.companyname -match "^Microsoft"} |`

    `Select Name,Version,Author,Company`

1.  `get-content C:\Windows\WindowsUpdate.log |`

    `Select-string "[\w+\W+]Installing Update"`

    `Get-content ./apt/history.log | select-string "[\w+\W+]Installing"`

1.  你可以使用一个以一到三个数字开头，后跟一个实际点的模式来开始，例如：

    `get-dnsclientcache | where { $_.data -match "^\d{1,3}\."}`

    或者，你可以匹配整个 IPv4 地址字符串：

    `get-dnsclientcache | where`

    `{ $_.data -match "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"}`

1.  `gc /etc/hosts | where {$_ -match "^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"}`

## 21.7 进一步探索

你会在 PowerShell 的其他地方找到正则表达式，其中许多涉及我们在本书中没有涵盖的 shell 元素。以下是一些示例：

+   `Switch` 脚本结构包括一个参数，允许它将一个值与一个或多个正则表达式进行比较。

+   高级脚本和函数（脚本命令）可以利用基于正则表达式的输入验证工具来帮助防止无效的参数值。

+   `-Match` 操作符（我们在本章中简要介绍过）用于测试字符串与正则表达式的匹配，并且——我们之前没有分享过——将匹配的字符串捕获到自动的 `$matches` 集合中。

PowerShell 使用行业标准正则表达式语法，如果你有兴趣了解更多，我们推荐 Jeffrey E. F. Friedl 的《精通正则表达式》（O’Reilly，2006 年）。市面上还有无数的正则表达式书籍，其中一些是针对 Windows 和.NET（以及 PowerShell）的，有些专注于为特定情况构建正则表达式，等等。浏览你最喜欢的在线书店，看看是否有任何书籍看起来适合你和你特定的需求。

我们还使用了一个免费的在线正则表达式存储库，[`RegExLib.com`](http://RegExLib.com)，它包含各种目的的正则表达式示例（电话号码、电子邮件地址、IP 地址等）。我们还发现自己在使用 [`RegExTester.com`](http://RegExTester.com)，这是一个允许你交互式测试正则表达式的网站，以精确地得到你需要的方式。
