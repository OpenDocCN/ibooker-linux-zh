# 12 过滤和比较

到目前为止，你一直在处理 shell 提供的任何输出：所有进程、文件系统对象和各种 Azure 命令。但这类输出并不总是你想要的。通常，你希望将结果缩小到几个特定感兴趣的项目，例如获取匹配特定模式的进程或文件。这就是你将在本章中学到的内容。

## 12.1 让 shell 只给你你需要的内容

shell 提供了两种广泛的结果缩小模型，它们都被称为 *过滤*。在第一种模型中，你试图指示为你检索信息的 cmdlet 只检索你指定的内容。在第二种模型（在第 12.5 节中讨论），它采用迭代方法，你接受 cmdlet 提供的所有内容，并使用第二个 cmdlet 过滤掉你不需要的内容。

理想情况下，你应尽可能多地使用我们称之为 *过滤左侧* 的第一种模型。这可能只是告诉 cmdlet 你想要什么。例如，使用 `Get-Process`，你可以告诉它你想要哪些进程名称：

```
Get-Process -Name p*,*s*
```

但如果你想让 `Get-Process` 只返回内存超过 1 GB 的进程，而不考虑它们的名称，你不能告诉 cmdlet 为你完成这个任务，因为它没有提供任何参数来指定该信息。

同样，如果你使用的是 `Get-ChildItem`，它包括 `-Path` 参数，支持通配符。虽然你可以获取所有文件并使用 `Where-Object` 进行过滤，但我们不推荐这样做。再次强调，这种技术之所以理想，是因为 cmdlet 只需要检索匹配的对象。我们称之为 *过滤左侧* 技术或称为 *早期过滤* 技术。

## 12.2 过滤左侧

*过滤左侧* 意味着尽可能将过滤条件放在命令行的左侧或开头。你越早过滤掉不需要的对象，剩余的命令行上的 cmdlet 就需要做的工作就越少，并且可能需要传输到计算机的网络上的不必要信息就越少。

过滤左侧技术的缺点是每个单独的 cmdlet 都可以实现自己的指定过滤方式，并且每个 cmdlet 在执行过滤方面的能力都不同。例如，使用 `Get-Process`，你只能根据进程的 `Name` 或 `Id` 属性进行过滤。

当你无法让 cmdlet 完成所有需要的过滤时，你可以转向一个名为 `Where-Object` 的 PowerShell Core cmdlet（别名为 `where`）。它使用通用语法，你可以在将对象检索并放入管道后使用它来过滤任何类型的对象。

要使用 `Where-Object`，你需要学习如何告诉 shell 你想要过滤的内容，这涉及到使用 shell 的比较运算符。

## 12.3 使用比较运算符

在计算机中，一个 *比较* 总是涉及两个对象或值，并测试它们之间的关系。你可能正在测试它们是否相等，或者一个是否大于另一个，或者它们是否匹配某种文本模式。你通过使用 *比较运算符* 来表示你想要测试的关系类型。简单操作中的测试结果会产生一个布尔值：`True` 或 `False`。换句话说，测试的关系要么是你指定的那样，要么不是。

PowerShell 使用以下比较运算符。请注意，当比较文本字符串时，这些运算符不是大小写敏感的；大写字母被视为与小写字母相等：

+   `-eq`—相等，例如 `5` `-eq` `5`（这是 `True`）或 `"hello"` `-eq` `"help"`（这是 `False`）

+   `-ne`—不等于，例如 `10` `-ne` `5`（这是 `True`）或 `"help"` `-ne` `"help"`（这是 `False`，因为实际上它们是相等的，而我们正在测试它们是否不相等）

+   `-ge` 和 `-le`—大于或等于，以及小于或等于，例如 `10` `-ge` `5`（这是 `True`）或 `(Get-Date)` `-le` `'2020-12-02'`（这取决于你何时运行它，并展示了如何比较日期）

+   `-gt` 和 `-lt`—大于和小于，例如 `10` `-lt` `10`（这是 `False`）或 `100` `-gt` `10`（这是 `True`）

对于字符串比较，如果需要，你也可以使用一组单独的大小写敏感运算符：`-ceq`、`-cne`、`-cgt`、`-clt`、`-cge`、`-cle`。

如果你想要同时比较多个事物，你可以使用逻辑运算符 `-and` 和 `-or`。每个运算符都包含其一边的一个子表达式，我们通常将它们括起来以使行更容易阅读：

+   `(5` `-gt` `10)` `-and` `(10` `-gt` `100)` 是 `False`，因为一个或两个子表达式是 `False`。

+   `(5` `-gt` `10)` `-or` `(10` `-lt` `100)` 是 `True`，因为至少有一个子表达式是 `True`。

此外，逻辑 `-not` 运算符会反转 `True` 和 `False`。当你处理一个已经包含 `True` 或 `False` 的变量或属性，并想要测试相反条件时，这可能很有用。例如，如果你想测试一个进程是否没有响应，你可以这样做（你将使用 `$_` 作为进程对象的占位符）：

```
$_.Responding -eq $False
```

PowerShell 定义了 `$False` 和 `$True` 来表示 `False` 和 `True` 布尔值。另一种写这种比较的方法如下：

```
-not $_.Responding
```

因为 `Responding` 通常包含 `True` 或 `False`，所以 `-not` 将 `False` 反转为 `True`。如果进程没有响应（意味着 `Responding` 是 `False`），你的比较将返回 `True`，表示进程“没有响应”。我们更喜欢第二种技术，因为它在英语中读起来更像我们正在测试的内容：“我想看看进程是否没有响应。”你有时会看到 `-not` 运算符被缩写为感叹号 (`!`)。

当你需要比较文本字符串时，一些其他的比较运算符也很有用：

+   `-like`——接受`*, ?,`和`[]`作为通配符，因此你可以比较以查看`"Hello"` `-like` `"*ll*"`（这将返回`True`）。相反的是`-notlike`，两者都不区分大小写；使用`-clike`和`-cnotlike`进行大小写敏感的比较。你可以在`about_Wildcards`帮助文件中找到其他可用的通配符。

+   `-match`——在文本字符串和正则表达式模式之间进行比较。它的逻辑对立面是`-notmatch`，正如你所期望的，`-cmatch`和`-cnotmatch`提供了大小写敏感的版本。正则表达式将在本书的后续章节中介绍。

关于壳（shell）的整洁之处在于，你几乎可以在命令行中直接运行所有这些测试（例外是使用`$_`占位符的测试——它单独使用时不会工作，但你在下一节中会看到它在哪里会工作）。

现在尝试一下 好吧，尝试这些比较中的任何一个——或者全部——。在一行上输入它们——例如，`5 -eq 5`——按 Enter 键，看看你得到什么。

你可以在`about_Comparison_Operators`帮助文件中找到其他可用的比较运算符，你将在第二十五章中了解其中的一些。

## 12.4 从管道中过滤对象

一旦你编写了一个比较，你将在哪里使用它？嗯，你可以使用 shell 的通用过滤 cmdlet，`Where-Object`。

例如，你想删除所有进程，但保留使用超过 100 MB 内存（`WorkingSet`）的进程吗？

```
Get-Process | Where-Object -FilterScript {$_.WorkingSet -gt 100MB} 
```

`-FilterScript`参数是位置参数，这意味着你通常会看到它没有指定就输入：

```
Get-Process | Where-Object {$_.WorkingSet -gt 100MB} 
```

如果你习惯于大声朗读这些内容，听起来是有道理的：“`WorkingSet`大于 100 MB 的地方。”这是它的工作原理：当你将对象通过管道传递给`Where-Object`时，它会使用其过滤器检查每一个对象。它一次将一个对象放入`$_`占位符中，然后运行比较以查看它是`True`还是`False`。如果是`False`，对象将从管道中丢弃。如果比较是`True`，对象将从`Where-Object`中流出，传递到管道中的下一个 cmdlet。在这种情况下，下一个 cmdlet 是`Out-Default`，它总是位于管道的末尾（正如我们在第十一章中讨论的那样），并且它启动了格式化过程以显示你的输出。

那个`$_`占位符是一个特殊的实体：你之前已经见过它被使用过（在第十章中），你还会在另一个或两个上下文中看到它。你只能在使用 PowerShell 查找它的特定位置使用此占位符，这恰好是那些位置之一。正如你在第十章中学到的，点号告诉 shell 你并不是在比较整个对象，而是在比较它的一个属性，`WorkingSet`。

我们希望你能开始看到 `Get-Member` 的用途。它为你提供了一个快速简单的方式来发现对象属性，这让你可以转过来在比较中使用这些属性，就像这样。始终记住，PowerShell 最终输出中的列标题并不总是反映属性名称。例如，运行 `Get-Process`，你会看到一个像 `PM(MB)` 这样的列。运行 `Get-Process` `|` `Get-Member`，你会看到实际的属性名是 `PM`。这是一个重要的区别：始终通过使用 `Get-Member` 来验证属性名称；不要使用 `Format-` 命令。

超越

PowerShell v3 引入了一种新的“简化”语法用于 `Where-Object`。你只能在执行单个比较时使用它；如果你需要比较多个项目，你仍然必须使用原始语法，这就是你在本节中看到的语法。

人们争论这种简化的语法是否有帮助。它看起来可能像这样：

```
Get-Process | where WorkingSet -gt 100MB
```

显然，这更容易阅读：它省略了花括号 `{}`，并且不需要使用看起来尴尬的 `$_` 占位符。但这个新语法并不意味着你可以忘记旧语法，你仍然需要它来进行更复杂的比较：

```
Get-Process | Where-Object {$_.WorkingSet -gt 100MB -and $_.CPU -gt 100}
```

更重要的是，互联网上有数年的示例，所有这些示例都使用旧语法，这意味着你必须知道它才能使用它们。你还必须知道新语法，因为现在它将开始在开发者的示例中出现。需要知道两套语法并不完全是“简化”，但至少你知道是什么。

## 12.5 使用迭代命令行模型

现在我们想和你简要地谈谈我们所说的 PowerShell 迭代命令行模型。这个模型背后的想法是，你不需要一次性从头开始构建这些大型、复杂的命令行。从小处着手。

假设你想测量使用虚拟内存最多的 10 个进程的虚拟内存量。但如果 PowerShell 本身是这些进程之一，你不想将其包括在计算中。让我们快速盘点一下你需要做什么：

1.  获取进程。

1.  移除所有 PowerShell 相关的内容。

1.  按虚拟内存对进程进行排序。

1.  根据排序结果，只保留前 10 个或后 10 个。

1.  将剩余的虚拟内存加起来。

我们相信你知道如何完成前三个步骤。第四步是通过使用你的老朋友 `Select-Object` 来实现的。

现在尝试一下。花点时间阅读 `Select-Object` 的帮助。你能找到任何参数，使你能够只保留集合中的第一个或最后一个对象吗？

我们希望你已经找到了答案。最后，你需要将虚拟内存加起来。这是你需要找到一个新命令的地方，可能通过使用 `Get-Command` 或 `Help` 进行通配符搜索。你可以尝试使用 `Add` 关键字，或者 `Sum` 关键字，甚至 `Measure` 关键字。

现在尝试一下。看看你是否能找到一个可以测量类似虚拟内存这样的数值属性的命令。使用 `Help` 或 `Get-Command` 与 `*` 通配符。

当你尝试这些小任务（并且不提前阅读答案）时，你正在将自己变成 PowerShell 专家。一旦你认为你找到了答案，你可能会开始尝试迭代方法。

首先，你需要获取进程。这很简单：

```
Get-Process
```

现在尝试一下。在 shell 中跟随并运行这些命令。在每个命令之后，检查输出，看看你是否可以预测出你需要在下一个命令迭代中更改的内容。

接下来，你需要过滤掉你不需要的内容。记住，*filter left* 意味着你希望将过滤器尽可能靠近命令行的开头。在这种情况下，你将使用 `Where-Object` 来进行过滤，因为你希望它是管道中的下一个 cmdlet。这不如在第一个 cmdlet 上进行过滤好，但比在管道的后面过滤要好。

在 shell 中，按键盘上的上箭头键来回忆你的上一个命令，然后添加下一个命令：

```
Get-Process | Where-Object { $_.Name -notlike 'pwsh*' }
```

你不确定是 `pwsh` 还是 `pwsh.exe`，所以你使用通配符比较来覆盖所有可能性。任何不与这些名称相似的进程都将保留在管道中。

运行这个命令来测试它，然后再次按上箭头键来添加下一个部分：

```
Get-Process | Where-Object { $_.Name -notlike 'pwsh*' } |
Sort-Object VM -Descending
```

按下 Enter 键让你检查你的工作，上箭头键让你添加下一个部分：

```
Get-Process | Where-Object  { $_.Name -notlike 'pwsh*' } |
Sort-Object VM -Descending | Select -First 10
```

如果你按默认的升序排序，你会在添加这部分之前保留 `-last` `10`：

```
Get-Process | Where-Object { $_.Name -notlike 'pwsh*' } |
Sort-Object VM -Descending | Select -First 10 | 
Measure-Object -Property VM -Sum
```

我们希望你能至少找出那个最后一个 cmdlet 的名称，如果不是这里使用的确切语法。

这种模型——运行命令、检查结果、回忆它，并修改它以进行另一次尝试——是 PowerShell 与更传统的脚本语言区别开来的地方。因为 PowerShell 是一个命令行 shell，你可以立即获得结果，以及如果结果不是你所期望的，可以快速轻松地修改你的命令。你也应该看到，当你将你在本书中到目前为止学到的 cmdlet 中的几个 cmdlet 结合起来时，你拥有的力量。

## 12.6 常见混淆点

任何时候我们在类中引入 `Where-Object`，我们通常会遇到两个主要难点。我们试图在前面的讨论中深入探讨这些概念，但如果你有任何疑问，我们现在会澄清。

### 12.6.1 请左过滤

你希望你的过滤条件尽可能靠近命令行的开头。如果你可以在第一个 cmdlet 中完成所需的过滤，就那样做；如果不能，尝试在第二个 cmdlet 中过滤，以便后续的 cmdlet 有尽可能少的工作要做。

此外，尽量在数据源附近进行过滤。例如，如果你从远程计算机查询进程并需要使用 `Where-Object`——就像我们在本章的一个示例中所做的那样——考虑使用 PowerShell 远程，以便在远程计算机上进行过滤，而不是将所有对象带到你的计算机上并在那里过滤它们。你将在第十三章处理远程，我们将在那里再次提到在源处过滤的想法。

### 12.6.2 当 $_ 被允许时

特殊的 `$_` 占位符仅在 PowerShell 知道查找它的位置有效。当它有效时，它每次包含从被管道传输到该 cmdlet 的对象中的一个。请记住，管道中的内容可以在管道的各个阶段发生变化，因为各种 cmdlet 执行并产生输出。

还要注意嵌套管道——那些发生在括号命令内部的管道。例如，以下内容可能难以理解：

```
Get-Process -Name (Get-Content c:\names.txt |
Where-Object -filter { $_ -notlike '*daemon' }) |
Where-Object -filter { $_.WorkingSet -gt 128KB }
```

让我们一步步来：

1.  你从 `Get-Process` 开始，但这不是第一个要执行的命令。由于括号的存在，`Get-Content` 将首先执行。

1.  `Get-Content` 正在将输出——由简单的 `String` 对象组成——传输到 `Where-Object`。那个 `Where-Object` 在括号内，在其过滤器中，`$`_ 代表从 `Get-Content` 管道传输进来的 `String` 对象。只有那些不以 *daemon* 结尾的字符串将被保留并由 `Where-Object` 输出。

1.  `Where-Object` 的输出成为括号命令的结果，因为 `Where-Object` 是括号内的最后一个 cmdlet。因此，所有不以 *daemon* 结尾的名称都将发送到 `Get-Process` 的 `-Name` 参数。

1.  现在 `Get-Process` 执行，它产生的 `Process` 对象将被传输到 `Where-Object`。那个 `Where-Object` 实例将每次将一个服务放入其 `$`_ 占位符中，并且它只保留那些 `WorkingSet` 属性大于 `128KB` 的服务。

有时我们觉得眼睛都交叉了，因为有所有的花括号、大括号、句点和括号，但这就是 PowerShell 的工作方式，如果你能训练自己仔细地遍历命令，你就能弄清楚它在做什么。

## 12.7 实验室

记住，`Where-Object` 不是过滤的唯一方式，甚至也不是你应该首先考虑的方式。我们保持这一章节简短，以便你有更多时间来实际操作。考虑到 *filter left* 原则，尝试完成以下任务：

1.  从 `PSReadLine` 模块获取命令。

1.  从 `PSReadLine` 模块获取使用动词 `Get` 的命令。

1.  显示 /usr/bin 下所有大于 5 MB 的文件。

1.  查找 PowerShell 画廊中以 `PS` 开头且作者以 Microsoft 开头的所有模块。

1.  获取当前目录中 `LastWriteTime` 在上周的文件。（提示：（`Get-Date).AddDays(-7`）将给出上周的日期。）

1.  显示所有以名称 `pwsh` 或名称 `bash` 运行的进程列表。

## 12.8 实验答案

1.  `Get-Command -Module PSReadLine`

1.  `Get-Command Get-* -Module PSReadLine`

1.  `Get-ChildItem /usr/bin/* | Where-Object {$_.length –gt 5MB}`

1.  `Find-Module -Name PS* | Where-Object {$_.Author -like 'Microsoft*'}`

1.  `Get-ChildItem | where-object LastWriteTime -ge (get-date).AddDays(-7)`

1.  `Get-Process -Name pwsh,bash`

## 12.9 进一步探索

熟能生巧，所以尝试过滤你已经学习过的 cmdlet 的输出，例如 `Get-ChildItem`、`Get-Process`，甚至是 `Get-Command`。例如，你可能尝试过滤 `Get-Command` 的输出，只显示 cmdlet。或者使用 `Test-Connection` 来 ping 几个计算机或网站（如 google.com 或 facebook.com），并只显示未响应的计算机的结果。我们并不是建议你在每种情况下都需要使用 `Where-Object`，但你应该在适当的时候练习使用它。
