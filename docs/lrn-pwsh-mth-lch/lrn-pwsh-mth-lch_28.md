# 附录。PowerShell 速查表

这是我们将许多小*陷阱*集中在一个地方的机会。如果你曾经遇到困难，记不起某个东西是什么或做什么，首先翻到这个附录。

## A.1 标点符号

PowerShell 充满了标点符号，其中许多在帮助文件中的含义与在 shell 本身中的含义不同。以下是它们在 shell 中的含义：

+   *反引号* (``` ` ``)——PowerShell 的转义字符。它移除了其后任何字符的特殊含义。例如，空格通常是一个分隔符，这就是为什么`cd c:\Program Files`会生成错误。转义空格，`cd c:\Program` `Files`，移除了这种特殊含义并强制空格被视为一个字面量，因此命令可以正常工作。

+   *波浪号* (`~`)——当波浪号用作路径的一部分时，它代表当前用户的家目录，如`UserProfile`环境变量中定义的那样。

+   *括号* `( )`——它们有几种用法：

    +   就像数学一样，括号定义了执行顺序。PowerShell 首先执行括号内的命令，从最内层的括号到最外层的括号。这是一种运行命令并将输出传递给另一个命令的参数的好方法：`Get-Service -computerName (Get-Content c:\computernames.txt)`。

    +   括号也包含了方法的参数，即使方法不需要任何参数也必须包含它们：例如，`$mystring.replace('ship','spaceship')` 或 `Delete()`。

+   *方括号* `[]`——在 shell 中有两个主要用途：

    +   当你想要引用数组或集合中的单个对象时，它们包含索引号：`$services[2]`从`$services`获取第三个对象（索引始终从 0 开始）。

    +   当你将数据转换为特定类型时，它们包含数据类型。例如，`$myresult / 3 -as [int]`将结果转换为整数（整数），而`[xml]$data = Get-Content data.xml`将读取`Data.xml`的内容并尝试将其解析为有效的 XML 文档。

+   *大括号* `{}`——也称为*大括号*，它们有三个用途：

    +   它们包含可执行代码块或命令，称为*脚本块*。这些通常被提供给期望脚本块或过滤器块的参数：例如，`Get-Service | Where-Object { $_.Status -eq 'Running' }`。

    +   它们包含组成新哈希表的键值对。开括号总是由一个`@`符号 precedes。在以下示例中，我们使用大括号来包围哈希表的键值对（有两个），以及包围一个表达式脚本块，这是第二个键`e: $hashtable = @{l='Label';e={expression}}`的值。

    +   当变量名包含空格或其他在变量名中通常非法的字符时，必须用大括号包围名称：`${My Variable}`。

+   *单引号* (`'`)——它们包含字符串值。PowerShell 在单引号内不寻找转义字符，也不寻找变量。

+   *双引号* (`"`)—这些包含字符串值。PowerShell 在双引号内查找转义字符和`$`字符。转义字符被处理，跟随`$`符号（字母数字字符）的字符被视为变量名，并替换该变量的内容。例如，如果变量`$one`包含值`World`，那么`$two = "Hello $one `n"`将包含`Hello World`和一个换行符（` `n ``是换行符）。

+   *美元符号* (`$`)—这告诉 shell，接下来的字母数字字符代表一个变量名。当与处理变量的 cmdlet 一起工作时，这可能会很棘手。假设`$one`包含值`two`，那么`New-Variable -name $one -value 'Hello'`将创建一个名为`two`的新变量，其值为`Hello`，因为美元符号告诉 shell 你想使用`$one`的内容。相比之下，`New-Variable -name one -value 'Hello'`将创建一个新变量`$one`。

+   *百分号* (`%`)—这是`ForEach-Object` cmdlet 的别名。它也是取模运算符，返回除法操作的余数。

+   *问号* (`?`)—这是`Where-Object` cmdlet 的别名。

+   *右尖括号* (`>`)—这是一种`Out-File` cmdlet 的别名。它不是真正的别名，但它确实提供了 cmd.exe 风格的文件重定向：`dir > files.txt`。

+   *数学运算符* (`+`, `-`, `*`, `/`, 和 `%`)—这些作为标准算术运算符。请注意，`+`也用于字符串连接。

+   *破折号或连字符* (`-`)—它位于参数名称和许多运算符之前，例如`-computerName`或`-eq`。它还分隔 cmdlet 名称的动词和名词部分，如`Get-Content`，并作为减法算术运算符。

+   *at 符号* (`@`)—在 shell 中有四种用途：

    +   它位于哈希表开括号之前（参见此列表中的括号）。

    +   当在括号之前使用时，它包围一个由逗号分隔的值列表，这些值形成一个数组：`$array = @(1,2,3,4)`。`@`符号和括号都是可选的，因为 shell 通常将任何由逗号分隔的列表视为数组。

    +   它表示一个 here-string，即一组字面字符串文本。here-string 以`@"`开始，以`"@"`结束，并且结束标记必须位于新行的开头。运行`help about_quoting_rules`获取更多信息及示例。here-string 也可以使用单引号定义。

    +   它是 PowerShell 的 splat 运算符。如果你构建一个键与参数名称匹配的哈希表，并且那些值的键是参数的值，那么你可以将哈希表 splat 到 cmdlet 中。运行`help about_splatting`了解更多信息。

+   *与号* (`&`)—这是 PowerShell 的调用运算符，指示 shell 将某物视为命令并运行它。例如，`$a = "Dir"`将字符串`Dir`放入变量`$a`中。然后`& $a`将运行`Dir`命令。

+   *分号* (`;`)—这用于分隔单行上包含的两个独立的 PowerShell 命令：`Dir ; Get-Process` 将运行 `Dir` 然后运行 `Get-Process`。结果被发送到单个管道，但 `Dir` 的结果不会传递到 `Get-Process`。

+   *井号，或哈希标签* (`#`)—这用作注释字符。任何跟在 `#` 后面，直到下一个换行符的字符都将被 shell 忽略。尖括号 (`<` 和 `>`) 用作定义块注释的标签的一部分：使用 `<#` 开始一个块注释，使用 `#>` 结束一个。块注释中的所有内容都将被 shell 忽略。

+   *等号* (`=`)—这是赋值运算符，用于将值赋给变量：`$one = 1`。它不用于质量比较；请使用 `-eq`。请注意，等号可以与数学运算符一起使用：`$var +=5` 将 `5` 添加到 `$var` 当前包含的内容中。

+   *管道* (`|`)—这用于将一个 cmdlet 的输出传递到另一个 cmdlet 的输入。第二个 cmdlet（接收输出的 cmdlet）使用管道参数绑定来确定哪些参数或参数将接收管道中的对象。第六章和第十章有关于此过程的讨论。

+   *正斜杠或反斜杠* (`/`, `\`)—这些在数学表达式中用作除法运算符；无论是正斜杠 (`/`) 还是反斜杠 (`\`) 都可以用作文件路径中的路径分隔符：C:\Windows 与 C:\Windows 相同。反斜杠还用作 WMI 过滤条件中的转义字符和在正则表达式中的转义字符。

+   *句号* (.)—它有三个主要用途：

    +   它用于表示你想访问一个成员，例如属性或方法，或一个对象：`$_.Status` 将访问 `$_` 占位符中任何对象的 `Status` 属性。

    +   它用于 dot-source 一个脚本，意味着该脚本将在当前作用域内运行，并且在该脚本完成后定义的任何内容都将保持定义：`. c:\myscript.ps1.`

    +   两个点 (`..`) 形成范围运算符，这在附录的后面部分有讨论。你还会看到两个点用于在文件系统中引用父文件夹，例如在 ..\ 路径中。

+   *逗号* (`,`)—在引号之外，逗号用于分隔列表或数组中的项：`"One",2,"Three",4`。它可以用来向可以接受它们的参数传递多个静态值：`Get-Process -computername Server1, Server2,Server3`。

+   *冒号* (`:` )—冒号（技术上，是两个冒号）用于访问类的静态成员；这涉及到 .NET 框架编程概念；`[-datetime]::now` 是一个例子（尽管你可以通过运行 `Get-Date` 完成相同的任务）。

+   *感叹号* (!)—这是 `-not` 布尔运算符的别名。

我们认为，在美式键盘上，PowerShell 没有积极使用的唯一标点符号是插入符 (`^`)，尽管这些在正则表达式中确实被使用。

## A.2 帮助文件

帮助文件中的标点符号具有略微不同的含义：

+   *方括号* `[]`—当方括号包围任何文本时，表示该文本是可选的。这可能包括整个参数（`[-Name <string>]`），或者它可能表示参数是位置性的，名称是可选的（`[-Name] <string>`）。它还可以表示参数是可选的，如果使用，则可以按位置使用（`[[-Name] <string>]`）。如果你有任何疑问，使用参数名称总是合法的。

+   *相邻方括号* `[]`—这表示参数可以接受多个值（`<string[]>`而不是`<string>`）。

+   *尖括号* `< >`—这些包围数据类型，表示参数期望的值或对象类型：`<string>`、`<int>`、`<process>`等等。

总是花时间阅读完整的帮助信息（在`help`命令中添加`-full`），因为它提供了最大细节，以及在大多数情况下，使用示例。

## A.3 操作符

PowerShell 不使用大多数编程语言中找到的传统比较运算符。相反，它使用这些：

+   `-eq`—相等（对于大小写敏感的字符串比较，使用`-ceq`）。

+   `-ne`—不等式（对于大小写敏感的字符串比较，使用`-cne`）。

+   `-ge`—大于或等于（对于大小写敏感的字符串比较，使用`-cge`）。

+   `-le`—小于或等于（对于大小写敏感的字符串比较，使用`-cle`）。

+   `-gt`—大于（对于大小写敏感的字符串比较，使用`-cgt`）。

+   `-lt`—小于（对于大小写敏感的字符串比较，使用`-clt`）。

+   `-contains`—如果指定的集合包含指定的对象，则返回`True`（`$collection -contains $object`）；`-notcontains`是相反的。

+   `-in`—如果指定的对象在指定的集合中，则返回`True`（`$object -in $collection`）；`-notin`是相反的。

逻辑运算符用于组合多个比较：

+   `-not`—反转`True`和`False`（`!`符号是该操作符的别名）。

+   `-and`—整个表达式为`True`，如果两个子表达式都必须为`True`。

+   `-or`—整个表达式为`True`，如果任一子表达式为`True`。

此外，还有一些执行特定功能的操作符：

+   `-join`—将数组的元素连接为一个分隔的字符串。

+   `-split`—将分隔的字符串拆分为数组。

+   `-replace`—将一个字符串的 occurrence 替换为另一个字符串。

+   `-is`—如果项目是指定的类型，则返回`True`（`$one -is [int]`）。

+   `-as`—将项目转换为指定的类型（`$one -as [int]`）。

+   `..`—是范围操作符；`1..10`返回 10 个对象，从 1 到 10。

+   `-f`—是格式化操作符，用值替换占位符：`"{0}, {1}" -f "Hello","World"`。

## A.4 自定义属性和列语法

在几个章节中，我们向您展示了如何使用`Select-Object`定义自定义属性，或者使用`Format-Table`和`-Format-List`分别定义自定义列和列表条目。以下是该散列表语法——您为每个自定义属性或列这样做：

```
@{label='Column_or_Property_Name';expression={Value_expression}}
```

两个键，`Label`和`Expression`，可以分别缩写为`l`和`e`（务必输入小写的*L*，而不是数字 1；您也可以使用`n`代替小写的*L*）：

```
@{n='Column_or_Property_Name';e={Value_expression}}
```

在表达式内部，可以使用`$_`占位符来引用当前对象（例如当前表行或您要添加自定义属性的对象）：

```
@{n='ComputerName';e={$_.Name}}
```

`Select-Object`和`Format-` cmdlet 都寻找`n`（或`name`、`label`或`l`）键和`e`键；`Format-` cmdlet 还可以使用`width`和`align`（这些仅用于`-Format-Table`）和`formatstring`。阅读`Format-Table`的帮助以获取示例。

## A.5 管道参数输入

在第十章中，您了解到有两种类型的参数绑定：`ByValue`和`ByPropertyName`。`ByValue`首先发生，而`ByPropertyName`只有在`ByValue`不起作用时才会发生。

对于`ByValue`，shell 会查看管道输入对象的类型。您可以通过将对象管道到`gm`来发现该类型名称。然后 shell 会检查是否有任何 cmdlet 的参数接受这种类型的输入，并配置为接受管道输入`ByValue`。在这种情况下，一个 cmdlet 不可能有两个参数绑定相同的数据类型。换句话说，您不应该看到一个 cmdlet 有两个参数，每个参数都接受`<string>`输入，并且都接受管道输入`ByValue`。

如果`ByValue`不起作用，shell 将切换到`ByPropertyName`。在这里，它会查看管道输入对象的属性，并尝试找到具有完全相同名称的参数，这些参数可以接受管道输入`ByPropertyName`。如果管道输入对象具有`Name`、`Status`和`ID`属性，shell 将检查 cmdlet 是否有名为`Name`、`Status`和`ID`的参数。这些参数还必须标记为接受管道输入`ByPropertyName`，您可以在阅读完整帮助时看到这一点（在`help`命令中添加`-full`）。

让我们看看 PowerShell 是如何做到这一点的。对于这个例子，我们将参考第一个 cmdlet 和第二个 cmdlet，假设您有一个类似于`Get-Service | Stop-Service`或`Get-Service | Stop-Process`的命令。PowerShell 遵循以下过程：

1.  第一个 cmdlet 产生的对象的`TypeName`是什么？您可以将 cmdlet 的结果管道到`Get-Member`来查看这一点。对于多部分类型名称，如`System.Diagnostics.Process`，只需记住最后那部分：`Process`。

1.  第二个 cmdlet 的任何参数接受第一个 cmdlet 产生的对象类型吗（阅读第二个 cmdlet 的完整帮助以确定这一点：`help <cmdlet name> -full`）？如果是这样，它们也使用`ByValue`技术从管道接受该输入吗？这可以在每个参数的帮助文件的详细信息中看到。

1.  如果步骤 2 的回答是肯定的，那么第一个 cmdlet 产生的整个对象将被附加到步骤 2 中指定的参数。你已经完成了——不要继续到步骤 4。但如果步骤 2 的回答是否定的，继续到步骤 4。

1.  考虑第一个 cmdlet 产生的对象。这些对象有哪些属性？你可以通过将第一个 cmdlet 的输出通过管道传递到`Get-Member`来查看这一点。

1.  考虑第二个 cmdlet 的参数（你需要再次阅读完整的帮助）。是否有任何参数（a）与步骤 4 中的某个属性同名，并且（b）使用`ByPropertyName`技术接受管道输入？

如果任何参数符合步骤 5 中的标准，属性值将被附加到同名参数，第二个 cmdlet 将运行。如果属性名称与`ByPropertyName`启用的参数之间没有匹配，第二个 cmdlet 将不带管道输入运行。

请记住，你可以在任何命令中手动输入参数和值。这样做将防止该参数以任何方式接受管道输入，即使它通常可以这样做。

## A.6 何时使用`$_`

这可能是关于壳（shell）最令人困惑的事情之一：何时允许使用`$_`占位符？正如我们之前所学的，`$_`是管道中下一个对象的占位符。

这个占位符仅在 shell 明确寻找它并准备用某物填充它时才有效。一般来说，这种情况只发生在处理管道输入的脚本块中，在这种情况下，`$_`占位符每次将包含一个管道输入对象。你会在几个地方遇到这种情况：

+   在`Where-Object`使用的过滤脚本块中：

    ```
    Get-Service | Where-Object {$_.Status -eq 'Running' }
    ```

+   在传递给`ForEach-Object`的脚本块中，例如通常与 cmdlet 一起使用的默认`Process`脚本块：

    ```
    Get-CimInstance -class Win32_Service -filter "name='mssqlserver'" |
    ForEach-Object -process { $_.ChangeStartMode('Automatic') }
    ```

+   在过滤函数或高级函数的`Process`脚本块中。Don Jones 和 Jeffery Hicks 的《一个月午餐中的 PowerShell 工具制作》（Manning, 2012）讨论了这些内容。

+   在用于创建自定义属性或表列的哈希表表达式中。

在所有这些情况下，`$_`仅在脚本块的括号内出现。这是一个很好的规则，可以帮助你确定何时可以使用`$_`。
