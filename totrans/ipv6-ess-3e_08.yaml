- en: Chapter 7. Transition Technologies
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章 过渡技术
- en: This chapter provides an overview of the various transition mechanisms that
    are available. IPv6 and IPv4 will coexist for many years, and there are a wide
    range of techniques that make coexistence possible and provide an easy transition.
    It is important to make the right choices and find the best migration path. There
    is not an easy one-size-fits-all strategy. The migration path has to be adjusted
    to the individual requirements of each organization and network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了各种可用的过渡机制。IPv6和IPv4将在未来多年共存，并且有多种技术使得共存成为可能，并提供了一个简单的过渡过程。选择正确的方案并找到最佳的迁移路径非常重要。没有一种“一刀切”的简单策略。迁移路径必须根据每个组织和网络的个别需求进行调整。
- en: 'The available techniques that support you in your transition are separated
    into three main categories:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 支持过渡的可用技术被分为三大类：
- en: '*Dual-stack techniques*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*双栈技术*'
- en: Allow IPv4 and IPv6 to coexist in the same devices and networks
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 允许IPv4和IPv6在相同的设备和网络中共存
- en: '*Tunneling techniques*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*隧道技术*'
- en: Allow the transport of IPv6 traffic over the existing IPv4 infrastructure
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在现有的IPv4基础设施上传输IPv6流量
- en: '*Translation techniques*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换技术*'
- en: Allow IPv6-only nodes to communicate with IPv4-only nodes
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 允许仅支持IPv6的节点与仅支持IPv4的节点进行通信
- en: These techniques can and likely will be used in combination with one another.
    The migration to IPv6 can be done step-by-step, starting with single hosts or
    subnets. You can migrate your corporate network or parts of it while your ISP
    still runs only IPv4, or your ISP can upgrade to IPv6 while your corporate network
    still runs IPv4\. This first section describes the techniques available today
    for each of these categories. RFC 4213, “Basic Transition Mechanisms for IPv6
    Hosts and Routers,” describes the dual-stack technique and configured tunneling.
    There has been a lot of change in this area; transition mechanisms that were key
    technologies at some point (such as 6to4) have been replaced by newer mechanisms,
    such as 6rd in the case of 6to4\. New technologies have been defined and even
    more are soon to come. This is the fulfillment of the promise that the IETF will
    develop new and adjusted transition mechanisms to provide solutions for enterprises
    as the need becomes obvious.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术可以并且很可能会相互结合使用。IPv6的迁移可以一步步进行，从单个主机或子网开始。你可以在ISP仍然只运行IPv4的情况下迁移你的企业网络或其部分网络，或者在ISP升级到IPv6的同时，企业网络仍然运行IPv4。本节描述了当前每一类技术的可用方案。RFC
    4213，《IPv6主机和路由器的基本过渡机制》描述了双栈技术和配置隧道。这个领域发生了很大的变化；曾经是关键技术的过渡机制（如6to4）已被更新的机制所替代，例如在6to4的情况下，6rd就是一种替代方案。新的技术不断被定义，并且更多的新技术即将到来。这实现了IETF承诺的目标，即在需求变得明显时，为企业开发新的和调整过的过渡机制，提供解决方案。
- en: Dual-Stack
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双栈
- en: A *dual-stack node* has complete support for both protocol versions. This type
    of node is often referred to as an *IPv6/IPv4 node*. In communication with an
    IPv6 node, such a node behaves like an IPv6-only node; in communication with an
    IPv4 node, it behaves like an IPv4-only node. Implementations may allow you to
    enable or disable one of the stacks, so this node type can have three modes of
    operation. When the IPv4 stack is enabled and the IPv6 stack is disabled, the
    node behaves like an IPv4-only node. When the IPv6 stack is enabled and the IPv4
    stack disabled, it behaves like an IPv6-only node. When both the IPv4 and IPv6
    stacks are enabled, the node can use both protocols. An IPv6/IPv4 node has at
    least one address for each enabled protocol version. It uses IPv4 mechanisms to
    be configured for an IPv4 address (static configuration or DHCP) and uses IPv6
    mechanisms to be configured for an IPv6 address (static configuration, SLAAC,
    or DHCPv6).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*双栈节点*完全支持两个协议版本。此类节点通常被称为*IPv6/IPv4节点*。在与IPv6节点通信时，这种节点表现得像一个仅支持IPv6的节点；在与IPv4节点通信时，它表现得像一个仅支持IPv4的节点。实现中可能允许你启用或禁用其中一个栈，因此这种节点类型有三种操作模式。当启用IPv4栈而禁用IPv6栈时，该节点表现得像一个仅支持IPv4的节点。当启用IPv6栈而禁用IPv4栈时，它表现得像一个仅支持IPv6的节点。当IPv4和IPv6栈都启用时，节点可以使用这两种协议。一个IPv6/IPv4节点为每个启用的协议版本至少有一个地址。它使用IPv4机制配置IPv4地址（静态配置或DHCP），并使用IPv6机制配置IPv6地址（静态配置、SLAAC或DHCPv6）。
- en: DNS is used with both protocol versions to resolve names and IP addresses. An
    IPv6/IPv4 node needs a DNS resolver that is capable of resolving both types of
    DNS address records. The DNS A record represents IPv4 addresses, and the DNS AAAA
    (referred to as quad-A) record represents IPv6 addresses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DNS在两个协议版本中都用于解析名称和IP地址。一个IPv6/IPv4节点需要一个能够解析两种类型DNS地址记录的DNS解析器。DNS A记录表示IPv4地址，DNS
    AAAA（称为四A记录）表示IPv6地址。
- en: Depending on how a service is reachable (over IPv4 or IPv6 or both), DNS may
    return only an IPv4 or only an IPv6 address, or both. Default address selection
    mechanisms and profiles will have to ensure that connections can be established
    efficiently in any case. Hopefully, both the DNS resolver on the client and an
    application using DNS will have configuration options that let us specify orders
    or filters of how to use the addresses (i.e., preferred protocol settings). Happy
    Eyeballs is a specification that has been developed to optimize connection setup
    in a dual-stacked world. Note that the DNS resolver may run over an IPv4 or IPv6
    network to resolve either type of address record.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务的可达方式（通过IPv4、IPv6或两者），DNS可能仅返回IPv4地址或仅返回IPv6地址，或者同时返回两者。默认地址选择机制和配置文件必须确保在任何情况下都能有效地建立连接。希望客户端上的DNS解析器和使用DNS的应用程序都能够提供配置选项，让我们指定如何使用地址的顺序或过滤器（即首选协议设置）。*Happy
    Eyeballs*是一项旨在优化双栈世界中连接设置的规范。请注意，DNS解析器可能通过IPv4或IPv6网络运行，以解析任何类型的地址记录。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a detailed discussion of IPv6 DNS and Happy Eyeballs, refer to [Chapter 5](ch05.html
    "Chapter 5. Networking").
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有关IPv6 DNS和*Happy Eyeballs*的详细讨论，请参见[第5章](ch05.html "第5章. 网络").
- en: A *dual-stack network* is an infrastructure in which both IPv4 and IPv6 forwarding
    is enabled on routers. The advantage of dual-stack is that you run both protocols
    in native mode. Once the infrastructure runs dual-stack you can start to migrate
    applications from IPv4 to IPv6 as they become available. And your traffic shifts
    from IPv4 to IPv6 smoothly. No tunneling and no translation is involved. This
    is best for performance, scalability, and efficiency. And there is no need to
    design, test, and deploy temporary transition mechanisms that need to be removed
    later on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*双栈网络*是一种基础设施，其中路由器启用了IPv4和IPv6转发。双栈的优势在于你可以原生运行这两种协议。一旦基础设施支持双栈，你就可以开始将应用程序从IPv4迁移到IPv6，并且流量会平稳地从IPv4切换到IPv6。整个过程中不涉及隧道和转换。这是性能、可扩展性和效率的最佳选择。同时也不需要设计、测试和部署临时的过渡机制，这些机制以后还需要移除。'
- en: For this technique you must perform a full network upgrade to run the two separate
    protocol stacks. All tables (e.g., routing tables) are kept simultaneously with
    routing protocols being configured for both protocols. For security, you need
    two concepts, one for IPv4 and one for IPv6, as you have two inroads into your
    network. For network management, on some operating systems you may still have
    separate commands depending on the protocol (e.g., *ping* for IPv4 and *ping6*
    for IPv6), and it takes more memory and CPU power. But with state-of-the-art hardware,
    this should not be an issue and the advantages of dual-stack outweigh the disadvantages
    by far.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种技术，你必须进行全面的网络升级，以运行两个独立的协议栈。所有表格（例如路由表）都需要同时保留，并为两个协议配置路由协议。出于安全考虑，你需要两个概念，一个用于IPv4，另一个用于IPv6，因为你有两条通向网络的入口。对于网络管理，在某些操作系统中，可能仍然需要根据协议使用不同的命令（例如，*ping*用于IPv4，*ping6*用于IPv6），这会占用更多的内存和CPU资源。但在现代硬件上，这应该不会成为问题，双栈的优势远远大于其劣势。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dual-stack is a good way to go for IPv6 deployment. But it requires that IPv4
    addresses are available for all hosts. If that is not the case, IPv6-only options
    such as NAT64, DS-Lite, MAP, or 464XLAT have to be used. These methods decouple
    edge network growth from IPv4 availability. They are discussed later in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 双栈是IPv6部署的一个好方法。但它要求所有主机都有IPv4地址。如果没有IPv4地址，则必须使用IPv6单一方案，如NAT64、DS-Lite、MAP或464XLAT。这些方法将边缘网络的增长与IPv4的可用性解耦。它们将在本章后面讨论。
- en: Another aspect to keep in mind is that dual-stack makes troubleshooting problems
    more complicated. For instance, did an application that has problems with IPv6
    attempt to connect via IPv4 instead of IPv6 and fail? How do you have to adjust
    your troubleshooting approaches to test and figure that out? Your helpdesk and
    IT support staff also need to understand how to use specific tools for IPv4 and
    IPv6 so they can rule out one protocol versus the other. So from an operational
    and support perspective, it may cost more to run a dual-stack network. This is
    one of the main reasons more and more enterprises consider migrating to an IPv6-only
    infrastructure as soon as possible. But more about this in [Chapter 9](ch09.html
    "Chapter 9. Planning for IPv6").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的方面是，双栈使故障排除变得更加复杂。例如，出现IPv6问题的应用程序是否尝试通过IPv4而不是IPv6进行连接并失败？你需要如何调整故障排除方法来测试并找出原因？你的帮助台和IT支持人员也需要理解如何使用特定的工具来处理IPv4和IPv6，以便能够排除其中一个协议的问题。因此，从操作和支持的角度来看，运行双栈网络可能需要更多成本。这也是越来越多企业考虑尽快迁移到IPv6-only基础设施的主要原因之一。有关更多信息，请参见[第9章](ch09.html
    "第9章：IPv6规划")。
- en: Tunneling Techniques
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隧道技术
- en: Tunneling mechanisms can be used to deploy an IPv6 forwarding infrastructure
    while the overall IPv4 infrastructure is still the basis and either should not
    or cannot be modified or upgraded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道机制可以用于部署IPv6转发基础设施，而整体IPv4基础设施仍然是基础，并且不应或不能被修改或升级。
- en: 'Tunneling is also called *encapsulation*. With encapsulation, one protocol
    (in our case, IPv6) is encapsulated in the header of another protocol (in our
    case, IPv4) and forwarded over the infrastructure of the second protocol (IPv4).
    The process of encapsulation has three components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道也称为*封装*。通过封装，一个协议（在我们的例子中是IPv6）被封装在另一个协议（在我们的例子中是IPv4）的头部，并通过第二个协议（IPv4）的基础设施转发。封装过程有三个组成部分：
- en: Encapsulation at the tunnel entry point
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隧道入口点的封装
- en: Decapsulation at the tunnel exit point
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隧道出口点的解封装
- en: Tunnel management
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隧道管理
- en: 'So tunneling can be used to carry IPv6 traffic by encapsulating it in IPv4
    packets and tunneling it over the IPv4 routing infrastructure. For instance, if
    your provider still has an IPv4-only infrastructure, tunneling allows you to have
    a corporate IPv6 network and tunnel through your ISP’s IPv4 network to reach other
    IPv6 hosts or networks. Or you can deploy IPv6 islands in your corporate network
    while the backbone is still IPv4\. IPv6 packets traveling from one IPv6 island
    to another can traverse the backbone encapsulated in IPv4 packets. General tunneling
    techniques and the encapsulation of IPv6 packets in IPv4 packets are defined in
    several RFCs, such as RFC 2473, “Generic Packet Tunneling in IPv6 Specification,”
    and RFC 4213, “Basic Transition Mechanisms for IPv6 Hosts and Routers.” We differentiate
    two general types of tunneling:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，隧道技术可以通过将IPv6流量封装在IPv4数据包中，并通过IPv4路由基础设施传输来承载IPv6流量。例如，如果你的服务提供商仍然只有IPv4基础设施，隧道可以让你拥有一个企业IPv6网络，并通过ISP的IPv4网络隧道传输到其他IPv6主机或网络。或者，你可以在企业网络中部署IPv6岛屿，而主干网络仍然是IPv4。IPv6数据包从一个IPv6岛屿到另一个IPv6岛屿可以通过主干网络以IPv4数据包封装的方式传输。通用的隧道技术和IPv6数据包在IPv4数据包中的封装已在多个RFC中定义，例如RFC
    2473《IPv6中的通用数据包隧道规范》和RFC 4213《IPv6主机和路由器的基本过渡机制》。我们区分两种常见的隧道类型：
- en: '*Manually configured tunneling of IPv6 over IPv4*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*手动配置的IPv6-over-IPv4隧道*'
- en: IPv6 packets are encapsulated in IPv4 packets to be carried over IPv4 routing
    infrastructures. These are point-to-point tunnels that need to be configured manually.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包被封装在IPv4数据包中，通过IPv4路由基础设施传输。这些是点对点隧道，需要手动配置。
- en: '*Automatic tunneling of IPv6 over IPv4*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动的IPv6-over-IPv4隧道*'
- en: IPv6 nodes can use different types of addresses, such as 6to4, 6rd, or ISATAP
    addresses, to dynamically tunnel IPv6 packets over an IPv4 routing infrastructure.
    These special IPv6 unicast addresses carry an IPv4 address in some parts of the
    IPv6 address fields, which can be used to determine the IPv4 address of the destination
    or the tunnel endpoint, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6节点可以使用不同类型的地址，例如6to4、6rd或ISATAP地址，来动态地通过IPv4路由基础设施隧道IPv6数据包。这些特殊的IPv6单播地址在IPv6地址字段的某些部分携带IPv4地址，可用于确定目标或隧道端点的IPv4地址。
- en: How Tunneling Works
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隧道是如何工作的
- en: The concepts discussed in this section apply to tunneling in general. The next
    two paragraphs discuss the difference between configured tunnels and automatic
    tunneling. [Figure 7-1](ch07.html#encapsulation_and_tunneling "Figure 7-1. Encapsulation
    and tunneling") shows two IPv6 networks connected through an IPv4-only network.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的概念适用于隧道技术的一般情况。接下来的两段将讨论配置隧道和自动隧道之间的区别。[图 7-1](ch07.html#encapsulation_and_tunneling
    "图 7-1. 封装与隧道")展示了通过一个仅支持 IPv4 的网络连接的两个 IPv6 网络。
- en: '![Encapsulation and tunneling](images/ipv6_0701.png)Figure 7-1. Encapsulation
    and tunneling'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![封装与隧道](images/ipv6_0701.png)图 7-1. 封装与隧道'
- en: Host Marvin is on an IPv6 network and wants to send an IPv6 packet to host Ford
    on another IPv6 network. The network between router R1 and router R2 is an IPv4-only
    network. Router R1 is the *tunnel entry point*. Marvin sends the IPv6 packet to
    router R1 (step 1 in [Figure 7-1](ch07.html#encapsulation_and_tunneling "Figure 7-1. Encapsulation
    and tunneling")). When router R1 receives the packet addressed to Ford, it encapsulates
    the packet in an IPv4 header and forwards it to router R2 (step 2 in [Figure 7-1](ch07.html#encapsulation_and_tunneling
    "Figure 7-1. Encapsulation and tunneling")), which is the *tunnel exit point*.
    Router R2 decapsulates the packet and forwards it to its final destination (step
    3 in [Figure 7-1](ch07.html#encapsulation_and_tunneling "Figure 7-1. Encapsulation
    and tunneling")). Between R1 and R2, any number of IPv4 routers is possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主机 Marvin 在一个 IPv6 网络中，并希望将 IPv6 数据包发送到另一个 IPv6 网络中的主机 Ford。路由器 R1 和路由器 R2 之间的网络是一个仅支持
    IPv4 的网络。路由器 R1 是 *隧道入口点*。Marvin 将 IPv6 数据包发送到路由器 R1（如[图 7-1](ch07.html#encapsulation_and_tunneling
    "图 7-1. 封装与隧道")中的步骤 1）。当路由器 R1 接收到发送给 Ford 的数据包时，它将数据包封装在 IPv4 头部中并转发到路由器 R2（如[图
    7-1](ch07.html#encapsulation_and_tunneling "图 7-1. 封装与隧道")中的步骤 2），后者是 *隧道出口点*。路由器
    R2 解封装数据包并将其转发到最终目的地（如[图 7-1](ch07.html#encapsulation_and_tunneling "图 7-1. 封装与隧道")中的步骤
    3）。在 R1 和 R2 之间，可能会有任意数量的 IPv4 路由器。
- en: 'A tunnel has two endpoints: the tunnel entry point and the tunnel exit point.
    In the scenario in [Figure 7-1](ch07.html#encapsulation_and_tunneling "Figure 7-1. Encapsulation
    and tunneling"), the tunnel end points are two routers, but the tunnel can be
    configured in different ways. It can be set up router-to-router, host-to-router,
    host-to-host, or router-to-host. Depending on which scenario is used, the tunnel
    entry and exit point can be either a host or a router.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道有两个端点：隧道入口点和隧道出口点。在[图 7-1](ch07.html#encapsulation_and_tunneling "图 7-1. 封装与隧道")的场景中，隧道端点是两台路由器，但隧道可以以不同方式配置。它可以设置为路由器到路由器、主机到路由器、主机到主机，或路由器到主机。根据所使用的场景，隧道的入口点和出口点可以是主机或路由器。
- en: 'The steps for the encapsulation of the IPv6 packet are the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 数据包封装的步骤如下：
- en: The entry point of the tunnel decrements the IPv6 hop limit by one, encapsulates
    the packet in an IPv4 header, and transmits the encapsulated packet through the
    tunnel. If necessary, the IPv4 packet is fragmented.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隧道的入口点将 IPv6 跳数限制减一，将数据包封装在 IPv4 头部中，并通过隧道传输封装后的数据包。如果需要，IPv4 数据包会被分片。
- en: The exit point of the tunnel receives the encapsulated packet. It checks whether
    the source of the packet (tunnel entry point) is an acceptable source (according
    to its configuration). If the packet was fragmented, the exit point reassembles
    it. Then, the exit point removes the IPv4 header and processes the IPv6 packet
    to its original destination.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隧道的出口点接收封装后的数据包。它会检查数据包的源（隧道入口点）是否是可接受的源（根据其配置）。如果数据包被分片，出口点会重新组装它。然后，出口点移除
    IPv4 头部，并将 IPv6 数据包处理到原始目的地。
- en: '[Figure 7-2](ch07.html#encapsulation "Figure 7-2. Encapsulation") shows the
    encapsulation of an IPv6 packet in an IPv4 packet.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.html#encapsulation "图 7-2. 封装")展示了一个 IPv6 数据包在 IPv4 数据包中的封装过程。'
- en: '![Encapsulation](images/ipv6_0702.png)Figure 7-2. Encapsulation'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![封装](images/ipv6_0702.png)图 7-2. 封装'
- en: 'The following fields in the IPv4 header are interesting to note: the Total
    Length field in the IPv4 header contains the length of the IPv4 header plus the
    length of the IPv6 packet, which is treated as the payload. If the encapsulated
    packet has to be fragmented, there will be corresponding values in the Flags and
    Fragment Offset fields. The value of the Time to Live (TTL) field depends on the
    implementation used. The Protocol Number is set to 41, the value assigned for
    IPv6\. Thus, if you want to analyze your tunneled IPv6 traffic, you can set a
    filter in your analyzer to display the packets containing the value 41 in the
    Protocol Number field. The IPv4 Source address is the address of the outgoing
    interface of the tunnel entry point. It should also be configurable for cases
    where automatic address selection may produce different results over time (multiple
    addresses/interfaces). The IPv4 Destination address is the IPv4 address of the
    tunnel exit point. The IPv6-over-IPv4 tunnel is considered a single hop. The Hop
    Limit field in the IPv6 header is therefore decremented by one. This hides the
    existence of a tunnel to the end user, and is not detectable by common tools such
    as *traceroute*. [Figure 7-3](ch07.html#encapsulation_in_the_trace_file "Figure 7-3. Encapsulation
    in the trace file") shows an encapsulated IPv6 packet in the trace file.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头中的以下字段值得注意：IPv4头中的总长度字段包含IPv4头的长度加上IPv6数据包的长度，而IPv6数据包被视为有效负载。如果封装的数据包需要被分段，则标志和分段偏移字段将包含相应的值。生存时间（TTL）字段的值取决于使用的实现。协议号设置为41，这是分配给IPv6的值。因此，如果你想分析隧道中的IPv6流量，可以在分析器中设置过滤器，以显示协议号字段中包含值41的数据包。IPv4源地址是隧道入口点的出接口地址。在自动地址选择可能随时间变化产生不同结果（多个地址/接口）的情况下，应该能够进行配置。IPv4目标地址是隧道出口点的IPv4地址。IPv6-over-IPv4隧道被视为单跳。因此，IPv6头中的跳数限制（Hop
    Limit）字段将减少1。这隐藏了隧道的存在，最终用户无法检测到，且无法通过诸如*traceroute*之类的常见工具检测到。[图7-3](ch07.html#encapsulation_in_the_trace_file
    "图7-3. 封装在跟踪文件中")显示了跟踪文件中的一个封装的IPv6数据包。
- en: '![Encapsulation in the trace file](images/ipv6_0703.png)Figure 7-3. Encapsulation
    in the trace file'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![封装在跟踪文件中](images/ipv6_0703.png)图7-3. 封装在跟踪文件中'
- en: The Ethertype is set to 0800, the value for IPv4\. The TTL in the IPv4 header
    is set to 128\. The Protocol field shows value 41 for IPv6, which identifies this
    packet as an encapsulated packet. The Source address `62.2.84.115` is the IPv4
    address of the tunnel entry point. The Destination address is the IPv4 address
    of a 6to4 relay router (explained later in this chapter) in the Internet, the
    tunnel exit point. This router can forward IPv6 packets to an IPv6 network. Compare
    these IPv4 addresses with the IPv6 Source and Destination addresses (which can
    be seen in the highlighted summary line above the detail screen). Use your Windows
    calculator to find out that the IPv6 Source and Destination addresses have the
    6to4 prefix of `2002` plus the IPv4 address in hexadecimal notation in the low-order
    32 bits. This is an example of a host-to-host automatic tunnel because we were
    actually pinging the 6to4 router.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ethertype设置为0800，这是IPv4的值。IPv4头中的TTL设置为128。协议字段显示值41，表示该数据包是一个封装的数据包。源地址`62.2.84.115`是隧道入口点的IPv4地址。目标地址是Internet中一个6to4中继路由器的IPv4地址（本章稍后将解释），即隧道出口点。该路由器可以将IPv6数据包转发到IPv6网络。将这些IPv4地址与IPv6源和目标地址进行比较（可以在详细屏幕上方的高亮汇总行中看到）。使用Windows计算器可以发现IPv6源和目标地址具有`2002`的6to4前缀，并且低32位包含IPv4地址的十六进制表示。这是一个主机到主机的自动隧道示例，因为我们实际上是在ping
    6to4路由器。
- en: If an IPv4 router from within the tunnel generates an ICMPv4 error message,
    the router sends the message to the tunnel entry point because that host is the
    source of that packet. If the packet contains enough information about the original
    encapsulated IPv6 packet, the tunnel entry point may send an ICMPv6 message back
    to the original source of the packet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果隧道内的一个IPv4路由器生成了一个ICMPv4错误消息，该路由器会将消息发送到隧道入口点，因为该主机是该数据包的源。如果数据包包含足够的关于原始封装的IPv6数据包的信息，隧道入口点可能会向数据包的原始源发送一个ICMPv6消息。
- en: 'When the tunnel exit point receives an IPv4 datagram with a protocol value
    of 41, it knows that this packet has been encapsulated. Before forwarding a decapsulated
    IPv6 packet, the tunnel endpoint must verify that the tunnel Source address is
    acceptable. Thus, unacceptable ingress into the network can be avoided. If the
    tunnel is a bidirectionally configured tunnel, this check is done by comparing
    the Source address of the encapsulated packet with the configured address of the
    other side of the tunnel. For unidirectionally configured tunnels, the tunnel
    must be configured with a list of source IPv4 address prefixes that are acceptable.
    By default, this list is empty, which means that the tunnel endpoint has to be
    explicitly configured to allow forwarding of decapsulated packets. In the case
    of fragmentation, the tunnel exit point reassembles the packets and removes the
    IPv4 header. Before delivering the IPv6 packet to the final destination, it checks
    to see if the IPv6 Source address is valid. The following Source addresses are
    considered invalid:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当隧道出口点接收到协议值为41的IPv4数据报时，它知道该数据包已经被封装。在转发解封装后的IPv6数据包之前，隧道终点必须验证隧道源地址是否可接受。这样可以避免网络中的不合法入口。如果隧道是双向配置的，则通过将封装数据包的源地址与隧道另一端配置的地址进行比较来进行此检查。对于单向配置的隧道，隧道必须配置一份可接受的源IPv4地址前缀列表。默认情况下，这个列表是空的，这意味着隧道终点必须明确配置，才能允许转发解封装后的数据包。在分片的情况下，隧道出口点会重新组装数据包并移除IPv4头。在将IPv6数据包交付给最终目的地之前，它会检查IPv6源地址是否有效。以下源地址被认为是无效的：
- en: All multicast addresses (`ff00::/8`)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有多播地址（`ff00::/8`）
- en: The loopback address (`::1`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回环地址（`::1`）
- en: All IPv4-compatible IPv6 addresses (`::/96`), excluding the unspecified address
    for Duplicate Address Detection (`::/128`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有IPv4兼容的IPv6地址（`::/96`），不包括用于重复地址检测的未指定地址（`::/128`）
- en: All IPv4-mapped IPv6 addresses (`::ffff:0:0/96`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有IPv4映射的IPv6地址（`::ffff:0:0/96`）
- en: Both tunnel endpoints need to have a link-local IPv6 address. The IPv4 address
    of that same interface may be the interface identifier for the IPv6 address. For
    example, a host with an IPv4 address of `192.168.0.2` may have a link-local address
    of `fe80::192.168.0.2/64.`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 两个隧道终点都需要具有链路本地IPv6地址。该接口的IPv4地址可以作为IPv6地址的接口标识符。例如，一个IPv4地址为`192.168.0.2`的主机可能具有`fe80::192.168.0.2/64`的链路本地地址。
- en: The specification contains rules that apply tunnel Source address verification
    and ingress filtering (RFCs 2827 and 3704) in general to packets before they are
    decapsulated. If further security mechanisms are desirable, a tunneling scheme
    with authentication can be used—for example, IPsec (preferable) or Generic Routing
    Encapsulation (GRE) with a preconfigured secret key (RFC 2890). Since the configured
    tunnels are set up manually, setting up the keying material is not a problem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范包含了一些规则，这些规则在隧道源地址验证和入口过滤（RFC 2827 和 3704）应用到数据包之前，通常适用于数据包的解封装。如果需要进一步的安全机制，可以使用带身份验证的隧道方案——例如，IPsec（更为推荐）或带预配置密钥的通用路由封装（GRE）（RFC
    2890）。由于配置的隧道是手动设置的，因此设置密钥材料不是问题。
- en: Automatic Tunneling
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动隧道
- en: Automatic tunneling allows IPv6/IPv4 nodes to communicate over an IPv4 infrastructure
    without the need for tunnel destination preconfiguration. The tunnel configuration
    information is extracted from an IPv4 address embedded in an IPv6 address. In
    a previous specification (RFC 2893, obsoleted by RFC 4213), the tunnel endpoint
    address was determined by an IPv4-compatible Destination address. RFC 4213 removes
    the description of automatic tunneling and IPv4-compatible addresses and refers
    to 6to4 (discussed later in this chapter), which does not use IPv4-compatible
    IPv6 addresses. 6to4 has its own IPv6 address format, which includes the IPv4
    address of the tunnel endpoint in the prefix and therefore allows for automatic
    tunneling. These days, 6to4 is not a recommended tunnel mechanism anymore; it
    has been replaced by 6rd. But more about this in the sections 6to4 and 6rd later
    in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自动隧道允许IPv6/IPv4节点通过IPv4基础设施进行通信，而无需预先配置隧道目标。隧道配置信息从嵌入在IPv6地址中的IPv4地址中提取。在之前的规范（RFC
    2893，已被RFC 4213废弃）中，隧道终端地址由IPv4兼容的目标地址决定。RFC 4213去除了自动隧道和IPv4兼容地址的描述，并转向6to4（本章稍后讨论），它不使用IPv4兼容的IPv6地址。6to4有自己的IPv6地址格式，包含了隧道终点的IPv4地址作为前缀，从而实现自动隧道。如今，6to4已经不再推荐作为隧道机制，它被6rd所替代。但关于这点将在本章后面的6to4和6rd部分进一步讨论。
- en: Configured Tunneling (RFC 4213)
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置隧道（RFC 4213）
- en: Configured tunneling is IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint
    addresses are determined by configuration information on the tunnel endpoints.
    All tunnels are assumed to be bidirectional. The tunnel provides a virtual point-to-point
    link to the IPv6 layer using the configured IPv4 addresses as the lower layer
    endpoint addresses. The administrative work to manage configured tunnels is higher
    than with automatic tunnels, but for security reasons it may be desirable, as
    it provides more possibilities to control the forwarding path of IPv6 packets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 配置隧道是指IPv6-over-IPv4隧道，其中IPv4隧道端点地址由隧道端点的配置信息决定。所有隧道假定是双向的。隧道通过使用配置的IPv4地址作为下层端点地址，为IPv6层提供一个虚拟的点对点链接。管理配置隧道的工作比自动隧道更复杂，但出于安全原因，这可能是可取的，因为它提供了更多控制IPv6数据包转发路径的可能性。
- en: RFC 4213 discusses the configuration and issues to be taken care of, such as
    determination of valid tunnel endpoint addresses (ingress filtering), how to deal
    with ICMPv4 or ICMPv6 messages, how to optimize tunnel MTU sizes, fragmentation,
    the header fields, Neighbor Discovery (ND) over tunnels, and security considerations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 4213讨论了配置和需要注意的问题，例如有效隧道端点地址的确定（入口过滤）、如何处理ICMPv4或ICMPv6消息、如何优化隧道MTU大小、分片、头部字段、隧道中的邻居发现（ND）以及安全考虑事项。
- en: IPv6/IPv4 hosts connected to network segments with no IPv6 routers can be configured
    with a static route to an IPv6 router in the Internet at the other side of an
    IPv4 tunnel; this enables communication with a remote IPv6 world. In this case,
    the IPv6 address of an IPv6/IPv4 router at the other end of the tunnel is added
    into the routing table as a default route. Now all IPv6 Destination addresses
    match the route and can be tunneled through the IPv4 infrastructure. This default
    route has a mask of zero and is used only if there are no other routes with a
    more specific matching mask.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到没有IPv6路由器的网络段的IPv6/IPv4主机，可以配置静态路由到Internet中位于IPv4隧道另一端的IPv6路由器；这使得与远程IPv6网络的通信成为可能。在这种情况下，隧道另一端IPv6/IPv4路由器的IPv6地址会作为默认路由添加到路由表中。现在，所有IPv6目标地址都匹配该路由，并可以通过IPv4基础设施进行隧道传输。此默认路由的掩码为零，只有在没有更具体匹配掩码的其他路由时才会使用。
- en: Encapsulation in IPv6 (RFC 2473)
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6封装（RFC 2473）
- en: RFC 2473 specifies the model and the generic mechanisms for encapsulation with
    IPv6\. Most of the rules discussed in this chapter about tunneling in IPv4 apply
    to tunneling in IPv6\. The main difference is that in tunneling in IPv6, the packets
    are encapsulated in an IPv6 header and sent through an IPv6 network. The packet
    being encapsulated can be an IPv4 packet, an IPv6 packet, or any other protocol.
    The tunnel entry point prepends the IPv6 header and, if needed, one or a set of
    Extension headers in front of the original packet header. Whatever the tunnel
    entry point prepends are called the *Tunnel IPv6 headers*. [Figure 7-4](ch07.html#tunnel_ipv6_headers_from_the_packet_view
    "Figure 7-4. Tunnel IPv6 headers from the packet view") shows the Tunnel IPv6
    headers in the packet view.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2473指定了IPv6封装的模型和通用机制。关于IPv4隧道的本章大部分规则同样适用于IPv6隧道。主要的区别在于，在IPv6隧道中，数据包被封装在IPv6头部中，并通过IPv6网络发送。被封装的数据包可以是IPv4数据包、IPv6数据包或任何其他协议。隧道入口点会在原始数据包头部前面加上IPv6头部，并在需要时，可能会加上一组扩展头部。无论隧道入口点添加的内容叫什么，都被称为*隧道IPv6头部*。[图7-4](ch07.html#tunnel_ipv6_headers_from_the_packet_view
    "图7-4. 从数据包视图看隧道IPv6头部")展示了数据包视图中的隧道IPv6头部。
- en: '![Tunnel IPv6 headers from the packet view](images/ipv6_0704.png)Figure 7-4. Tunnel
    IPv6 headers from the packet view'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![从数据包视图看隧道IPv6头部](images/ipv6_0704.png)图7-4. 从数据包视图看隧道IPv6头部'
- en: In the IPv6 header applied by the tunnel entry point, the Source address is
    the address of the tunnel entry point node, and the Destination address is the
    address of the tunnel exit point node. The source node of the original packet
    can be the same node as the tunnel entry point. The original packet, including
    its header, becomes the payload of the encapsulated packet. The header of the
    original packet is treated according to standard forwarding rules. If the header
    is an IPv4 header, the TTL field is decremented by one. If it is an IPv6 header,
    the Hop Limit field is decremented by one. The network between the tunnel entry
    point and the tunnel exit point is thus virtually just one hop, no matter how
    many actual hops there are in between.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在隧道入口点应用的 IPv6 头部中，源地址是隧道入口点节点的地址，目标地址是隧道出口点节点的地址。原始数据包的源节点可以与隧道入口点相同。原始数据包（包括其头部）成为封装数据包的有效载荷。原始数据包的头部将根据标准转发规则进行处理。如果头部是
    IPv4 头部，则 TTL 字段减一。如果是 IPv6 头部，则 Hop Limit 字段减一。隧道入口点和隧道出口点之间的网络因此实际上只算作一次跳跃，无论中间有多少实际跳跃。
- en: The Tunnel IPv6 header is processed according to the IPv6 protocol rules. Extension
    headers, if added, are processed as though the packet were a standard IPv6 packet.
    For example, a Hop-by-Hop Options header would be processed by every node listed
    in the Hop-by-Hop Options field. A Destination Options header would be processed
    by the destination host—i.e., the tunnel exit point. All these options are configured
    on the tunnel entry point. An example of the use of a Destination Options header
    is the configuration of a Tunnel Encapsulation Limit Option (RFC 2473). This option
    may be used when tunnels are nested. One hop of a tunnel can be the entry point
    of another tunnel. In this case, we have *nested tunnels*. The first tunnel is
    called the *outer tunnel*, and the second tunnel is called the *inner tunnel*.
    The inner tunnel entry point treats the whole packet received from the outer tunnel
    as the original packet and applies the same rules as shown in [Figure 7-6](ch07.html#the_tunnel_ipv6_header
    "Figure 7-6. The Tunnel IPv6 header"). The only natural limit to the number of
    nested tunnels is the maximum IPv6 packet size. Every encapsulation adds to the
    size of the tunnel IPv6 headers. This would allow for something around 1,600 nested
    tunnels, which is not realistic. Also, consider the case in which the packet has
    to be fragmented. If it has to be fragmented again because the additional tunnel
    IPv6 headers have increased the packet size, the number of fragments is doubled.
    So a mechanism was needed to limit the number of nested tunnels. It is specified
    in RFC 2473 and is called the Tunnel Encapsulation Limit Option. This option is
    carried in a Destination Option header and has the format shown in [Figure 7-5](ch07.html#format_of_the_tunnel_encapsulation_limit
    "Figure 7-5. Format of the Tunnel Encapsulation Limit Option").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道 IPv6 头部根据 IPv6 协议规则进行处理。如果添加了扩展头部，则按标准 IPv6 数据包的处理方式进行处理。例如，Hop-by-Hop 选项头将由列在
    Hop-by-Hop 选项字段中的每个节点处理。目的地选项头将由目标主机处理，即隧道出口点。所有这些选项都在隧道入口点进行配置。一个使用目的地选项头的例子是隧道封装限制选项的配置（RFC
    2473）。当隧道嵌套时，可以使用此选项。隧道的一跳可以是另一个隧道的入口点。在这种情况下，我们有*嵌套隧道*。第一个隧道称为*外部隧道*，第二个隧道称为*内部隧道*。内部隧道入口点将从外部隧道接收到的整个数据包视为原始数据包，并按照[图
    7-6](ch07.html#the_tunnel_ipv6_header "图 7-6. 隧道 IPv6 头部")中所示的规则进行处理。嵌套隧道的自然限制是最大
    IPv6 数据包大小。每次封装都会增加隧道 IPv6 头部的大小。这将允许大约 1,600 层嵌套隧道，但这并不现实。此外，考虑到数据包必须分片的情况。如果由于额外的隧道
    IPv6 头部增加了数据包大小而需要再次分片，则分片的数量会加倍。因此，需要一种机制来限制嵌套隧道的数量。它在 RFC 2473 中有所规定，称为隧道封装限制选项。此选项通过目的地选项头进行传输，格式如[图
    7-5](ch07.html#format_of_the_tunnel_encapsulation_limit "图 7-5. 隧道封装限制选项的格式")所示。
- en: '![Format of the Tunnel Encapsulation Limit Option](images/ipv6_0705.png)Figure 7-5. Format
    of the Tunnel Encapsulation Limit Option'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![隧道封装限制选项的格式](images/ipv6_0705.png)图 7-5. 隧道封装限制选项的格式'
- en: The Option Type field has 1 byte and the decimal value 4, specifying the Tunnel
    Encapsulation Limit Option. The Option Data Length field has the decimal value
    1, specifying the length of the following Option field. In this case, the Option
    field has a size of 1 byte and contains the actual value for the Tunnel Encapsulation
    Limit Option. The value in this field specifies how many further levels of encapsulation
    are permitted. If the value is zero, the packet is discarded and an ICMP Parameter
    Problem message is sent back to the source (the tunnel entry point of the previous
    tunnel). If the value is nonzero, the packet is encapsulated and forwarded. In
    this case, a new Tunnel Encapsulation Limit Option has to be applied with a value
    of one less than the limit received in the packet being encapsulated. If the packet
    received does not have a tunnel encapsulation limit, but this tunnel entry point
    has one configured, the tunnel entry point must apply a destination options header
    and include the configured value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Option Type字段占1字节，十进制值为4，指定了隧道封装限制选项（Tunnel Encapsulation Limit Option）。Option
    Data Length字段的十进制值为1，指定了后续Option字段的长度。在这种情况下，Option字段的大小为1字节，包含隧道封装限制选项的实际值。该字段中的值指定了允许的进一步封装级别数量。如果值为零，则数据包会被丢弃，并返回ICMP参数问题消息给源节点（即之前隧道的入口点）。如果值为非零，数据包会被封装并转发。在这种情况下，必须应用一个新的隧道封装限制选项，且其值应比接收到的数据包中的限制小1。如果接收到的数据包没有隧道封装限制，但该隧道入口点已配置了一个限制，隧道入口点必须应用目标选项头，并包含配置的值。
- en: '*Loopback encapsulation* should be avoided. Loopback encapsulation happens
    when a node encapsulates a packet originating from itself and destined to itself.
    IPv6 implementations should prevent this by checking and rejecting configurations
    of tunnels where both the entry and exit points belong to the same host. Another
    undesirable situation is a *routing-loop nested encapsulation*. This situation
    happens if a packet from an inner tunnel reenters an outer tunnel from which it
    has not yet exited. This can be controlled only by a combination of the original
    packet’s hop limit and the configuration of tunnel encapsulation limits.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*回环封装*应当避免。回环封装发生在一个节点将来自自身且目标为自身的数据包进行封装时。IPv6实现应该通过检查并拒绝配置两端都属于同一主机的隧道配置来防止这种情况。另一个不希望出现的情况是*路由环路嵌套封装*。这种情况发生在来自内层隧道的数据包重新进入外层隧道，而该数据包还未从外层隧道退出。这种情况只能通过原始数据包的跳数限制和隧道封装限制的配置相结合来控制。'
- en: Let’s have a closer look at a Tunnel IPv6 Header in [Figure 7-6](ch07.html#the_tunnel_ipv6_header
    "Figure 7-6. The Tunnel IPv6 header").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来更仔细地看看[图7-6](ch07.html#the_tunnel_ipv6_header "图7-6. 隧道IPv6头部")中的隧道IPv6头部。
- en: '![The Tunnel IPv6 header](images/ipv6_0706.png)Figure 7-6. The Tunnel IPv6
    header'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![隧道IPv6头部](images/ipv6_0706.png)图7-6. 隧道IPv6头部'
- en: 'The fields of a standard IPv6 header were discussed in [Chapter 3](ch03.html
    "Chapter 3. The Structure of the IPv6 Protocol"). Interesting values here are
    the following: the values for Traffic Class, Flow Label, and Hop Limit can be
    preconfigured on the tunnel entry point. The Payload Length has the value for
    the packet length of the original packet plus the size of any Extension headers
    prepended by the tunnel entry point. The Source and Destination Addresses of the
    Tunnel IPv6 header contain the IPv6 addresses of the tunnel entry and exit points,
    respectively. Note that a host configured as a tunnel entry point must support
    fragmentation of packets that it encapsulates. Encapsulated packets may exceed
    the Path MTU of the tunnel. Because the tunnel entry point is considered the source
    of the encapsulated packet, it must fragment it if needed. The tunnel exit point
    node will reassemble the packet. If the original packet is an IPv4 packet with
    the Don’t Fragment Bit set, the tunnel entry point discards the packet and sends
    an ICMP Destination Unreachable message with the code “fragmentation needed and
    DF set” back to the source of the packet.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 标准IPv6头部的各字段在[第3章](ch03.html "第3章 IPv6协议的结构")中进行了讨论。这里有一些有趣的值：流量类别、流标签和跳数限制的值可以在隧道入口点预配置。有效负载长度的值为原始数据包的包长加上隧道入口点前置的任何扩展头部的大小。隧道IPv6头部的源地址和目的地址分别包含隧道入口和出口点的IPv6地址。请注意，配置为隧道入口点的主机必须支持它封装的数据包的分段。如果封装的数据包超过了隧道的路径MTU，隧道入口点作为封装数据包的源，必须在需要时对其进行分段。隧道出口点节点将重新组装数据包。如果原始数据包是带有不分段位的IPv4数据包，隧道入口点会丢弃该数据包，并向数据包的源发送一个ICMP目标不可达消息，代码为“需要分段且DF设置”。
- en: Tunneling Mechanisms
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隧道机制
- en: The next sections describe a set of tunneling mechanisms available today. They
    are to be seen as a set of tools in your IPv6 toolbox. Analyze your environment
    and your requirements to find the optimal tools or combination of tools that meet
    your goals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节描述了目前可用的一系列隧道机制。它们应被视为你IPv6工具箱中的一组工具。分析你的环境和需求，以找到最适合你的目标的工具或工具组合。
- en: 6to4
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6to4
- en: RFC 3056, “Connection of IPv6 Domains via IPv4 Clouds,” specifies a mechanism
    for IPv6 sites to communicate with each other over the IPv4 network without explicit
    tunnel setup. This mechanism is called *6to4* and is one of the automatic tunneling
    mechanisms. The wide area IPv4 network is treated as a unicast point-to-point
    link layer, and the native IPv6 domains communicate via 6to4 routers, also referred
    to as 6to4 gateways. Note that only the 6to4 router needs to be 6to4 aware. No
    changes have to be made to the hosts within the 6to4 network.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 3056《通过IPv4云连接IPv6域》指定了一种机制，使IPv6站点能够通过IPv4网络彼此通信，而无需显式设置隧道。这个机制叫做*6to4*，是自动隧道机制之一。广域IPv4网络被视为单播点对点链路层，原生IPv6域通过6to4路由器通信，也称为6to4网关。请注意，只有6to4路由器需要支持6to4。6to4网络中的主机无需做任何更改。
- en: This was intended as a transition mechanism used during the period of coexistence
    of IPv4 and IPv6\. It will not be used as a permanent solution. 6to4 will also
    not be one of the strategic tunnel mechanisms. There are some disadvantages in
    the design that will be discussed later in this section. We still discuss the
    mechanism as it has not been deprecated, because there is a newer mechanism called
    *6rd*, which is based on 6to4 and is implemented in production networks. 6rd resolves
    some of the disadvantages of 6to4 and is also discussed later in this chapter.
    So back to 6to4.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这本来是作为IPv4和IPv6共存期间使用的过渡机制。它不会作为永久解决方案使用。6to4也不会成为战略性隧道机制之一。设计中有一些缺点将在本节后面讨论。我们仍然讨论这个机制，因为它没有被弃用，因为有一种基于6to4的新机制叫做*6rd*，并且已经在生产网络中实现。6rd解决了6to4的一些缺点，后面章节也会讨论。所以回到6to4。
- en: 'The IPv6 packets are encapsulated in IPv4 at the 6to4 gateway. At least one
    globally unique IPv4 unicast address is required for this configuration. The IANA
    has assigned a special prefix for the 6to4 scheme: `2002::/16`. [Figure 7-7](ch07.html#format_of_the_6to4_prefix
    "Figure 7-7. Format of the 6to4 prefix") shows the format of the 6to4 prefix in
    detail.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包在6to4网关处被封装到IPv4中。此配置至少需要一个全球唯一的IPv4单播地址。IANA为6to4方案分配了一个特殊的前缀：`2002::/16`。[图7-7](ch07.html#format_of_the_6to4_prefix
    "图7-7. 6to4前缀的格式")详细显示了6to4前缀的格式。
- en: '![Format of the 6to4 prefix](images/ipv6_0707.png)Figure 7-7. Format of the
    6to4 prefix'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![6to4 前缀格式](images/ipv6_0707.png)图 7-7. 6to4 前缀格式'
- en: The 32 bits after the prefix `2002::/16` are the IPv4 address of the gateway
    in hex representation. This leaves you with 80 bits of address space for your
    internal network. 16 bits are used for the local network addressing, so you can
    create 65,536 networks! The remaining 64 bits are used for the interface identifier
    of the nodes on your network; that is, 2^(64) nodes per subnet. It looks like
    getting familiar with the extended address space has some advantages. Now all
    the hosts on your network can communicate with other 6to4 hosts on the Internet.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀 `2002::/16` 后的 32 位是网关的 IPv4 地址的十六进制表示。这为你的内部网络提供了 80 位的地址空间。16 位用于本地网络寻址，因此你可以创建
    65,536 个网络！剩余的 64 位用于网络上节点的接口标识符；也就是说，每个子网可以有 2^(64) 个节点。看起来，熟悉扩展地址空间有一些优势。现在，网络中的所有主机都可以与互联网上的其他
    6to4 主机进行通信。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Figure 7-7](ch07.html#format_of_the_6to4_prefix "Figure 7-7. Format of the
    6to4 prefix"), there are terms such as FP (Format Prefix), TLA (Top Level Aggregator),
    and SLA (Site Level Aggregator). They come from an older IPv6 address architecture
    specification (RFC 2374). At the time when 6to4 was specified, RFC 2374 was still
    valid.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-7](ch07.html#format_of_the_6to4_prefix "图 7-7. 6to4 前缀格式")中，有一些术语，比如 FP（格式前缀）、TLA（顶级聚合器）和
    SLA（站点级聚合器）。它们来自较早的 IPv6 地址架构规范（RFC 2374）。在指定 6to4 时，RFC 2374 仍然有效。
- en: When a node in a 6to4 network wants to communicate with a node in another 6to4
    network, no tunnel configuration is necessary (automatic tunneling). The tunnel
    entry point takes the IPv4 address of the tunnel exit point from the IPv6 address
    of the destination. To communicate with an IPv6 node in a remote IPv6 network
    (which is not a 6to4 network), you need a *6to4 relay router*. The relay router
    is a router configured for 6to4 and IPv6\. It connects your 6to4 network to the
    native IPv6 network. It announces the 6to4 prefix of `2002::/16` into the native
    IPv6 network.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当 6to4 网络中的节点想要与另一个 6to4 网络中的节点通信时，不需要配置隧道（自动隧道）。隧道入口点通过目标 IPv6 地址中的 IPv4 地址来确定隧道出口点。要与远程
    IPv6 网络中的 IPv6 节点（该节点不是 6to4 网络的一部分）进行通信，你需要一个*6to4 中继路由器*。中继路由器是配置了 6to4 和 IPv6
    的路由器，它将你的 6to4 网络与原生 IPv6 网络连接起来，并将 `2002::/16` 的 6to4 前缀广播到原生 IPv6 网络中。
- en: '[Figure 7-8](ch07.html#to4_components "Figure 7-8. 6to4 components") shows
    the 6to4 components and how they play together.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-8](ch07.html#to4_components "图 7-8. 6to4 组件")展示了 6to4 组件以及它们如何协同工作。'
- en: '![6to4 components](images/ipv6_0708.png)Figure 7-8. 6to4 components'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![6to4 组件](images/ipv6_0708.png)图 7-8. 6to4 组件'
- en: The figure shows the different possible communication paths. Within site 1,
    hosts A and B can communicate using IPv6\. To communicate with host C in site
    2 (another 6to4 site), the packets are sent to router R1 in site 1\. Router R1
    encapsulates them in IPv4 and forwards them to Router R2 in site 2\. Router R1
    learns the IPv4 address of Router R2 from the IPv6 Destination address. Router
    R2 decapsulates the packet and forwards the original IPv6 packet to host C. To
    communicate with an IPv6-only host in the Internet, host A or B sends its IPv6
    packets to Router R1\. Router R1 encapsulates them in IPv4 and forwards them to
    the Relay Router R3\. Router R3 decapsulates the packet and forwards the original
    IPv6 packet over the IPv6 routing infrastructure to host D.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图中展示了不同的通信路径。在站点 1 内，主机 A 和 B 可以使用 IPv6 进行通信。要与站点 2 中的主机 C（另一个 6to4 网络）通信，数据包会被发送到站点
    1 的路由器 R1。路由器 R1 将其封装在 IPv4 中并转发给站点 2 的路由器 R2。路由器 R1 从目标 IPv6 地址中学习到路由器 R2 的 IPv4
    地址。路由器 R2 解封装数据包并将原始的 IPv6 数据包转发给主机 C。要与互联网上的 IPv6-only 主机通信，主机 A 或 B 会将其 IPv6
    数据包发送到路由器 R1。路由器 R1 将其封装在 IPv4 中并转发给中继路由器 R3。路由器 R3 解封装数据包，并通过 IPv6 路由基础设施将原始的
    IPv6 数据包转发给主机 D。
- en: Router R1 internally advertises the 6to4 prefix in its Router Advertisements
    (if configured to do so). The IPv6 hosts in site 1 can use the RA for Stateless
    Address Autoconfiguration of their IPv6 address. The prefix announced has the
    format `2002:IPv4-address-R1:subnet-ID::/64`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器 R1 会在其路由器通告中内部广播 6to4 前缀（如果已配置）。站点 1 中的 IPv6 主机可以利用路由器通告（RA）进行无状态地址自动配置（Stateless
    Address Autoconfiguration），以获取其 IPv6 地址。广播的前缀格式为 `2002:IPv4-address-R1:subnet-ID::/64`。
- en: To connect a 6to4 network with the IPv6 Internet, a convenient 6to4 relay can
    be evaluated and manually configured. The manual configuration has the advantage
    of providing control over the relays used but creates more administrative work.
    In case the preconfigured relay is not available, another relay needs to be configured.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要将6to4网络与IPv6互联网连接，可以评估并手动配置一个便捷的6to4中继。手动配置的优点是能够控制使用的中继，但会增加更多的管理工作。如果预配置的中继不可用，则需要配置另一个中继。
- en: RFC 3068 defines a 6to4 relay router anycast address to simplify the configuration
    of 6to4 gateways that need a default route to find a 6to4 relay router on the
    Internet. IANA assigned an IPv4 6to4 Relay anycast prefix of `192.88.99.0/24`.
    The assigned anycast address corresponds to the first node in the prefix, e.g.,
    `192.88.99.1`. The 6to4 routers have to be configured with a default route pointing
    to this anycast address. Using this address means that 6to4 packets are routed
    to the nearest available 6to4 relay router automatically. If one 6to4 relay goes
    down, you do not need to reconfigure your 6to4 gateway; packets will automatically
    be rerouted to the next available relay.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 3068定义了一个6to4中继路由器的任何播送地址，以简化需要默认路由来查找6to4中继路由器的6to4网关的配置。IANA为IPv4 6to4中继分配了一个任何播送前缀`192.88.99.0/24`。分配的任何播送地址对应于该前缀中的第一个节点，例如`192.88.99.1`。6to4路由器必须配置默认路由，指向此任何播送地址。使用该地址意味着6to4数据包会自动路由到最近的可用6to4中继路由器。如果一个6to4中继出现故障，你无需重新配置6to4网关；数据包会自动重新路由到下一个可用的中继。
- en: As mentioned before, 6to4 has some problems. Deployments showed that there are
    several cases where communication failures can occur. These failures can lead
    to long retry delays or to total communication failures for users trying to access
    services. The users are usually not aware of the fact that they use 6to4 and blame
    the applications and services for the failure. There were discussions going on
    to move 6to4 to historic status, but this would not eliminate the multitude of
    implementations out in the market. As 6to4 was one of the early and main transition
    technologies, it has been implemented widely. RFC 6343, “Advisory Guidelines for
    6to4 Deployment,” describes the observed issues and gives recommendations for
    6to4 deployment. In fact, implementations on many hosts and consumer routers now
    de-preference or eliminate 6to4 such that websites that enable native IPv6 see
    very little 6to4 traffic in practice today. You can see this in the [Google Statistics](http://www.google.com/intl/en/ipv6/statistics.html),
    where 6to4 and Teredo traffic is displayed in the red curve, which is down to
    zero basically since 2011\. The green curve that increases constantly is native
    IPv6 traffic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，6to4存在一些问题。部署实践表明，在某些情况下，通信可能会失败。这些故障可能导致用户在尝试访问服务时出现长时间的重试延迟，或完全无法通信。用户通常并不意识到他们正在使用6to4，而是将故障归咎于应用程序和服务。曾有人讨论将6to4置于历史状态，但这并不能消除市场上大量的实现方式。作为早期主要的过渡技术之一，6to4已被广泛实施。RFC
    6343《6to4部署建议指南》描述了观察到的问题，并提供了6to4部署的建议。实际上，许多主机和消费级路由器上的实现现在会降低或消除6to4的优先级，以至于启用原生IPv6的网站在实际中几乎看不到6to4流量。你可以在[Google统计](http://www.google.com/intl/en/ipv6/statistics.html)中看到这一点，其中6to4和Teredo流量显示在红色曲线中，自2011年以来几乎已经降到零。不断上升的绿色曲线则代表了原生IPv6流量。
- en: IPv6 Rapid Deployment—6rd
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv6快速部署——6rd
- en: 'Let me give you some background on the story behind 6rd before we dive into
    the workings of it. I kept preaching that providers and vendors should not wait
    until customers ask for IPv6, because customers would usually not care about transport
    protocols, but rather about services. So why should they ask for IPv6? But then
    the exception happened in France. Back in 2007, customers of Free (a French ISP
    belonging to the Iliad Group) made a request to Free, initiated by Remi Despres.
    More than 20,000 people signed a petition that they would pay one Euro more per
    month for getting IPv6 services. Within the incredibly short period of five weeks,
    Free provided IPv6 Internet access to 1.5 million users. They started from zero
    and did the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨6rd的工作原理之前，先给你介绍一下6rd背后的背景。我一直在强调，提供商和供应商不应等到客户要求IPv6时才行动，因为客户通常不会关注传输协议，而是关注服务。那么，为什么他们会要求IPv6呢？然而，法国发生了一个例外。早在2007年，Free（属于Iliad集团的法国ISP）的客户在Remi
    Despres的推动下向Free提出了请求。超过20,000人签署了一份请愿书，表示愿意每月多支付一欧元，以获得IPv6服务。在短短的五周时间内，Free为150万用户提供了IPv6互联网接入。他们从零开始，并做了以下工作：
- en: Obtained a /32 IPv6 prefix from their Regional Internet Registry (RIR)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其区域互联网注册机构（RIR）获得了一个/32的IPv6前缀
- en: Added 6rd support to the software of their Freebox home-gateway (based on the
    widely available 6to4 code)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向他们的Freebox家庭网关软件添加了6rd支持（基于广泛使用的6to4代码）
- en: Provisioned PC-compatible platforms with a 6to4 gateway software
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为PC兼容平台提供了6to4网关软件
- en: Modified it to support 6rd
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其修改为支持6rd
- en: Tested IPv6 operation with several operating systems and applications
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个操作系统和应用程序测试了IPv6的操作
- en: Finished operational deployment, by providing downloadable software to their
    Freeboxes
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供可下载的软件到Freebox，实现了操作部署
- en: Announced IPv6 Internet connectivity, at no extra charge, for all their customers
    wishing to activate it
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宣布为所有希望激活IPv6的客户提供IPv6互联网连接，且不收取额外费用
- en: IPv6 availability was limited in December 2007 to only one IPv6 link per customer
    site (with /64 site-prefix assignments). A few months later, after Free had detailed
    its achievement and plans to its RIR, and then obtained from it a /26 prefix,
    up to 16 IPv6 links per customer became possible (with /60 site-prefix assignments).
    At the IPv6 World Congress in 2011, Free announced that they would now enable
    IPv6 for all new users and after that for all users. This was a very significant
    announcement, as it was one of the first providers to provide IPv6 not just to
    users asking for IPv6, but to all users without asking.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 2007年12月，IPv6的可用性仅限于每个客户站点一个IPv6链路（/64站点前缀分配）。几个月后，在Free向其区域互联网注册机构（RIR）详细介绍了其成就和计划后，并从其获得了/26前缀，每个客户最多可拥有16个IPv6链路（/60站点前缀分配）。在2011年IPv6世界大会上，Free宣布他们将为所有新用户启用IPv6，随后为所有用户启用IPv6。这是一个非常重要的宣布，因为它是首批不仅为请求IPv6的用户提供IPv6，而且为所有用户无条件提供IPv6的ISP之一。
- en: For a long time, France has been leading in the percentage of IPv6-enabled Internet
    users, thanks to this. In 2013, Switzerland jumped up to number one, being the
    first country with a double digit user penetration rate (more than 10% of IPv6-enabled
    users). This was mainly possible thanks to Swisscom, who has also deployed 6rd.
    But let’s continue the Free story first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，法国在IPv6启用的互联网用户比例上处于领先地位，这要归功于此。2013年，瑞士跃升为第一，成为第一个IPv6启用用户渗透率达到两位数（超过10%）的国家。这主要得益于瑞士电信公司Swisscom，该公司也部署了6rd。但我们还是先继续讲Free的故事。
- en: 'So why did Free not simply use 6to4? For reasons mentioned before in the 6to4
    section there are certain limitations in 6to4 that prevented ISPs from using it.
    The first reason is the communication issues. Packets coming from a 6to4 network
    can easily reach nodes in other 6to4 networks or in the IPv6 Internet. But it
    is not always possible that packets coming from an IPv6 network can reach a 6to4
    site. The reason for this is that somewhere on their path these packets must traverse
    a 6to4 relay router. And there is no guarantee or control that routes toward such
    a relay router exist from anywhere and that all such relays forward packets toward
    the complete IPv4 Internet. Also, even if the ISP operates one or several 6to4
    relays and has them advertise the 6to4 prefix of `2002::/16` toward the IPv6 Internet,
    it may receive packets destined to an unknown number of other 6to4 ISPs. Furthermore,
    ISPs prefer to assign their customers addresses out of their public ISP range
    and not out of the 6to4 prefix. So Free has slightly modified 6to4 and made the
    following changes in order to improve the situation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么Free不直接使用6to4呢？如前面6to4部分所提到的，6to4存在一些限制，阻止了ISP使用它。第一个原因是通信问题。来自6to4网络的包可以轻松到达其他6to4网络或IPv6互联网中的节点。但来自IPv6网络的包并不总是能够到达6to4站点。原因在于，这些数据包在其路径中的某些地方必须经过一个6to4中继路由器。而且并没有保证或控制，从任何地方到这些中继路由器的路由都存在，并且所有这些中继都会将数据包转发到完整的IPv4互联网。另外，即使ISP运营一个或多个6to4中继，并让它们向IPv6互联网宣布6to4前缀`2002::/16`，它也可能接收到目标为未知数量的其他6to4
    ISP的数据包。此外，ISP更愿意从其公共ISP范围内为客户分配地址，而不是使用6to4前缀。因此，Free对6to4进行了略微修改，并做出了以下改动，以改善这种情况：
- en: They replaced the standard 6to4 prefix with their IPv6 prefix that belongs to
    the ISP-assigned address space.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用属于ISP分配地址空间的IPv6前缀替换了标准的6to4前缀
- en: They chose to replace the 6to4 anycast address by another anycast address chosen
    by the ISP.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们选择将6to4任播地址替换为ISP选择的另一个任播地址
- en: The ISP operates one or several 6rd gateways (which are upgraded 6to4 routers)
    at its border between its IPv4 infrastructure and the IPv6 Internet.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ISP在其IPv4基础设施与IPv6互联网之间的边界上运营一个或多个6rd网关（这些是升级版的6to4路由器）。
- en: CPEs (Customer Premises Equipment) support IPv6 on the customer-site side and
    support 6rd (which is upgraded 6to4 functionality) on the provider side.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPE（客户驻地设备）在客户侧支持 IPv6，在提供商侧支持 6rd（即升级版的 6to4 功能）。
- en: This creative and efficient deployment has been described in RFC 5569, if you
    are interested in more details. But as you can guess, this is not the end of the
    story.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这一创新高效的部署已经在 RFC 5569 中有所描述，如果您有兴趣了解更多细节。不过，正如您可以猜到的，这并不是故事的结尾。
- en: The IETF took notice of this rapid deployment and today 6rd is an official protocol
    specification defined in RFC 5969\. It has been adopted fast, and there are many
    implementations out there, and more and more providers are using it in production
    (such as Swisscom in Switzerland) or are considering it. To make it clear, this
    is an automatic tunneling mechanism that can be used by providers if their backbone
    does not support IPv6 natively yet. If the ISP doesn’t want to wait until he can
    upgrade his backbone he can choose to use 6rd in order to tunnel customer IPv6
    traffic over his IPv4-based backbone. But it should be a temporary solution. The
    final goal is to be native end-to-end.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: IETF 关注到了这一快速部署，今天 6rd 已成为 RFC 5969 中定义的官方协议规范。它已经得到快速采用，现有许多实现，并且越来越多的服务提供商开始在生产环境中使用它（例如瑞士的
    Swisscom），或者正在考虑采用它。需要明确的是，这是一种自动隧道机制，服务提供商可以在其骨干网尚未原生支持 IPv6 时使用它。如果 ISP 不想等待骨干网升级，可以选择使用
    6rd 来通过其基于 IPv4 的骨干网隧道化客户的 IPv6 流量。但这应当是一个临时解决方案，最终目标是实现端到端的原生 IPv6。
- en: Let us have a closer look at how 6rd is designed to work. And remember, many
    of the processes are similar to 6to4, so we describe the changes here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看 6rd 的设计工作原理。请记住，许多过程与 6to4 类似，因此我们在这里描述了变化之处。
- en: 'Let’s first define the terminology used in the RFC and in this section:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义 RFC 中以及本节中使用的术语：
- en: '*6rd Prefix*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 前缀*'
- en: An IPv6 prefix selected by the service provider. There is exactly one 6rd prefix
    for a given 6rd domain. A service provider can deploy 6rd with one or multiple
    6rd domains.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由服务提供商选择的 IPv6 前缀。每个 6rd 域仅有一个 6rd 前缀。一个服务提供商可以使用一个或多个 6rd 域来部署 6rd。
- en: '*6rd Customer Edge (CE)*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 客户边缘（CE）*'
- en: The customer edge router in a 6rd deployment. Sometimes also referred to as
    customer premises equipment (CPE). Usually has one WAN-side interface, one or
    more LAN-side interfaces, and a 6rd virtual interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 6rd 部署中的客户边缘路由器。有时也被称为客户驻地设备（CPE）。通常有一个 WAN 侧接口，一个或多个 LAN 侧接口，以及一个 6rd 虚拟接口。
- en: '*6rd Delegated Prefix*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 委托前缀*'
- en: The IPv6 prefix calculated by the CE to be used within the customer network.
    It is built by combining the 6rd prefix with the IPv4 address of the CE received
    by IPv4 configuration methods. This is equivalent to the DHCPv6 delegated prefix
    described in RFC 3633 and in [Chapter 5](ch05.html "Chapter 5. Networking").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由 CE 计算出的用于客户网络中的 IPv6 前缀。它通过将 6rd 前缀与 CE 收到的 IPv4 地址（通过 IPv4 配置方法获取）结合来构建。这等同于
    RFC 3633 中描述的 DHCPv6 委托前缀，也可以在 [第 5 章](ch05.html "第 5 章. 网络")中找到。
- en: '*6rd Domain*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 域*'
- en: A set of 6rd CEs and BRs connected to the same virtual 6rd link. Each 6rd domain
    requires a separate 6rd prefix.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一组连接到相同虚拟 6rd 链接的 6rd CE 和 BR。每个 6rd 域需要一个独立的 6rd 前缀。
- en: '*CE LAN side*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*CE LAN 侧*'
- en: This interface serves the customer-facing side of the CE and is fully IPv6 enabled.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口服务于 CE 的面向客户的侧，并且完全支持 IPv6。
- en: '*CE WAN side*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*CE WAN 侧*'
- en: This interface serves the WAN side of the CE and is IPv4 only.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口服务于 CE 的 WAN 侧，并且仅支持 IPv4。
- en: '*6rd Border Relay (BR)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 边界中继（BR）*'
- en: A 6rd-enabled router managed by the SP, sitting at the border between the SP’s
    IPv4 network and the native IPv6 Internet (or another IPv6 network). It has at
    least an IPv4-enabled interface toward the SP network, a 6rd virtual interface
    acting as an endpoint for the 6rd tunnel, and an IPv6 interface connecting to
    the native IPv6 network.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由服务提供商管理的 6rd 启用路由器，位于服务提供商的 IPv4 网络与原生 IPv6 互联网（或其他 IPv6 网络）之间的边界。它至少有一个面向服务提供商网络的
    IPv4 启用接口，一个充当 6rd 隧道终端的 6rd 虚拟接口，以及一个连接到原生 IPv6 网络的 IPv6 接口。
- en: '*6rd Virtual Interface*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 虚拟接口*'
- en: Internal tunnel interface that encapsulates and decapsulates IPv6 packets. A
    typical CE or BR requires only one 6rd virtual interface, but no more than one
    per 6rd domain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个内部隧道接口，用于封装和解封装 IPv6 数据包。典型的 CE 或 BR 仅需要一个 6rd 虚拟接口，但每个 6rd 域最多只需要一个。
- en: One of the most obvious changes is the fact that 6rd does not use the 6to4 prefix
    (`2002::/16`). It uses the service provider’s IPv6 prefix. This way the operational
    domain is limited to the SP’s network and he has direct control over it. The RFC
    states that from the customer perspective and the IPv6 Internet, 6rd can be seen
    as equivalent to native IPv6\. Addresses assigned from the 6rd-delegated prefix
    are treated like native IPv6 in the default address selection rules (RFC 6724).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的变化之一是，6rd不使用6to4前缀（`2002::/16`）。它使用服务提供商的IPv6前缀。这样，操作域就限制在SP的网络内，并且SP可以直接控制该网络。RFC指出，从客户角度和IPv6互联网的角度来看，6rd可以视为等同于原生IPv6。6rd委托的前缀分配的地址在默认地址选择规则（RFC
    6724）中被视为原生IPv6。
- en: '[Figure 7-9](ch07.html#a_6rd_network "Figure 7-9. A 6rd network") shows the
    layout of a 6rd network.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-9](ch07.html#a_6rd_network "图7-9. 6rd网络")显示了6rd网络的布局。'
- en: '![A 6rd network](images/ipv6_0709.png)Figure 7-9. A 6rd network'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![6rd网络](images/ipv6_0709.png)图7-9. 6rd网络'
- en: A 6rd domain consists of 6rd customer edge routers (CE) and one or more 6rd
    border relays (BR). 6rd packets are encapsulated in an IPv4 header and therefore
    follow IPv4 routing within the SP’s IPv4 network. The BR is traversed if the packet
    is destined to or coming from networks outside of the SP’s network. 6rd works
    stateless, and thus, similar to 6to4, the BR can be reached using anycast for
    failover. In this case the BR’s IPv4 address can be an anycast address shared
    within the 6rd domain. The BR will use this address as a source address in packets
    relayed to CEs. Since 6rd uses provider address space, no specific routes need
    to be advertised externally for 6rd to operate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个6rd域由6rd客户边缘路由器（CE）和一个或多个6rd边界中继（BR）组成。6rd数据包被封装在IPv4头中，因此它们在SP的IPv4网络中遵循IPv4路由。当数据包的目标是来自SP网络外部的网络时，必须经过BR。6rd是无状态工作的，因此，类似于6to4，BR可以使用任播进行故障转移。在这种情况下，BR的IPv4地址可以是6rd域内共享的任播地址。BR将在转发到CE的数据包中使用该地址作为源地址。由于6rd使用服务提供商地址空间，因此不需要为6rd的运行在外部宣传特定的路由。
- en: Let’s have a look at how prefix delegation works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看前缀委托是如何工作的。
- en: The 6rd prefix is created by combining the IPv6 prefix defined by the SP with
    all or a part of the IPv4 address of the CE. From these two elements the 6rd delegated
    prefix is automatically configured by the CE and is used in the same manner as
    a prefix obtained via DHCPv6 prefix delegation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 6rd前缀是通过将SP定义的IPv6前缀与CE的IPv4地址的全部或部分组合来创建的。通过这两个元素，CE自动配置6rd委托的前缀，并像通过DHCPv6前缀委托获取的前缀一样使用。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to [Chapter 5](ch05.html "Chapter 5. Networking") for details on DHCPv6
    and prefix delegation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关DHCPv6和前缀委托的详细信息，请参阅[第5章](ch05.html "第5章. 网络").
- en: In 6to4, we have a well-known /16 prefix (`2002::/16`) followed by a 32-bit
    IPv4 address at a fixed location within the prefix. The 6to4 prefix is a /48 prefix.
    In 6rd, the IPv6 prefix and also the position and number of bits of the IPv4 address
    can vary. With 6rd the SP can adjust the size of the 6rd prefix. He can choose
    how many bits are used by the 6rd mechanism and how many bits are left to be delegated
    to the customer sites. To allow for Stateless Address Autoconfiguration, the prefix
    assigned to the customer site should be at least a /64\. It would be preferable
    to assign an even shorter prefix, such as a /60 or even a /56, in order to allow
    the customer to further subnet his IPv6 network.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在6to4中，我们有一个众所周知的/16前缀（`2002::/16`），后面跟着一个位于前缀固定位置的32位IPv4地址。6to4的前缀是/48前缀。而在6rd中，IPv6前缀以及IPv4地址的位置和位数可以变化。使用6rd时，服务提供商（SP）可以调整6rd前缀的大小。他可以选择6rd机制使用多少位，以及有多少位留给客户站点。为了支持无状态地址自动配置，分配给客户站点的前缀应该至少是/64。为了使客户能够进一步对子网进行划分，最好分配一个更短的前缀，如/60，甚至是/56。
- en: '[Figure 7-10](ch07.html#the_format_of_the_6rd_address "Figure 7-10. The format
    of the 6rd address") shows the format of the 6rd address.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-10](ch07.html#the_format_of_the_6rd_address "图7-10. 6rd地址格式")显示了6rd地址的格式。'
- en: '![The format of the 6rd address](images/ipv6_0710.png)Figure 7-10. The format
    of the 6rd address'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![6rd地址格式](images/ipv6_0710.png)图7-10. 6rd地址格式'
- en: The length of the delegated 6rd prefix is the sum of the number of bits of the
    6rd prefix (n) plus the number of bits of the IPv4 address (o). If the SP uses
    his /32 provider prefix and the full IPv4 address of the CE (32 bits), the customer
    will get a /64 prefix. If the SP wants to delegate a shorter prefix such as a
    /60 or /56, he can vary the number of bits in the prefix. Using less than the
    full 32 bits of an IPv4 address is possible, if a block of aggregatable IPv4 addresses
    is available for a 6rd domain (depending on the ISP’s IPv4 address plan). So as
    an example, if the IPv4 addresses can be aggregated as 10.1.0.0/8, the prefix
    for 6rd will be a /56 (32 + 24 = 56). In this case the customer network has 8
    bits for subnetting available (64 − 56 = 8).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 委派的 6rd 前缀长度是 6rd 前缀位数（n）与 IPv4 地址位数（o）之和。如果服务提供商使用他的 /32 提供商前缀和 CE 的完整 IPv4
    地址（32 位），客户将获得一个 /64 前缀。如果服务提供商希望委派较短的前缀，例如 /60 或 /56，他可以调整前缀的位数。如果可以为 6rd 域提供一块可聚合的
    IPv4 地址块（取决于 ISP 的 IPv4 地址计划），则可以使用少于 32 位的 IPv4 地址。因此，举个例子，如果 IPv4 地址可以聚合为 10.1.0.0/8，那么
    6rd 的前缀将是 /56（32 + 24 = 56）。在这种情况下，客户网络有 8 位可供子网划分（64 − 56 = 8）。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since 6rd delegated prefixes are selected algorithmically from an IPv4 address,
    changing the IPv4 address also changes the IPv6 prefix, which could be disruptive
    for the customer network. It is recommended to have either static IPv4 addresses
    on the CE or assign IPv4 addresses with long lifetimes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 6rd 委派的前缀是从 IPv4 地址通过算法选择的，改变 IPv4 地址也会改变 IPv6 前缀，这可能会对客户网络产生干扰。因此，建议在 CE
    上使用静态 IPv4 地址或分配长期有效的 IPv4 地址。
- en: While the protocol mechanism in 6rd allows for use within smaller allocations,
    it is much simpler operationally to support mapping of the full 32 bits of the
    IPv4 address into the 6rd prefix. This is what operators often prefer to do. The
    worry is that operators will use a /32 and give a customer only a /64, which is
    very problematic for any home network that has more than a single subnet. We expect
    that the home network in the future needs multiple subnets, for example, for guest
    plus home Wi-Fi support and to manage smart building components and multimedia
    devices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 6rd 协议机制允许在较小的地址分配中使用，但从操作上来说，支持将完整的 32 位 IPv4 地址映射到 6rd 前缀中要简单得多。这也是运营商通常更倾向于使用的方法。担心的是，运营商可能会使用
    /32 地址并只为客户分配 /64 前缀，这对于任何具有多个子网的家庭网络来说是非常有问题的。我们预计未来家庭网络需要多个子网，例如，为客用和家庭 Wi-Fi
    提供支持，并管理智能建筑组件和多媒体设备。
- en: This is the reason the developers are putting so much effort into changing the
    allocation policies. In the RIPE region as an ISP you can currently get a /29,
    which allows you to assign a /30 to be used for 6rd customers. ARIN currently
    has a special policy that allows for a /24 “separate allocation” with some special
    provisions associated. Other regions may have different rules. This is work and
    discussion in progress, so check with your local registry what the current rules
    are.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开发人员投入大量精力更改分配策略的原因。在 RIPE 区域，作为 ISP，您目前可以获得一个 /29 地址，这允许您为 6rd 客户分配一个 /30
    地址。ARIN 当前有一项特殊政策，允许进行 /24 的“单独分配”，并附带一些特别规定。其他区域可能有不同的规则。这项工作和讨论仍在进行中，因此请与当地注册机构核实当前规则。
- en: 'The 6rd CEs and BRs must be configured with the following elements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 6rd CEs 和 BRs 必须配置以下元素：
- en: '*IPv4 Mask Length*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4 子网掩码长度*'
- en: The number of high-order bits that are identical across all CE IPv4 addresses
    within the 6rd domain. For example, if there are no identical bits, the IPv4 mask
    length is zero and the entire CE IPv4 address is used in the 6rd prefix (32 bits).
    If there are 8 identical bits, the IPv4 mask length is 8 and the 8 high-order
    bits from the IPv4 address are stripped off before constructing the 6rd delegated
    prefix.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 6rd 域内，所有 CE IPv4 地址中相同的高阶位的数量。例如，如果没有相同的位，则 IPv4 子网掩码长度为零，整个 CE IPv4 地址都用于
    6rd 前缀（32 位）。如果有 8 个相同的位，则 IPv4 子网掩码长度为 8，并且在构建 6rd 委派前缀之前会去掉 IPv4 地址中的 8 个高阶位。
- en: '*6rd Prefix*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 前缀*'
- en: The 6rd prefix for the given 6rd domain.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 6rd 域的 6rd 前缀。
- en: '*6rd Prefix Length*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd 前缀长度*'
- en: The length of the 6rd IPv6 prefix for the given 6rd domain.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 6rd 域的 6rd IPv6 前缀长度。
- en: '*6rd BR IPv4 address*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*6rd BR IPv4 地址*'
- en: The IPv4 address of the 6rd BR for the given 6rd domain.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 6rd 域的 6rd BR 的 IPv4 地址。
- en: There is a 6rd DHCPv4 option with Option Code 212 and it looks as shown in [Figure 7-11](ch07.html#the_format_of_the_6rd_dhcpv4_option
    "Figure 7-11. The format of the 6rd DHCPv4 option").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 6rd DHCPv4 选项，选项代码为 212，格式如 [图 7-11](ch07.html#the_format_of_the_6rd_dhcpv4_option
    "图 7-11. 6rd DHCPv4 选项格式") 所示。
- en: '![The format of the 6rd DHCPv4 option](images/ipv6_0711.png)Figure 7-11. The
    format of the 6rd DHCPv4 option'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![6rd DHCPv4 选项格式](images/ipv6_0711.png)图 7-11. 6rd DHCPv4 选项格式'
- en: The 6rd Option Code is set to 212\. The Option Length field shows the length
    of the DHCP option in octets (22 octets with one BR IPv4 address). The IPv4 Mask
    Length field shows the number of high-order bits that are identical across all
    CE IPv4 addresses within a given 6rd domain. This can be a value between 0 and
    32\. The 6rd Prefix Length field shows the IPv6 prefix length of the SP’s 6rd
    prefix in number of bits. The 6rd BR IPv4 Address field contains one or more IPv4
    addresses of the 6rd Border Relay(s) for a given 6rd domain. And finally the 6rd
    Prefix field contains the 6rd prefix as a 16-octet IPv6 address. The number of
    bits in the prefix after the number of bits specified in the 6rd prefix length
    field must be set to zero by the sender and ignored by the receiver.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 6rd 选项代码设置为 212。选项长度字段显示 DHCP 选项的长度（以八位字节为单位，22 字节，其中包含一个 BR IPv4 地址）。IPv4 掩码长度字段显示在给定的
    6rd 域内所有 CE IPv4 地址相同的高位比特数。该值可以在 0 和 32 之间。6rd 前缀长度字段显示 SP 的 6rd 前缀的 IPv6 前缀长度（以比特为单位）。6rd
    BR IPv4 地址字段包含给定 6rd 域的一个或多个 6rd 边界中继的 IPv4 地址。最后，6rd 前缀字段包含 6rd 前缀，作为一个 16 字节的
    IPv6 地址。在 6rd 前缀长度字段指定的比特数之后，前缀中的比特必须由发送方设置为零，并由接收方忽略。
- en: When 6rd is enabled, a typical CE router will create a default route to the
    BR, a black hole route for the 6rd delegated prefix, and routes for any LAN-side
    assigned and advertised prefixes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用 6rd 时，典型的 CE 路由器将创建一个默认路由指向 BR，一个针对 6rd 委派前缀的黑洞路由，以及用于任何 LAN 侧分配和通告前缀的路由。
- en: ISATAP
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ISATAP
- en: The *Intra-Site Automatic Tunnel Addressing Protocol* (ISATAP) is designed to
    provide IPv6 connectivity for dual-stack nodes over an IPv4-based network. It
    treats the IPv4 network as one large link-layer network and allows those dual-stack
    nodes to automatically tunnel between each other. You can use this automatic tunneling
    mechanism regardless of whether you have global or private IPv4 addresses. ISATAP
    addresses embed an IPv4 address in the EUI-64 interface identifier. Note that
    all nodes in an ISATAP network need to support ISATAP. ISATAP is specified in
    RFC 5214.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*站点内自动隧道地址协议*（ISATAP）旨在通过基于 IPv4 的网络为双栈节点提供 IPv6 连接。它将 IPv4 网络视为一个大的链路层网络，允许这些双栈节点之间自动建立隧道。无论您是否拥有全球或私有
    IPv4 地址，都可以使用这一自动隧道机制。ISATAP 地址在 EUI-64 接口标识符中嵌入了一个 IPv4 地址。请注意，ISATAP 网络中的所有节点都需要支持
    ISATAP。ISATAP 在 RFC 5214 中进行了规定。'
- en: '[Figure 7-12](ch07.html#the_format_of_the_isatap_address "Figure 7-12. The
    format of the ISATAP address") shows the format of the ISATAP address.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-12](ch07.html#the_format_of_the_isatap_address "图 7-12. ISATAP 地址格式")
    显示了 ISATAP 地址的格式。'
- en: '![The format of the ISATAP address](images/ipv6_0712.png)Figure 7-12. The format
    of the ISATAP address'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![ISATAP 地址格式](images/ipv6_0712.png)图 7-12. ISATAP 地址格式'
- en: The ISATAP address has a standard 64-bit prefix that can be link-local, site-local,
    a 6to4 prefix, or can belong to the global unicast range. The interface identifier
    is built using the IANA OUI `00-00-5E`, which follows the prefix. The following
    byte is a type field, and the value `fe` indicates that this address contains
    an embedded IPv4 address. The last four bytes contain the IPv4 address, which
    can be written in dotted decimal notation. The format of the address can thus
    be summarized as `64bitPrefix:5efe:IPv4address`. For instance, if you have an
    assigned prefix of `2001:db8:510::/64` and an IPv4 address of `62.2.84.115`, your
    ISATAP address is `2001:db8:510::200:5efe:3e02:5473`. Alternatively, you can write
    `2001:db8:510::200:5efe:62.2.84.115`. The corresponding link-local address would
    be `fe80::200:5efe:62.2.84.115`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ISATAP 地址具有一个标准的 64 位前缀，可以是链路本地、站点本地、6to4 前缀，或者属于全局单播范围。接口标识符是使用 IANA OUI `00-00-5E`
    构建的，紧跟前缀。接下来的字节是类型字段，值 `fe` 表示该地址包含一个嵌入的 IPv4 地址。最后四个字节包含 IPv4 地址，可以用点分十进制表示。因此，地址的格式可以总结为
    `64bitPrefix:5efe:IPv4address`。例如，如果您分配的前缀是 `2001:db8:510::/64`，而 IPv4 地址是 `62.2.84.115`，那么您的
    ISATAP 地址为 `2001:db8:510::200:5efe:3e02:5473`。或者，您可以写成 `2001:db8:510::200:5efe:62.2.84.115`。对应的链路本地地址将是
    `fe80::200:5efe:62.2.84.115`。
- en: ISATAP interfaces form ISATAP interface identifiers from their IPv4 addresses
    and use them to create link-local ISATAP addresses. The Neighbor Discovery mechanisms
    specified in RFC 4861 are used (router and prefix discovery).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ISATAP 接口通过其 IPv4 地址形成 ISATAP 接口标识符，并使用这些标识符来创建链路本地 ISATAP 地址。使用 RFC 4861 中指定的邻居发现机制（路由器和前缀发现）。
- en: 'An ISATAP router is an IPv6 router that is also reachable over IP4 and performs
    the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ISATAP 路由器是一个 IPv6 路由器，同时也可以通过 IPv4 访问，并执行以下操作：
- en: Advertises address prefixes to identify the logical ISATAP subnet on which ISATAP
    hosts are located.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播地址前缀以标识 ISATAP 主机所在的逻辑 ISATAP 子网。
- en: Forwards packets between ISATAP hosts on the logical ISATAP subnet and IPv6
    hosts on other subnets (IPv4 subnets or IPv6 subnets).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在逻辑 ISATAP 子网中的 ISATAP 主机与其他子网（IPv4 子网或 IPv6 子网）中的 IPv6 主机之间转发数据包。
- en: Acts as a default router for ISATAP hosts.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 ISATAP 主机的默认路由器。
- en: Configures hosts on the logical subnet with router advertisements.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置逻辑子网中的主机，通过路由器广告进行配置。
- en: Using ISATAP, IPv6 hosts within an IPv4 intranet can communicate with each other.
    If they want to communicate with IPv6 hosts on the Internet, a border router must
    be configured; it can be an ISATAP router or a 6to4 gateway. The IPv4 addresses
    of the hosts within the site do not need to be public. They are embedded in the
    address with the standard prefix and are therefore unique and routable. Large
    numbers of ISATAP hosts can be assigned to one ISATAP prefix. If you deploy IPv6
    on a segment in your corporate network, you configure one of the native IPv6 nodes
    with an ISATAP interface, and it acts as a router between the native IPv6 segment
    and ISATAP hosts in the IPv4 segments.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ISATAP，IPv4 内部网络中的 IPv6 主机可以相互通信。如果它们想与互联网中的 IPv6 主机通信，则必须配置边界路由器；该路由器可以是
    ISATAP 路由器或 6to4 网关。内部网络中主机的 IPv4 地址不需要是公共的，它们被嵌入到标准前缀的地址中，因此是唯一且可路由的。大量的 ISATAP
    主机可以分配到一个 ISATAP 前缀下。如果你在公司网络的某个段上部署 IPv6，你可以将一个本地 IPv6 节点配置为 ISATAP 接口，它将充当本地
    IPv6 段和 IPv4 段中 ISATAP 主机之间的路由器。
- en: ISATAP is an easy-to-deploy mechanism if you want to test and play quickly and
    have an IPv4-routed network only. It can also easily give access to the IPv6 Internet
    for a number of IPv6 users in an IPv4 network. But it is not recommended to use
    in production networks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ISATAP 是一种易于部署的机制，如果你想快速测试和使用并且仅有一个 IPv4 路由的网络，它会非常方便。它也可以轻松为 IPv4 网络中的多个 IPv6
    用户提供 IPv6 互联网访问。但不建议在生产网络中使用。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In an unmanaged IPv6 network, you should make sure to disable ISATAP on all
    hosts and block IPv6 traffic at the border for security reasons.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个无管理的 IPv6 网络中，出于安全原因，你应确保在所有主机上禁用 ISATAP，并在边界上阻止 IPv6 流量。
- en: Teredo
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Teredo
- en: 6to4 makes IPv6 available over an IPv4 infrastructure using public IPv4 addresses.
    ISATAP enables deployment of IPv6 hosts within an IPv4 site regardless of whether
    it uses public or private IPv4 addresses. Teredo is designed to make IPv6 available
    to hosts through one or more layers of NAT by tunneling packets over UDP. It is
    specified in RFC 4380\. There are extensions defined in RFC 6081 to support more
    types of NAT and RFC 5991 contains security extensions for Teredo.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 6to4 使得 IPv6 可以通过 IPv4 基础设施使用公共 IPv4 地址进行通信。ISATAP 使得在 IPv4 网络中可以部署 IPv6 主机，无论是否使用公共或私有
    IPv4 地址。Teredo 旨在通过在一个或多个 NAT 层级之间隧道传输数据包，利用 UDP 使 IPv6 可用。它在 RFC 4380 中有所规定。RFC
    6081 中定义了支持更多类型 NAT 的扩展，RFC 5991 则包含了针对 Teredo 的安全扩展。
- en: 'Many Internet users, especially many home users, can access the Internet only
    through NATs (Network Address Translation). NATs create issues when tunneling
    IPv6 over an IPv4 infrastructure mainly for two reasons: first, NAT users have
    a private IPv4 address, and second, many NATs are configured to perform ingress
    filtering and do not allow many types of payload to go through. With tunneling,
    the IPv6 packet is the payload of IPv4\. Mechanisms such as 6to4 often fail in
    these environments because they require a public IPv4 address. 6to4 can be used
    in NAT environments if the 6to4 router runs on the same box as NAT. In all other
    cases, other mechanisms have to be chosen. In our future IPv6 world, we will no
    longer need NATs, but for the coming transition time, we will have to deal with
    them. Therefore, IPv6 developers are working on mechanisms to allow users sitting
    behind NATs to access the IPv6 world by tunneling IPv6 packets in UDP. One of
    these mechanisms is Teredo.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网用户，特别是许多家庭用户，只能通过NAT（网络地址转换）访问互联网。NAT在通过IPv4基础设施隧道IPv6时会产生问题，主要有两个原因：首先，NAT用户使用私有IPv4地址；其次，许多NAT配置了入口过滤，不允许许多类型的载荷通过。使用隧道时，IPv6数据包是IPv4的载荷。像6to4这样的机制在这些环境中通常会失败，因为它们需要公共IPv4地址。如果6to4路由器与NAT在同一设备上运行，则可以在NAT环境中使用6to4。在所有其他情况下，必须选择其他机制。在我们未来的IPv6世界中，我们将不再需要NAT，但在过渡时期，我们必须处理它们。因此，IPv6开发人员正在研究允许位于NAT后面的用户通过UDP隧道IPv6数据包访问IPv6世界的机制。其中一种机制就是Teredo。
- en: 'The following terms are used with Teredo:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下术语与Teredo一起使用：
- en: '*Teredo Service*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo服务*'
- en: The transmission of IPv6 packets over UDP.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过UDP传输IPv6数据包。
- en: '*Teredo Client*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo客户端*'
- en: A node that has access to the IPv4 Internet and needs access to the IPv6 Internet.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以访问IPv4互联网并需要访问IPv6互联网的节点。
- en: '*Teredo Server*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo服务器*'
- en: A node that has access to the IPv4 Internet through a public IPv4 address and
    is used to provide IPv6 connectivity to Teredo clients.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以通过公共IPv4地址访问IPv4互联网的节点，用于为Teredo客户端提供IPv6连接。
- en: '*Teredo Relay*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo中继*'
- en: An IPv6 router that can receive traffic destined to Teredo clients and forward
    it using the Teredo service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IPv6路由器，可以接收目标为Teredo客户端的流量，并使用Teredo服务将其转发。
- en: '*Teredo IPv6 Service Prefix*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo IPv6服务前缀*'
- en: An IPv6 addressing prefix used to construct the IPv6 address of Teredo clients.
    The global Teredo prefix assigned by IANA is `2001:0000::/32`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构造Teredo客户端IPv6地址的IPv6地址前缀。IANA分配的全局Teredo前缀是`2001:0000::/32`。
- en: '*Teredo UDP port*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo UDP端口*'
- en: The UDP port number at which Teredo servers are waiting for packets. The default
    value of this port is 3544.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo服务器等待数据包的UDP端口号。该端口的默认值是3544。
- en: '*Teredo Bubble*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo气泡*'
- en: A minimal IPv6 packet made of an IPv6 header and a null payload (payload type
    is set to 59, No Next Header). Teredo clients and relays use bubbles to create
    a mapping in a NAT.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最小的IPv6数据包，由IPv6头部和空载荷组成（载荷类型设置为59，即无下一个头部）。Teredo客户端和中继使用气泡在NAT中创建映射。
- en: '*Teredo Service port*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo服务端口*'
- en: The port from which the Teredo client sends Teredo packets. This port is attached
    to one of the client’s IPv4 addresses.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo客户端发送Teredo数据包的端口。此端口附加在客户端的IPv4地址之一上。
- en: '*Teredo Server Address*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo服务器地址*'
- en: The IPv4 address of the Teredo server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo服务器的IPv4地址。
- en: '*Teredo-mapped Address and Teredo-mapped Port*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo映射地址和Teredo映射端口*'
- en: A global IPv4 address and a UDP port that results from the translation of the
    IPv4 address and UDP port of a client’s Teredo service port by one or more NATs.
    The client learns these values through the Teredo protocol.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由一个或多个NAT转换的客户端Teredo服务端口的IPv4地址和UDP端口构成的全局IPv4地址和UDP端口。客户端通过Teredo协议学习这些值。
- en: '*Teredo IPv6 Client Prefix*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo IPv6客户端前缀*'
- en: A global IPv6 prefix composed of the Teredo IPv6 service prefix and the Teredo
    server address.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由Teredo IPv6服务前缀和Teredo服务器地址组成的全局IPv6前缀。
- en: '*Teredo Node Identifier*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo节点标识符*'
- en: A 64-bit identifier that contains the UDP port and IPv4 address at which a client
    can be reached through the Teredo service. A flag indicates the type of NAT through
    which the client accesses the IPv4 Internet.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个64位标识符，包含客户端可以通过Teredo服务访问的UDP端口和IPv4地址。一个标志指示客户端通过哪个类型的NAT访问IPv4互联网。
- en: '*Teredo IPv6 Address*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo IPv6地址*'
- en: A Teredo IPv6 address obtained by combining a Teredo IPv6 client prefix and
    a Teredo node identifier.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Teredo IPv6客户端前缀和Teredo节点标识符结合获得的Teredo IPv6地址。
- en: '*Teredo Refresh Interval*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo刷新间隔*'
- en: The interval during which a Teredo IPv6 address is expected to remain valid
    in the absence of “refresh” traffic. The interval depends on configuration parameters
    of the local NAT(s) in the path to the Teredo server. By default, clients assume
    an interval value of 30 seconds.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有“刷新”流量的情况下，Teredo IPv6 地址预期保持有效的时间间隔。该时间间隔取决于到达 Teredo 服务器路径中本地 NAT 配置的参数。默认情况下，客户端假定该时间间隔为
    30 秒。
- en: '*Teredo Secondary Port*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo 第二端口*'
- en: A UDP port used to send or receive packets in order to determine the appropriate
    value of the refresh interval, but not used to carry any Teredo traffic.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发送或接收数据包以确定刷新间隔的适当值的 UDP 端口，但不用于承载任何 Teredo 流量。
- en: '*Teredo IPv6 Discovery Address*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*Teredo IPv6 发现地址*'
- en: An IPv4 multicast address used to discover other Teredo clients on the IPv4
    subnet. The multicast address is `224.0.0.253`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在 IPv4 子网中发现其他 Teredo 客户端的 IPv4 多播地址。多播地址是 `224.0.0.253`。
- en: The Teredo service transports IPv6 packets as payload of UDP.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 服务将 IPv6 数据包作为 UDP 的有效负载进行传输。
- en: The Teredo design aims to provide robust access to IPv6 networks. This design
    creates some overhead. Teredo is only to be used if no other, more direct access
    is possible. For instance, if it is possible to implement a 6to4 or even a 6rd
    gateway on a NAT, this is the preferable solution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 设计旨在为 IPv6 网络提供可靠的访问。此设计带来了一些开销。只有在没有其他更直接访问方式的情况下，才应使用 Teredo。例如，如果可以在
    NAT 上实现 6to4 或甚至 6rd 网关，这是更优的解决方案。
- en: A Teredo address has the format shown in [Figure 7-13](ch07.html#format_of_the_teredo_address-id1
    "Figure 7-13. Format of the Teredo address").
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 地址的格式如 [图7-13](ch07.html#format_of_the_teredo_address-id1 "图7-13. Teredo
    地址格式") 所示。
- en: '![Format of the Teredo address](images/ipv6_0713.png)Figure 7-13. Format of
    the Teredo address'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Teredo 地址格式](images/ipv6_0713.png)图7-13. Teredo 地址格式'
- en: The Teredo service prefix has 32 bits and is `2001:0000::/32`. The Server IPv4
    field has a length of 32 bits and contains the IPv4 address of the Teredo server.
    The Flags field has 16 bits and defines the address and the NAT type used. The
    16-bit Port field contains the mapped UDP port of the Teredo Service on the client;
    the Client IPv4 field contains the mapped IPv4 address of the client. The bits
    in the Port and Client address field are all obfuscated. Each bit in the address
    and port number is reversed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 服务前缀有 32 位，值为 `2001:0000::/32`。服务器 IPv4 字段长度为 32 位，包含 Teredo 服务器的 IPv4
    地址。标志字段有 16 位，定义了地址和使用的 NAT 类型。16 位的端口字段包含客户端 Teredo 服务的映射 UDP 端口；客户端 IPv4 字段包含客户端的映射
    IPv4 地址。端口和客户端地址字段中的所有位都被混淆。地址和端口号中的每一位都被反转。
- en: '[Figure 7-14](ch07.html#teredo_communication "Figure 7-14. Teredo communication")
    shows the Teredo communication.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-14](ch07.html#teredo_communication "图7-14. Teredo 通信") 显示了 Teredo 通信。'
- en: '![Teredo communication](images/ipv6_0714.png.jpg)Figure 7-14. Teredo communication'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Teredo 通信](images/ipv6_0714.png.jpg)图7-14. Teredo 通信'
- en: A Teredo client must be preconfigured with the IPv4 address of its Teredo server.
    On booting, it sends a Router solicitation to the all-routers multicast address
    from its link-local IPv6 address. The Router solicitation is sent to the IPv4
    address of the Teredo server over UDP. The Router advertisement coming back from
    the Teredo server contains the Teredo IPv6 Service prefix. The client builds its
    Teredo IPv6 address by combining the prefix with the reversed values for address
    and port.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 客户端必须预先配置其 Teredo 服务器的 IPv4 地址。启动时，它从其链路本地 IPv6 地址向所有路由器多播地址发送路由器请求。路由器请求通过
    UDP 发送到 Teredo 服务器的 IPv4 地址。来自 Teredo 服务器的路由器广告包含 Teredo IPv6 服务前缀。客户端通过将前缀与地址和端口的反转值组合，构建其
    Teredo IPv6 地址。
- en: When the Teredo server forwards packets from Teredo clients, it encapsulates
    the IPv6 packet in a UDP packet. It builds the IPv4 address and the UDP port for
    the destination from the destination IPv6 address. It uses its own IPv4 address
    as Source address and the Teredo UDP port (3544) as source port. The Teredo server’s
    job is to forward packets from Teredo clients over UDP to the right Destination
    address and to forward packets for Teredo clients coming from outside to the right
    client internally.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Teredo 服务器转发来自 Teredo 客户端的数据包时，它将 IPv6 数据包封装在 UDP 数据包中。它根据目标 IPv6 地址构建 IPv4
    地址和 UDP 端口。它使用自身的 IPv4 地址作为源地址，并使用 Teredo UDP 端口（3544）作为源端口。Teredo 服务器的任务是通过 UDP
    将来自 Teredo 客户端的数据包转发到正确的目标地址，并将来自外部的数据包转发给内部的正确客户端。
- en: The Teredo Relay is an IPv6 router announcing the Teredo Service prefix to the
    outside world using regular IPv6 routing mechanisms.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 中继是一个 IPv6 路由器，使用常规 IPv6 路由机制向外界广播 Teredo 服务前缀。
- en: Teredo was one of the early transition mechanisms and like 6to4 is widely implemented.
    It is not recommended to use Teredo in production networks. Your Microsoft Windows
    clients often have Teredo activated by default (depending on OS version and patch
    level). Make sure, whatever operating system you are using, to verify that Teredo
    is turned off.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Teredo 是早期的过渡机制之一，像 6to4 一样被广泛实现。不推荐在生产网络中使用 Teredo。你的 Microsoft Windows 客户端通常默认启用
    Teredo（具体取决于操作系统版本和补丁级别）。无论你使用什么操作系统，请确保确认 Teredo 已被关闭。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In an unmanaged IPv6 network, you should make sure to disable Teredo on all
    hosts and block IPv6 traffic at the border for security reasons.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个未管理的 IPv6 网络中，出于安全考虑，你应该确保在所有主机上禁用 Teredo，并在边界处阻止 IPv6 流量。
- en: Tunnel Broker
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隧道代理
- en: Tunnel Brokers can be seen as virtual IPv6 providers providing IPv6 Internet
    connectivity to users that already have an IPv4 connection to the Internet. The
    Tunnel Broker is specified in RFC 3053.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道代理可以被视为虚拟的 IPv6 提供商，为已经通过 IPv4 连接到互联网的用户提供 IPv6 互联网连接。隧道代理在 RFC 3053 中有所规定。
- en: '[Figure 7-15](ch07.html#how_the_tunnel_broker_works "Figure 7-15. How the Tunnel
    Broker works") illustrates how the Tunnel Broker works.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-15](ch07.html#how_the_tunnel_broker_works "图 7-15. 隧道代理如何工作") 展示了隧道代理的工作原理。'
- en: '![How the Tunnel Broker works](images/ipv6_0715.png)Figure 7-15. How the Tunnel
    Broker works'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![隧道代理如何工作](images/ipv6_0715.png)图 7-15. 隧道代理如何工作'
- en: A user desiring an IPv6 connection registers with the Tunnel Broker. The Tunnel
    Broker manages the establishment, maintenance, and deletion of the tunnel on behalf
    of the user. The Tunnel Broker can share the data load across several *Tunnel
    Servers*. The Tunnel Broker sends the configuration information to a Tunnel Server
    when it wants to establish, change, or delete a tunnel. The Tunnel Broker also
    registers the addresses in DNS if it is configured to do so. A Tunnel Broker must
    be reachable with an IPv4 address. It can also have an IPv6 address, but it is
    not required. The communication between Tunnel Broker and Tunnel Server can run
    over either IPv4 or IPv6.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 IPv6 连接的用户向隧道代理注册。隧道代理代表用户管理隧道的建立、维护和删除。隧道代理可以将数据负载分摊到多个*隧道服务器*。隧道代理在需要建立、变更或删除隧道时，会将配置信息发送给隧道服务器。隧道代理还会在配置了该功能的情况下，在
    DNS 中注册地址。隧道代理必须能够通过 IPv4 地址访问。它也可以拥有一个 IPv6 地址，但这不是必须的。隧道代理与隧道服务器之间的通信可以通过 IPv4
    或 IPv6 进行。
- en: A Tunnel Server is a dual-stack router connected to the global Internet. When
    it receives configuration information from the Tunnel Broker, it establishes,
    changes, or deletes the server part of the tunnel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道服务器是一个双栈路由器，连接到全球互联网。当它接收到隧道代理的配置信息时，它会建立、变更或删除隧道的服务器部分。
- en: The client is a dual-stack host or router connected to the Internet over IPv4\.
    When it wants to register for an IPv6 connection with the Tunnel Broker, it should
    authenticate with standard procedures (e.g., with RADIUS). This way, unauthorized
    use of the tunnel service can be avoided. So the Tunnel Broker provides access
    control to the tunnel service. Once the client is authorized, it provides its
    IPv4 address, a name for the registration of its IPv6 address in DNS, and an indication
    of whether it is a host or a router. If the client is a router, it should send
    additional information about the number of IPv6 addresses that it wants to be
    served. The Tunnel Broker needs this information in order to assign an appropriate
    prefix to the client.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是一个双栈主机或路由器，通过 IPv4 连接到互联网。当它希望向隧道代理注册 IPv6 连接时，应该使用标准程序（例如，RADIUS）进行身份验证。通过这种方式，可以避免隧道服务的未授权使用。因此，隧道代理提供隧道服务的访问控制。一旦客户端获得授权，它将提供其
    IPv4 地址、一个用于在 DNS 中注册其 IPv6 地址的名称，以及一个指示其是主机还是路由器的信息。如果客户端是路由器，它还应发送关于其希望获取的 IPv6
    地址数量的额外信息。隧道代理需要这些信息以便为客户端分配合适的前缀。
- en: 'The Tunnel Broker fulfills the following tasks:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道代理履行以下任务：
- en: Choosing a Tunnel Server as a tunnel exit point. If it has more than one option,
    it chooses based on preconfigured load-sharing criteria.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择隧道服务器作为隧道出口点。如果有多个选项，它会根据预配置的负载共享标准来选择。
- en: Choosing a prefix for the client. The prefix can be any length. The most common
    values are /48 (site prefix), /64 (subnet prefix), or /128 (single host).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为客户端选择一个前缀。前缀可以是任意长度。最常见的值是/48（站点前缀）、/64（子网前缀）或/128（单一主机）。
- en: Defining a lifetime for the tunnel.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为隧道定义生命周期。
- en: Registering the global IPv6 addresses it has assigned in DNS.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DNS中注册它分配的全局IPv6地址。
- en: Configuring the Tunnel Server.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置隧道服务器。
- en: Sending the configuration information back to the client. This information includes
    the tunnel parameters and DNS names.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置信息发送回客户端。此信息包括隧道参数和DNS名称。
- en: This concludes the tunnel configuration. The clients now have access to all
    IPv6 networks to which the Tunnel Server has access.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了隧道配置。客户端现在可以访问隧道服务器可以访问的所有IPv6网络。
- en: There are a number of ISPs that offer Tunnel Broker services. Often, users can
    register through the browser by filling out a form and receiving the configuration
    information displayed or sent by email. The client can now manually configure
    its tunnel entry point or use script files from the provider that automate the
    configuration process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多互联网服务提供商（ISP）提供隧道代理服务。通常，用户可以通过浏览器注册，填写表单并接收显示或通过电子邮件发送的配置信息。客户端现在可以手动配置其隧道入口点，或者使用提供商的脚本文件自动化配置过程。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are different lists on the Internet to find a suitable Tunnel Broker.
    Two well-known providers are [Hurricane Electrics](http://www.tunnelbroker.net)
    and [SixXS](https://www.sixxs.net). Wikipedia has a list of [Tunnel Brokers](http://en.wikipedia.org/wiki/List_of_IPv6_tunnel_brokers).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上有不同的列表可以找到合适的隧道代理。两个著名的提供商是[Hurricane Electrics](http://www.tunnelbroker.net)和[SixXS](https://www.sixxs.net)。维基百科有一个[隧道代理列表](http://en.wikipedia.org/wiki/List_of_IPv6_tunnel_brokers)。
- en: The Tunnel Broker model is designed for smaller and isolated IPv6 networks and
    especially for single, isolated IPv6 hosts. It works only with public IPv4 addresses.
    If private addresses are used, another mechanism such as Protocol 41 Forwarding
    must be used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道代理模型适用于较小且隔离的IPv6网络，尤其是单个、孤立的IPv6主机。它仅适用于公共IPv4地址。如果使用私有地址，则必须使用其他机制，例如协议41转发。
- en: IPv4/IPv6 coexistence by using VLANs
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过使用VLAN实现IPv4/IPv6共存
- en: VLANs, which are quite common in enterprise networks, can be used to deploy
    IPv6 in a situation where IPv6-capable router and switch equipment is not available
    yet. The VLAN standard allows separate LANs to be deployed over a single bridged
    LAN. It uses virtual LAN tagging or membership information, which is inserted
    into the Ethernet frames. So to introduce IPv6 in such an environment, a parallel
    IPv6 routing infrastructure can be deployed, and the IPv6 links can be overlaid
    onto the IPv4 infrastructure by using VLAN technology. This setup doesn’t require
    any changes to the IPv4 environment. Find a detailed description of this scenario
    and possible configurations in RFC 4554, “Use of VLANs for IPv4-IPv6 Coexistence
    in Enterprise Networks.”
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: VLAN（虚拟局域网）在企业网络中非常常见，可用于在尚未具备IPv6路由器和交换机设备的情况下部署IPv6。VLAN标准允许将多个局域网部署在同一个桥接的局域网中。它使用虚拟局域网标记或成员信息，并将其插入以太网帧中。因此，要在这种环境中引入IPv6，可以部署一个并行的IPv6路由基础设施，并通过VLAN技术将IPv6链路叠加到IPv4基础设施上。此设置不需要对IPv4环境进行任何更改。有关该场景的详细描述和可能的配置，请参阅RFC
    4554《在企业网络中使用VLAN实现IPv4和IPv6共存》。
- en: IPv6 in MPLS networks
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv6在MPLS网络中的应用
- en: MPLS (MultiProtocol Label Switching) technology was introduced originally to
    enhance the forwarding performance of Service Provider network cores. It is basically
    a tunneling mechanism where forwarding is done hop-by-hop based on locally relevant
    labels prepended to the IP packet. This means shorter lookups and easier hardware
    implementation. Since its inception, however, the capabilities of routing platforms
    have dramatically increased with respect to forwarding IP packets at line rate.
    At this point the value of MPLS does not reside as much in forwarding performance
    gains as it does in its ability to segment (MPLS-based VPNs) and organize traffic
    (Traffic Engineering) over a network core. These capabilities also made MPLS attractive
    to large enterprises that deploy their own network backbone.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: MPLS（多协议标签交换）技术最初是为了提升服务提供商网络核心的转发性能。它本质上是一种隧道机制，数据转发是基于附加到IP数据包上的本地相关标签逐跳进行的。这意味着更短的查找时间和更简单的硬件实现。然而，自从MPLS问世以来，路由平台在以线速转发IP数据包方面的能力已经大大增强。此时，MPLS的价值不再仅仅体现在转发性能的提升上，更在于它在网络核心中实现流量的分段（基于MPLS的VPN）和组织（流量工程）的能力。这些能力也使得MPLS对部署自有网络骨干的大型企业具有吸引力。
- en: The operation of MPLS depends on the existence of an IGP that ensures IP routing
    is properly set up in the backbone and a label exchange protocol. The label exchange
    protocol enables the P (Provider) and PE (Provider Edge) routers to define a label
    for each hop a packet would take from one edge of the MPLS core to another. As
    an IP packet enters the MPLS core, it is fitted with a locally relevant label
    that tells the next hop where the packet is going. The next-hop router (or MPLS
    switch as it might sometimes be called) swaps the label with a label relevant
    for the next hop and so on to the destination PE. The P router before the destination
    PE will strip the label and present the PE router with the IP packet that entered
    the MPLS core. The PE router will in turn IP route the packet further toward its
    final destination.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: MPLS的操作依赖于存在一个IGP（内部网关协议），确保IP路由在骨干网中正确设置，并且依赖标签交换协议。标签交换协议使P（提供商）路由器和PE（提供商边缘）路由器能够为每个数据包从MPLS核心的一端到另一端的每个跳点定义一个标签。当IP数据包进入MPLS核心时，它会被赋予一个本地相关的标签，告知下一个跳点数据包的去向。下一个跳点路由器（有时也称为MPLS交换机）会将标签交换为与下一个跳点相关的标签，依此类推，直到目标PE。目标PE前的P路由器将去掉标签，并将进入MPLS核心的IP数据包交给PE路由器。PE路由器则会将数据包进一步进行IP路由，直到其最终目的地。
- en: MPLS is a generic tunneling mechanism. So regardless of the control plane implementation
    (IGP plus label exchange), it can forward IPv6 packets just as easily as it would
    forward IPv4 packets. However, the options for transporting IPv6 over an IPv4
    MPLS core were particularly easy to expand when the MPLS labels are complemented
    with labels specific to particular functionality relevant at the edge of the MPLS
    core. In other words, an additional label that tells the destination PE what type
    of IP packet this is or in what routing context the packet should be placed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: MPLS是一种通用的隧道机制。因此，无论控制平面实现（IGP加标签交换）如何，它都可以像转发IPv4数据包一样轻松转发IPv6数据包。然而，当MPLS标签与特定于MPLS核心边缘功能的标签相结合时，IPv4
    MPLS核心上承载IPv6的选项变得特别容易扩展。换句话说，附加标签可以告知目标PE此数据包是什么类型的IP数据包，或者数据包应放置在哪种路由上下文中。
- en: 'Most MPLS deployments today leverage MP-iBGP (MultiProtocol interior BGP; RFC
    3107) to enhance functionality. Address families relevant to various protocols
    (such as IPv4 and IPv6) and various functionalities (VPNs, multicast, etc.) can
    be defined on the PE routers and the related traffic tagged with specific labels.
    MP-iBGP exchanges these labels between the PE routers, enabling them to recognize
    and properly process the tagged packets. These protocol or functional labels are
    stacked on top of the MPLS labels. Extending this functionality to IPv6 was easy.
    An IPv6 address family had to be identified and functionality similar to IPv4
    (VPN, multicast, etc.) associated to the IPv6 address family. For example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数MPLS部署利用MP-iBGP（多协议内部BGP；RFC 3107）来增强功能。与各种协议（如IPv4和IPv6）以及不同功能（如VPN、组播等）相关的地址族可以在PE路由器上定义，并将相关流量标记上特定标签。MP-iBGP在PE路由器之间交换这些标签，使它们能够识别并正确处理这些标记的数据包。这些协议或功能标签堆叠在MPLS标签之上。将这一功能扩展到IPv6非常容易。必须识别IPv6地址族，并将类似于IPv4的功能（VPN、组播等）与IPv6地址族关联。例如：
- en: Address Family Identifier (AFI) for IPv6 = 2
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6的地址族标识符（AFI）= 2
- en: Subsequent Address Family Identifier for transporting IPv6 traffic over MPLS
    = 4
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在MPLS上传输IPv6流量的后续地址族标识符 = 4
- en: Subsequent Address Family Identifier for transporting VPN IPv6 traffic over
    MPLS = 128
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在MPLS上传输VPN IPv6流量的后续地址族标识符 = 128
- en: 'For these reasons, IPv6 can easily and very effectively be transported over
    existing MPLS backbones. In general, IPv6 transport over an MPLS infrastructure
    can be done in three ways:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，IPv6可以轻松且高效地通过现有的MPLS骨干网传输。一般来说，IPv6通过MPLS基础设施的传输可以通过三种方式完成：
- en: '*IPv6 over IPv6/MPLS core*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6通过IPv6/MPLS核心*'
- en: The MPLS core can be enabled directly for IPv6, meaning it runs IPv6 natively.
    It uses an IPv6 IGP and it exchanges labels for and over IPv6\. In this case,
    IPv6 runs over the IPv6 MPLS core the same way as IPv4 runs over an IPv4 MPLS
    core. IPv4 can be tunneled over this IPv6-based infrastructure as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: MPLS核心可以直接启用IPv6，这意味着它原生支持IPv6。它使用IPv6 IGP，并在IPv6上交换标签。在这种情况下，IPv6通过IPv6 MPLS核心的方式与IPv4通过IPv4
    MPLS核心的方式相同。IPv4也可以通过这种基于IPv6的基础设施进行隧道传输。
- en: '*Layer 2 tunneling over MPLS*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过MPLS进行第二层隧道传输*'
- en: Layer 2 tunnels can be set up across MPLS cores. These tunnels simplify the
    network architecture of the organizations using the MPLS backbone for connectivity.
    They will carry any Layer 3 protocol, including IPv6 between the PE endpoints.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在MPLS核心上建立第二层隧道。这些隧道简化了使用MPLS骨干网进行连接的组织的网络架构。它们将承载任何第3层协议，包括PE端点之间的IPv6。
- en: '*IPv6 over IPv4/MPLS core*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6通过IPv4/MPLS核心*'
- en: This method is based on the distribution of IPv6 prefixes (along with the corresponding
    labels) between the Edge Label Switching routers using MP-iBGP4 over IPv4\. The
    next hop is identified by an IPv4 address and the packet is forwarded over the
    MPLS core based on the labels for the IPv4 address of the target PE router (RFC
    4798). Cisco calls their implementation of this mechanism 6PE (IPv6 Provider Edge
    Router). The same concept is used to enable IPv6 VPNs over an IPv4 MPLS core (RFC
    4659).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基于使用MP-iBGP4通过IPv4在边缘标签交换路由器之间分发IPv6前缀（以及相应的标签）。下一跳由IPv4地址标识，数据包根据目标PE路由器的IPv4地址的标签在MPLS核心上传输（RFC
    4798）。Cisco将其实现该机制的方式称为6PE（IPv6提供商边缘路由器）。相同的概念用于在IPv4 MPLS核心上启用IPv6 VPN（RFC 4659）。
- en: It is important to note that transporting IPv6 over an IPv4 MPLS core is a very
    effective transition mechanism. The changes required consist only of configuration
    adjustments for the PE routers (assuming the functionality is supported). In this
    type of deployment, IPv6 benefits from all the value provided by the MPLS infrastructure,
    from line rate forwarding to traffic engineering.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意的是，通过IPv4 MPLS核心传输IPv6是一种非常有效的过渡机制。所需的变化仅仅是PE路由器的配置调整（假设功能已得到支持）。在这种部署类型中，IPv6可以充分利用MPLS基础设施提供的所有价值，从线路速率转发到流量工程。
- en: 6PE
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6PE
- en: The concept for 6PE is based on the hierarchical routing structure of MPLS shown
    in [Figure 7-16](ch07.html#mpls_routing_hierarchy "Figure 7-16. MPLS routing hierarchy").
    I do not aim to discuss general MPLS technology here; the goal is to show how
    MPLS can support an easy introduction of IPv6.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 6PE的概念基于MPLS的层次路由结构，如[图7-16](ch07.html#mpls_routing_hierarchy "图7-16. MPLS路由层次结构")所示。这里我并不打算讨论一般的MPLS技术，目的是展示MPLS如何支持IPv6的简便引入。
- en: '![MPLS routing hierarchy](images/ipv6_0716.png)Figure 7-16. MPLS routing hierarchy'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![MPLS路由层次结构](images/ipv6_0716.png)图7-16. MPLS路由层次结构'
- en: In the center of the MPLS network are the Provider routers (P). They switch
    the MPLS packets, which means that they do not process the Layer 3 header. At
    the edge of the core network are the Provider Edge routers (PE). They receive
    regular IP packets from the Customer Edge routers (CE), apply an MPLS label, and
    forward them to the Provider routers. MPLS packets are sent only between Provider
    Edge routers and Provider routers in [Figure 7-16](ch07.html#mpls_routing_hierarchy
    "Figure 7-16. MPLS routing hierarchy").
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在MPLS网络的核心是提供商路由器（P）。它们转发MPLS数据包，这意味着它们不会处理第3层的头部。在核心网络的边缘是提供商边缘路由器（PE）。它们从客户边缘路由器（CE）接收常规的IP数据包，应用MPLS标签，并将其转发给提供商路由器。MPLS数据包仅在提供商边缘路由器和提供商路由器之间传输，具体参见[图7-16](ch07.html#mpls_routing_hierarchy
    "图7-16. MPLS路由层次结构")。
- en: 'In this environment, routing works as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在此环境中，路由工作方式如下：
- en: The PE and CE routers use the common routing protocols (RIP, OSPF, BGP, or static
    routing). The PE router learns the prefixes that it can reach through the CE routers
    through these routing protocols.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PE和CE路由器使用常见的路由协议（RIP、OSPF、BGP或静态路由）。PE路由器通过这些路由协议学习它能够通过CE路由器到达的前缀。
- en: Each PE router announces the prefixes learned from its CE routers over MP-iBGP
    to the other PE routers and inserts itself as next hop for these prefixes. If
    a global routing domain is established across the MPLS core for IPv6 (6PE) then
    MP-iBGP will use SAFI 4 when exchanging prefixes. Along with the prefixes, the
    PE advertises labels that should be used on packets sent to those prefixes.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个PE路由器通过MP-iBGP将从其CE路由器学到的前缀通告给其他PE路由器，并将其自己作为这些前缀的下一跳。如果在MPLS核心中为IPv6（6PE）建立了全局路由域，那么MP-iBGP将使用SAFI
    4来交换前缀。与前缀一起，PE还会通告应该在发送到这些前缀的数据包上使用的标签。
- en: The MPLS core uses an IGP, typically IS-IS or OSPF, to establish reachability
    between the PEs. In conjunction with the label exchange protocol, Label Switched
    Paths (LSPs) can be set up between PEs.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MPLS核心使用IGP，通常是IS-IS或OSPF，来建立PE之间的可达性。结合标签交换协议，PE之间可以建立标签交换路径（LSP）。
- en: 'Forwarding of IPv6 traffic works as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6流量的转发过程如下：
- en: An LSP (Label Switched Path; think the equivalent of a tunnel) already exists
    between the ingress and egress PEs, established by the IPv4-based control plane
    in the MPLS core.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在入口和出口PE之间已经存在一个LSP（标签交换路径；可以理解为隧道），该路径由MPLS核心中的基于IPv4的控制平面建立。
- en: MP-iBGP already informed the ingress PE (PE1) who the next-hop PE is (PE4 identified
    by its IPv4 address) and about the label that should be used for the IPv6 destination
    prefix.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MP-iBGP已经通知了入口PE（PE1）下一个跳的PE是哪个（通过IPv4地址标识的PE4），并且告诉它应该使用哪个标签来标记IPv6目标前缀。
- en: The label for the destination address prefix (CE3) is first appended by PE1
    to the incoming IPv6 traffic received from CE1\. The ingress PE1 also appends
    in front of that the label for the IPv4 address of the egress PE4 and sends the
    packet to the next hop P router.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标地址前缀（CE3）的标签首先由PE1附加到从CE1接收到的进入IPv6流量上。入口PE1还会在前面附加出口PE4的IPv4地址的标签，并将数据包发送到下一跳P路由器。
- en: The P1 router swaps the top label (the one relevant for the egress PE4 IPv4
    address) and forwards the packet to the next P router.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P1路由器交换掉顶部标签（即与出口PE4的IPv4地址相关的标签），并将数据包转发到下一个P路由器。
- en: The process continues hop by hop until the packet reaches the P router connected
    to the egress router. The P router eliminates the top label and forwards the packet
    to the PE router.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该过程会继续进行，直到数据包到达与出口路由器相连的P路由器。P路由器移除顶部标签，并将数据包转发到PE路由器。
- en: The egress PE4 receives the packet with only one label; however, based on that
    label it will know what to do with it. If this is a 6PE deployment, it will drop
    the label and hand the IPv6 packet to the global IPv6 forwarding process
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出口PE4接收到的数据包只有一个标签；然而，基于该标签，它将知道该如何处理这个数据包。如果这是一个6PE部署，它会丢弃该标签，并将IPv6数据包交给全局IPv6转发过程。
- en: The IPv6 packet is then natively forwarded to CE3 and further on to the destination.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，IPv6数据包会被原生转发到CE3，再继续转发到目标。
- en: If you are familiar with the concept of MPLS-VPNs, you can think of 6PE as one
    global VPN dedicated to transporting IPv6 between all PEs where it is enabled.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉MPLS-VPN的概念，可以将6PE视为一个全球性的VPN，专门用于在所有启用了IPv6的PE之间传输IPv6。
- en: 6VPE
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6VPE
- en: Once we understand how 6PE works, and we are comfortable with MPLS-VPNs, then
    6VPE will seem to be a very natural extension. For those who are not familiar
    with MPLS-VPN, the key concept to know is that of a Virtual Routing and Forwarding
    (VRF) instance. Across the MPLS backbone, if we define domains that should not
    share or see each other’s traffic, we define Virtual Private Networks (VPNs).
    The PE routers must maintain that separation so the traffic for each VPN instantiated
    on a PE is routed and forwarded using dedicated tables that are maintained within
    a respective VRF (Virtual Routing and Forwarding).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了6PE的工作原理，并且熟悉MPLS-VPN，那么6VPE将显得是一个非常自然的扩展。对于那些不熟悉MPLS-VPN的人，关键概念是虚拟路由与转发（VRF）实例。在MPLS骨干网中，如果我们定义了不应该共享或看到彼此流量的域，我们就定义了虚拟私人网络（VPN）。PE路由器必须维持这种分离，以便每个VPN流量在PE上被路由和转发时使用的是专门的表，这些表由各自的VRF（虚拟路由与转发）维护。
- en: In the case of 6VPE, we create MPLS-VPNs specifically for IPv6 or we dual-stack
    the existing VPNs. The control plane is very similar to 6PE. The MP-iBGP will
    exchange labels (using SAFI 128) that now not only are related to an IPv6 prefix
    but that are also related to the VRF to which that IPv6 prefix belongs. At the
    PEs, IPv6 interfaces are bound to a VRF and so the IPv6 traffic is maintained
    within the defined VPN. Forwarding is also similar to 6PE, the IPv6 packets are
    fitted with a top-level label (exchanged via the label exchange protocol) used
    for switching within the MPLS core and a second label (exchanged via MP-iBGP)
    used to indicate to the receiving PE in which VRF the IPv6 packet should go.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在6VPE的情况下，我们为IPv6专门创建MPLS-VPN，或者对现有的VPN进行双栈配置。控制平面与6PE非常相似。MP-iBGP将交换标签（使用SAFI
    128），这些标签不仅与IPv6前缀相关，还与该IPv6前缀所属的VRF相关。在PE设备上，IPv6接口与VRF绑定，因此IPv6流量被保持在定义的VPN内。转发方式也类似于6PE，IPv6数据包会被添加一个顶级标签（通过标签交换协议交换），用于在MPLS核心内部进行切换，以及第二个标签（通过MP-iBGP交换），用来指示接收PE数据包应当进入哪个VRF。
- en: 'Referring to [Figure 7-12](ch07.html#the_format_of_the_isatap_address "Figure 7-12. The
    format of the ISATAP address"), unlike the 6PE scenario where all CEs are part
    of the same global routing domain, CE1 and CE3 belong to the red VRF while CE2
    belongs to blue VRF. PE1 will maintain separate routing and forwarding instances
    for CE1 and CE2\. Moreover, PE1 exchanges labels for the IPv6 prefixes belonging
    to each VRF. Forwarding is similar to 6PE:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[图7-12](ch07.html#the_format_of_the_isatap_address "图7-12. ISATAP地址格式")，与6PE场景中所有CE都属于同一全局路由域的情况不同，CE1和CE3属于红色VRF，而CE2属于蓝色VRF。PE1将为CE1和CE2分别维护独立的路由和转发实例。此外，PE1会为每个VRF中的IPv6前缀交换标签。转发方式类似于6PE：
- en: When CE1 sends a packet toward CE3, the packet enters PE1 through an interface
    associated to the red VRF.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当CE1将数据包发送到CE3时，数据包通过与红色VRF关联的接口进入PE1。
- en: The packet is fitted with the label for the CE3 destination IPv6 prefix (also
    in the red VRF) and with the label for MPLS forwarding.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包被添加了用于CE3目标IPv6前缀的标签（也位于红色VRF中），并且附加了用于MPLS转发的标签。
- en: PE1 sends the labeled packet to P1, and P1 swaps the top label and then forwards
    it to P2.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PE1将带标签的数据包发送给P1，P1交换顶层标签，然后将数据包转发给P2。
- en: P2 pops the top label and sends the packet to PE4.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P2去掉顶层标签并将数据包发送给PE4。
- en: PE4 receives a labeled packet and, based on it, PE4 knows what VRF this packet
    belongs to and even where to send it within that VRF.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PE4接收带标签的数据包，并根据标签，PE4知道该数据包属于哪个VRF，甚至知道该将数据包发送到VRF中的哪个位置。
- en: PE4 strips the last label and lets the typical IP routing and forwarding functions
    within the red VRF to take it to CE3.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PE4去掉最后的标签，让典型的IP路由和转发功能在红色VRF内执行，将数据包传送至CE3。
- en: The use of 6PE or 6VPE depends on the service that is supported by the IPv6
    traffic. If you simply want to offer IPv6 access to the Internet for all CEs,
    then 6PE will be a quick and easy solution. If you have multiple customers or
    organizations on your MPLS backbone who are separated in distinct VPNs, then 6VPE
    is the right solution for IPv6 enablement of these VPNs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用6PE或6VPE取决于IPv6流量支持的服务。如果你只是想为所有CE提供访问互联网的IPv6连接，那么6PE将是一个快速而简便的解决方案。如果你在MPLS骨干网络上有多个客户或组织，并且它们被分隔在不同的VPN中，那么6VPE是IPv6使能这些VPN的正确解决方案。
- en: The fact that MPLS can be used to transport IPv6 packets over IPv4 does not
    mean that you should implement MPLS for this purpose. If you do not have an MPLS
    infrastructure in place, other tunneling mechanisms may be better suited to reach
    your goal. But if you already have MPLS, it is a great foundation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: MPLS可以用于通过IPv4传输IPv6数据包并不意味着你应该为此目的实现MPLS。如果你没有现成的MPLS基础设施，其他隧道机制可能更适合实现你的目标。但如果你已经拥有MPLS，那么它是一个很好的基础。
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to delve deeper into this, refer to the book *Deploying IPv6
    Networks* by Ciprian Popoviciu, Patrick Grossetete, and Eric Levy-Abegnoli (Cisco
    Press). It is a practical guide to IPv6 concepts, service implementations, and
    interoperability with IPv4.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解这一点，可以参考Ciprian Popoviciu、Patrick Grossetete和Eric Levy-Abegnoli（Cisco
    Press）合著的《*部署IPv6网络*》一书。它是一本关于IPv6概念、服务实现及与IPv4互操作性的实用指南。
- en: Locator ID Separation Protocol (LISP)
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定位符ID分离协议（LISP）
- en: LISP (Locator ID Separation Protocol) is a new and innovative architecture,
    which was not purely designed to support IPv6\. However, the ability to register
    IPv6 addresses and use IPv4 as a transport makes LISP a very useful tool for IPv6
    transport over IPv4, connecting IPv6 islands or attaching IPv6 network elements
    directly to the IPv6 Internet.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: LISP（定位符标识符分离协议）是一种新颖的架构，虽然它并非完全为了支持IPv6而设计，但它具备了注册IPv6地址并使用IPv4作为传输工具的能力，使得LISP成为IPv4上运输IPv6、连接IPv6岛屿或将IPv6网络元素直接连接到IPv6互联网的非常有用的工具。
- en: 'Many challenges with the current addressing structure of IP come from the fact
    that an IP address (IPv4 and IPv6) contains two different types of information.
    One is about the location of a device (in the subnet information, prefix) and
    the other about the identity of a device (host ID and interface ID, respectively).
    Every time you boot your notebook, you may get a different IP address; the prefix
    changes depending on which network you are in, and the host ID may change also
    (depending on the configuration). LISP enables this “level of indirection,” by
    separating the IP addresses into two namespaces: *Endpoint Identifiers* (EID)
    and *Routing Locators* (RLOCs), which are assigned to a router, called *Tunnel
    Router*.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当前IP地址结构的许多挑战源于这样一个事实：一个IP地址（IPv4和IPv6）包含了两种不同类型的信息。一种是关于设备位置的信息（在子网信息中，前缀部分），另一种是关于设备身份的信息（主机ID和接口ID）。每次启动笔记本时，你可能会得到不同的IP地址；前缀会根据你所在的网络而变化，主机ID也可能会发生变化（取决于配置）。LISP通过将IP地址分为两个命名空间来实现这种“间接性”——*端点标识符*（EID）和*路由定位符*（RLOCs），这些标识符被分配给路由器，称为*隧道路由器*。
- en: 'LISP creates an overlay network with the following benefits:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: LISP创建了一个覆盖网络，带来了以下好处：
- en: Multihoming with ingress traffic engineering
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多宿主与入口流量工程
- en: Address family independence (IPv4 and IPv6; MAC address registration on roadmap)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址族独立性（IPv4和IPv6；MAC地址注册在规划中）
- en: High-scale virtualization and multitenancy support
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高规模虚拟化和多租户支持
- en: Datacenter mobility including session persistence with mobility events
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据中心的移动性，包括在移动事件中的会话持久性
- en: LISP is an IETF standard defined in the RFCs 6830 to 6836 and RFC 7052\. There
    is still ongoing work on LISP, which is documented in various drafts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: LISP是一个由IETF定义的标准，规定在RFC 6830至6836以及RFC 7052中。LISP仍在持续开发中，相关文档已记录在多个草案中。
- en: '[Figure 7-17](ch07.html#lisp_architectural_network_elements "Figure 7-17. LISP
    architectural network elements") shows the basic architectural elements of LISP.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-17](ch07.html#lisp_architectural_network_elements "图7-17. LISP架构网络元素")展示了LISP的基本架构元素。'
- en: The EID (Endpoint Identifier) space is the hosts/servers identifier’s IP address
    space. It could be IPv4 or IPv6\. There are no special changes for the hosts/servers
    or the branch, campus, or datacenter network. The EID is the identity of the host.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: EID（端点标识符）空间是主机/服务器标识符的IP地址空间。它可以是IPv4或IPv6。对于主机/服务器，或者分支、校园或数据中心网络，没有特殊的变化。EID是主机的身份标识。
- en: The RLOC (Routing Locator) space is the transport’s IP address space (identifying
    the location). It could be IPv4 or IPv6\. There are no special changes for the
    transport network, which could be the Internet, a Service Provider, or a private
    WAN.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: RLOC（路由定位符）空间是传输的IP地址空间（标识位置）。它可以是IPv4或IPv6。传输网络没有特殊变化，可以是互联网、服务提供商网络或私有WAN。
- en: 'As LISP is a pure network-based solution, the only box that is aware of LISP
    is the Tunnel Router (xTR), which comes in two flavors: ingress Tunnel Router
    (iTR) and egress Tunnel Router (eTR). The iTR gets an IP packet from the branch,
    campus, or datacenter and encapsulates the original packet into an IPv4/IPv6 UDP
    packet with either two destination ports (UDP 4341 for data and UDP 4342 for control).
    The source and destination of this encapsulated packet is defined by the RLOC
    (transport IP address of the xTRs) of the iTR and the eTR. The eTR will receive
    an encapsulated packet and will do the decapsulation. The basic configs for the
    xTR is minimal and LISP is very lightweight to the control plane (LISP is data
    driven and follows a pull model).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于LISP是一个纯网络基础的解决方案，唯一了解LISP的设备是隧道路由器（xTR），它有两种类型：入口隧道路由器（iTR）和出口隧道路由器（eTR）。iTR从分支、校园或数据中心接收一个IP数据包，并将原始数据包封装成一个IPv4/IPv6
    UDP数据包，其中包含两个目标端口（UDP 4341用于数据，UDP 4342用于控制）。这个封装数据包的源地址和目标地址由iTR和eTR的RLOC（xTR的传输IP地址）定义。eTR会接收到封装的数据包并进行解封装。xTR的基本配置是最小的，LISP对控制平面的负担非常轻（LISP是数据驱动的，并遵循拉取模型）。
- en: '![LISP architectural network elements](images/ipv6_0717.png.jpg)Figure 7-17. LISP
    architectural network elements'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![LISP架构网络元素](images/ipv6_0717.png.jpg)图7-17. LISP架构网络元素'
- en: 'The *Mapping Database* consists of two functions: the *Map Resolver* (MR) and
    the *Map Server* (MS). The eTR will register the EIDs (either IPv4 or IPv6) with
    its RLOC addresses (either IPv4 or IPv6) to the Map Server (map-register message).
    The iTR will ask the MR, in case of any EID traffic, which destination RLOC to
    use for the destination EID (map-request message). The MR forwards the map-request
    to the MS and the MS checks its database and forwards the map-request to the eTR,
    which will then do a more advanced answer (map-reply message) to the iTR. The
    MR/MS can be configured on an xTR or can be a standalone router or server (like
    a BGP route-reflector). The mapping database is very scalable and can be compared
    with DNS for scalability and performance.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*映射数据库*由两个功能组成：*映射解析器*（MR）和*映射服务器*（MS）。eTR将通过map-register消息，将EID（可以是IPv4或IPv6）和其RLOC地址（可以是IPv4或IPv6）注册到映射服务器。iTR在处理任何EID流量时会询问MR，哪个目的地RLOC应当用于目标EID（map-request消息）。MR将map-request转发给MS，MS检查其数据库并将map-request转发给eTR，后者将向iTR提供更为详细的回答（map-reply消息）。MR/MS可以配置在xTR上，也可以是独立的路由器或服务器（例如BGP路由反射器）。映射数据库具有很高的可扩展性，可以与DNS在可扩展性和性能方面进行比较。'
- en: To make LISP incrementally deployable there is a special xTR called *Proxy Tunnel
    Router* (PxTR). The Proxy ingress Tunnel Router (PiTR) announces the EID space
    into the Internet or non-LISP WAN and campus, and the Proxy egress Tunnel Router
    (PeTR) is used to send encapsulated traffic to the non-LISP world. The trigger
    to use the PeTR is a negative map-reply message from the MR.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使LISP能够逐步部署，存在一种特殊的xTR，称为*代理隧道路由器*（PxTR）。代理入口隧道路由器（PiTR）将EID空间宣布到互联网或非LISP的WAN和校园网络中，而代理出口隧道路由器（PeTR）则用于将封装流量发送到非LISP世界。使用PeTR的触发条件是来自MR的负map-reply消息。
- en: 'Many advantages come with LISP:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: LISP带来了许多优势：
- en: Optimizes routing from push to pull
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由优化从推送转换为拉取
- en: Works as an overlay technology
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种覆盖技术工作
- en: Uses stateless UDP encapsulation for optimized transport
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无状态UDP封装进行优化传输
- en: Calculates the source UDP LISP port from the original IP packet and helps with
    ECMP (Equal Cost Multiple Path) load balancing in the RLOC space
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算源UDP LISP端口来自原始IP数据包，并帮助实现RLOC空间中的ECMP（等成本多路径）负载均衡
- en: Makes deployment very easy as it only touches the network equipment at the edge
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得部署变得非常简便，因为它只涉及网络边缘的设备
- en: These advantages come in addition to the use cases for multihoming with real
    load balancing in the ingress. It supports virtualization for VRF transport and
    unique mobility features.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势除了在入口处进行真实负载均衡的多宿主使用场景外，还支持VRF传输的虚拟化和独特的移动性特性。
- en: But the most important part in this context is the capability to use IPv4 as
    a transport for IPv6\. LISP can be used to connect IPv6 islands over an IPv4 network
    or deliver a scalable and lightweight solution to connect to the IPv6 Internet.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但在此背景下，最重要的部分是能够使用IPv4作为IPv6的传输。LISP可以用来通过IPv4网络连接IPv6岛屿，或提供一种可扩展且轻量的解决方案来连接IPv6互联网。
- en: '[Figure 7-18](ch07.html#lisp_ipv6_over_ipv4 "Figure 7-18. LISP IPv6 over IPv4")
    shows the concept for transport of IPv6 over IPv4.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-18](ch07.html#lisp_ipv6_over_ipv4 "图7-18. LISP IPv6通过IPv4传输")展示了IPv6通过IPv4传输的概念。'
- en: '![LISP IPv6 over IPv4](images/ipv6_0718.png.jpg)Figure 7-18. LISP IPv6 over
    IPv4'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![LISP IPv6通过IPv4](images/ipv6_0718.png.jpg)图7-18. LISP IPv6通过IPv4'
- en: The LISP router on the left will do a map-register with the LISP mapping-database
    (not shown here). It will register the IPv6 address (IPv6 EID) of the IPv6 service
    with the IPv4 RLOC (Internet IP address) of the LISP router.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的LISP路由器将向LISP映射数据库（此处未显示）发送map-register。它将使用LISP路由器的IPv4 RLOC（互联网IP地址）注册IPv6服务的IPv6地址（IPv6
    EID）。
- en: The Proxy Tunnel Router (PxTR; LISP router on the right) is connected to the
    IPv4 and IPv6 Internet. The PiTR will announce the IPv6 EID to the IPv6 Internet
    to attract the traffic for the IPv6 service. When a packet for the IPv6 service
    arrives on the PiTR it will do a map-request for the IPv6 EID. The LISP router
    on the left (eTR) will get the map-request from the MR/MS and will answer with
    its IPv4 RLOC. The PiTR will now create a map-cache with the IPv6 EID and the
    next-hop IPv4 RLOC. Now the packet from the IPv6 Internet will be encapsulated
    in IPv4 and forwarded over the IPv4 Internet. The eTR will then decapsulate the
    packet and deliver this natively as an IPv6 packet to the IPv6 service.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 代理隧道路由器（PxTR；右侧的 LISP 路由器）连接到 IPv4 和 IPv6 Internet。PiTR 会将 IPv6 EID 宣布到 IPv6
    Internet，以吸引 IPv6 服务的流量。当 IPv6 服务的数据包到达 PiTR 时，它会为该 IPv6 EID 发出映射请求。左侧的 LISP 路由器（eTR）会从
    MR/MS 接收到映射请求，并会返回其 IPv4 RLOC。PiTR 现在会创建一个包含 IPv6 EID 和下一跳 IPv4 RLOC 的映射缓存。现在，从
    IPv6 Internet 来的包会被封装为 IPv4，并通过 IPv4 Internet 转发。eTR 然后会解封装该数据包，并将其作为原生 IPv6 数据包传递给
    IPv6 服务。
- en: The return traffic from the IPv6 EID to the IPv6 Internet works similarly. The
    iTR gets the IPv6 packet and depending on the configuration, it will issue a map-request
    or it will send the packet directly to the PeTR (static map-cache). In case of
    a map-request, a negative map-reply message will be received from the MR including
    the PeTR IPv4 RLOC. The iTR can now encapsulate the IPv6 packet into IPv4 with
    its source IPv4 RLOC and the IPv4 RLOC of the PeTR. The PeTR gets the encapsulated
    LISP packet, strips off the IPv4 transport header and forwards the IPv6 packet
    natively.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从 IPv6 EID 返回到 IPv6 Internet 的流量处理方式类似。iTR 获取 IPv6 数据包，根据配置，它会发出映射请求，或者直接将数据包发送到
    PeTR（静态映射缓存）。如果是映射请求，它会从 MR 接收到带有 PeTR IPv4 RLOC 的负面映射回复消息。iTR 现在可以使用其源 IPv4 RLOC
    和 PeTR 的 IPv4 RLOC 将 IPv6 数据包封装为 IPv4 数据包。PeTR 获取封装的 LISP 数据包，剥去 IPv4 传输头部，并原生地转发
    IPv6 数据包。
- en: 'These examples show the ease of LISP IPv6 over IPv4 transport. You can use
    the LISP control-plane or you can configure it statically as a direct map cache.
    So if you want to enable IPv6 over IPv4 with LISP, all it takes is: switch on
    LISP for xTR, configure your control-plane info (MR and MS), and define the IPv6
    prefix that is to be transported over IPv4\. Additionally, you can add a static
    map-entry to the iTR.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了 LISP 在 IPv4 传输上实现 IPv6 的简便性。你可以使用 LISP 控制平面，或者将其配置为静态映射缓存。因此，如果你想通过
    LISP 启用 IPv6 over IPv4，只需执行以下步骤：为 xTR 打开 LISP，配置你的控制平面信息（MR 和 MS），并定义需要通过 IPv4
    传输的 IPv6 前缀。此外，你还可以向 iTR 添加静态映射条目。
- en: LISP is available on all Cisco routers, on Catalyst 6500/6800, and Nexus7000\.
    The German CPE vendor AVM implemented LISP for IPv6 transport in their Fritz!Box,
    and there are a couple of open source versions (OpenLISP or LISPmob). There are
    also plans from other vendors to adopt LISP soon.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: LISP 可在所有 Cisco 路由器上使用，包括 Catalyst 6500/6800 和 Nexus7000。德国 CPE 厂商 AVM 在其 Fritz!Box
    中实现了 LISP 用于 IPv6 传输，此外，还有一些开源版本（OpenLISP 或 LISPmob）。其他厂商也计划很快采用 LISP。
- en: The solution from [Figure 7-18](ch07.html#lisp_ipv6_over_ipv4 "Figure 7-18. LISP
    IPv6 over IPv4") can be combined with other LISP use cases to create a real network
    architecture, such as adding virtualization for transporting different VRFs or
    increasing availability and load balancing with multihoming.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-18](ch07.html#lisp_ipv6_over_ipv4 "Figure 7-18. LISP IPv6 over IPv4")
    中的解决方案可以与其他 LISP 使用案例结合，创建一个实际的网络架构，例如为传输不同 VRF 添加虚拟化，或者通过多宿主提高可用性和负载均衡。'
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For further information on LISP, check out [http://www.lisp4.net](http://www.lisp4.net)
    or [http://www.lisp6.net](http://www.lisp6.net) (this link only works if your
    IPv6 connection works).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于 LISP 的信息，请访问 [http://www.lisp4.net](http://www.lisp4.net) 或 [http://www.lisp6.net](http://www.lisp6.net)（此链接仅在您的
    IPv6 连接正常时有效）。
- en: The LISP workgroup can be found at [http://www.tools.ietf.org/wg/lisp](http://www.tools.ietf.org/wg/lisp).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: LISP 工作组可以在 [http://www.tools.ietf.org/wg/lisp](http://www.tools.ietf.org/wg/lisp)
    查找。
- en: Generic Routing Encapsulation
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用路由封装
- en: Another Tunneling mechanism that can be used is Generic Routing Encapsulation
    (GRE). GRE is specified in RFC 2784 and is designed to encapsulate any protocol
    in another protocol. The protocol being encapsulated—in our case IPv6—is called
    the Passenger Protocol. The protocol that is used to encapsulate—in our case IPv4—is
    called the Carrier Protocol.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可用的隧道机制是通用路由封装（GRE）。GRE 在 RFC 2784 中进行了规范，旨在将任何协议封装在另一个协议中。被封装的协议——在我们的例子中是
    IPv6——被称为乘客协议。用于封装的协议——在我们的例子中是 IPv4——被称为承载协议。
- en: The configuration of a GRE tunnel is manual. On both tunnel endpoints (the GRE
    routers), the IPv4 address of the tunnel peer is preconfigured. So for each route
    where IPv6 has to be tunneled, a tunnel must be configured separately. In a more
    complex network, this can lead to a high initial configuration effort. A GRE tunnel
    cannot traverse NATs. It is useful when multiple protocols have to be tunneled
    through the same tunnel.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: GRE 隧道的配置是手动的。在两个隧道端点（GRE 路由器）上，隧道对端的 IPv4 地址是预配置的。因此，对于每条需要隧道传输 IPv6 的路由，必须单独配置一个隧道。在更复杂的网络中，这可能会导致较高的初始配置工作量。GRE
    隧道不能穿越 NAT。它在需要通过同一隧道传输多种协议时非常有用。
- en: Softwire Hub and Spoke Deployment Framework
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 软件隧道集线器与辐射部署框架
- en: This framework uses Layer 2 Tunneling Protocol version 2 (L2TPv2) and is basically
    L2TP tunneling. This works well in ISPs which have PPP deployed. In the “Hub and
    Spoke” solution space, a softwire is established to provide the home network with
    IPv4 connectivity across an IPv6-only access network, or IPv6 connectivity across
    an IPv4-only access network. A softwire is a tunnel that is created on the basis
    of a control protocol setup between softwire endpoints with a shared point-to-point
    or multipoint-to-point state.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架使用第二层隧道协议版本 2（L2TPv2），本质上是 L2TP 隧道技术。这在已经部署 PPP 的 ISP 中效果良好。在“集线器与辐射”解决方案中，建立了一个软件隧道，通过仅支持
    IPv6 的接入网络为家庭网络提供 IPv4 连接，或者通过仅支持 IPv4 的接入网络提供 IPv6 连接。软件隧道是在软件隧道端点之间通过控制协议设置建立的隧道，这些端点具有共享的点对点或多点到点状态。
- en: Just like any tunnel mechanism, it can be used until the rest of the infrastructure
    can be updated to support native IPv6\. It has been deployed by many ISPs, as
    it allows them to use a lot of their existing infrastructure. It is defined in
    RFC 5571.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何隧道机制一样，它可以一直使用，直到其他基础设施能够更新以支持原生 IPv6。许多 ISP 已经部署了它，因为它允许他们利用大量现有的基础设施。它在
    RFC 5571 中有所定义。
- en: Proto 41 forwarding
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协议 41 转发
- en: Some NAT implementations allow the configuration of IPv6 tunnels from inside
    of the private LAN to routers or tunnel servers in the Internet. This is a simple
    and helpful way to provide IPv6 nodes and IPv6 networks behind a NAT with access
    to the IPv6 Internet. This should only be used if no other mechanisms such as
    6to4 or native IPv6 are possible.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 NAT 实现允许从私有局域网内部配置 IPv6 隧道到互联网中的路由器或隧道服务器。这是一种简单且有帮助的方式，可以为位于 NAT 后的 IPv6
    节点和 IPv6 网络提供访问 IPv6 互联网的能力。只有在无法使用其他机制（如 6to4 或原生 IPv6）时，才应使用此方法。
- en: A tunnel client (host or router) with a private IPv4 address and a connection
    to the Internet through an IPv4-only NAT box can use a Tunnel Broker or an IPv6
    router to create an IPv6 tunnel. Many NAT boxes can be configured to forward packets
    based on the protocol value of 41 (for IPv6) in the IPv4 header. This provides
    an opportunity to rapidly deploy a huge number of IPv6 nodes and networks.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 具有私有 IPv4 地址并通过仅支持 IPv4 的 NAT 设备连接到互联网的隧道客户端（主机或路由器）可以使用隧道代理或 IPv6 路由器创建 IPv6
    隧道。许多 NAT 设备可以配置为根据 IPv4 头部中的协议值 41（用于 IPv6）转发数据包。这为快速部署大量 IPv6 节点和网络提供了机会。
- en: Most of the existing solutions for the transition to IPv6 rely on tunnels, assuming
    that the client endpoint is an IPv6-capable router. However, nowadays the installed
    base of IPv4-only NAT boxes/routers is still quite large, while most of the client
    operating systems already support IPv6.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数过渡到 IPv6 的解决方案依赖于隧道，假设客户端端点是支持 IPv6 的路由器。然而，现在仅支持 IPv4 的 NAT 设备/路由器的安装基础仍然相当庞大，而大多数客户端操作系统已经支持
    IPv6。
- en: SSH (Secure Shell) Tunnels
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SSH（安全外壳）隧道
- en: You won’t find SSH Tunnels as an official IPv6 transition mechanism, but they
    can be very practical and offer useful solutions in different situations. This
    section describes what they are and how you can use them in an IPv6 environment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会发现 SSH 隧道作为官方的 IPv6 过渡机制，但它们在不同情况下非常实用，并能提供有效的解决方案。本节将描述它们是什么，以及如何在 IPv6
    环境中使用它们。
- en: The aim of two projects, the [commercial OpenSSH](http://www.openssh.com) and
    the [closed source SSH](http://www.ssh.com), was to eliminate the use of unencrypted
    protocols such as Telnet, rlogin, and rsh. This section is by no means a complete
    overview of SSH, but it shows how SSH tunnels can be used as a simple transition
    mechanism for IPv4 to IPv6 and vice versa.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 两个项目的目标，[商业版 OpenSSH](http://www.openssh.com) 和 [闭源版 SSH](http://www.ssh.com)，是为了消除使用
    Telnet、rlogin 和 rsh 等未加密协议。 本节并不是 SSH 的完整概述，而是展示了如何将 SSH 隧道作为 IPv4 到 IPv6 及其反向过渡的简易机制。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more precise look at SSH, we recommend *SSH—The Secure Shell, The Definitive
    Guide*, Second Edition, written by Daniel J. Barrett et al. (O’Reilly).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想要更深入了解SSH，我们推荐阅读*《SSH——安全外壳，权威指南》，第二版*，由Daniel J. Barrett等人编写（O'Reilly出版）。
- en: Both projects allow for a practice called *port forwarding*, which essentially
    allows TCP ports to be forwarded between machines. It is also loosely referred
    to as the Poor Man’s VPN. In the scenario shown in [Figure 7-19](ch07.html#ipv4_client_connects_to_ipv6-only_server
    "Figure 7-19. IPv4 client connects to IPv6-only server through a dual-stacked
    SSH host"), we have an IPv4-only client connecting to a dual-stacked host running
    either version of SSH (both versions of SSH are IPv6 compliant).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个项目都支持一种叫做*端口转发*的实践，它本质上允许在机器之间转发TCP端口。它也被称为穷人的VPN。在[图7-19](ch07.html#ipv4_client_connects_to_ipv6-only_server
    "图7-19。IPv4客户端通过双栈SSH主机连接到仅支持IPv6的服务器")所示的场景中，我们有一个仅支持IPv4的客户端连接到运行双栈主机的SSH版本（这两个版本的SSH都支持IPv6）。
- en: '![IPv4 client connects to IPv6-only server through a dual-stacked SSH host](images/ipv6_0719.png)Figure 7-19. IPv4
    client connects to IPv6-only server through a dual-stacked SSH host'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![IPv4客户端通过双栈SSH主机连接到仅支持IPv6的服务器](images/ipv6_0719.png)图7-19。IPv4客户端通过双栈SSH主机连接到仅支持IPv6的服务器'
- en: The IPv4 client wishes to send mail via the IPv6-only server. With SSH’s flexibility,
    this can be accomplished one of two ways, described next. The examples that follow
    show how to do this using the command-line SSH client available from both vendors,
    but this can also be easily accomplished with GUI tools (please check your vendor’s
    documentation for your GUI tool).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4客户端希望通过仅支持IPv6的服务器发送邮件。通过SSH的灵活性，可以通过两种方式实现这一目标，接下来将进行描述。以下示例展示了如何使用两个厂商提供的命令行SSH客户端来实现这一点，但也可以使用GUI工具轻松实现（请查阅您厂商的文档了解GUI工具的使用）。
- en: '*Port forwarding TCP port 25 back to the client*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*将TCP端口25转发回客户端*'
- en: 'Typing the following command on the SSH server allows a single IPv4 client
    to access the IPv6 mail server: `ssh -L 25:[2001:db8::11]:25 [user@192.168.1](mailto:user@192.168.1).101`.
    After typing in a password, this command will forward TCP port 25 from the IPv6
    server back to the IPv4-only client. On the client side, a simple `telnet 127.0.0.1
    25` shows that the data is actually initiated on the local host, then forwarded
    to the IPv6-only SMTP server via the SSH server. It may sound a bit complex, but
    it works very well.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSH服务器上输入以下命令允许单一IPv4客户端访问IPv6邮件服务器：`ssh -L 25:[2001:db8::11]:25 [user@192.168.1](mailto:user@192.168.1).101`。输入密码后，该命令将从IPv6服务器将TCP端口25转发回仅支持IPv4的客户端。在客户端，输入简单的`telnet
    127.0.0.1 25`命令可以看到数据实际上是在本地主机上发起的，然后通过SSH服务器转发到仅支持IPv6的SMTP服务器。这可能听起来有点复杂，但它运行得非常好。
- en: '*Port forwarding TCP port 25 to the SSH server and allowing clients to connect
    to port 25 on the SSH server*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*将TCP端口25转发到SSH服务器并允许客户端连接到SSH服务器上的端口25*'
- en: 'This method, while a bit more complex on the initial setup, can ease administration
    issues; the connection only has to be initiated once, and then each client can
    connect to the SSH server. The following commands are typed on the SSH server:
    `ssh -g -L 25:[2001:db8::11]:25 [user@127.0.0](mailto:user@127.0.0).1`. After
    typing this on the server and logging in, you should be able to type `telnet 127.0.0.1
    25` and get the SMTP prompt from the IPv6-only SMTP server. The difference here
    is the `-g` in the SSH command, which allows Gateway mode. In Gateway mode, clients
    other than localhost can connect to that port. Typing the command `telnet 192.168.1.101
    25` at the IPv4-only workstation allows that client to connect to the IPv4 side
    of the dual-stacked SSH server, which relays the data to the IPv6-only SMTP server.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法在初始设置时稍显复杂，但可以简化管理问题；连接只需要初始化一次，然后每个客户端都可以连接到SSH服务器。以下命令需要在SSH服务器上输入：`ssh
    -g -L 25:[2001:db8::11]:25 [user@127.0.0](mailto:user@127.0.0).1`。在服务器上输入并登录后，你应该能够输入`telnet
    127.0.0.1 25`并得到IPv6-only SMTP服务器的SMTP提示符。这里的区别在于SSH命令中的`-g`选项，它允许启用网关模式。在网关模式下，除本地主机外的客户端也可以连接到该端口。在IPv4-only工作站上输入命令`telnet
    192.168.1.101 25`，允许该客户端连接到双栈SSH服务器的IPv4端，并将数据转发到仅支持IPv6的SMTP服务器。
- en: The flexibility of SSH tunnels allows for many other combinations, including
    the client being able to forward the port and allowing use of pregenerated keys
    for ease of administration (no logging in required). Disadvantages of using SSH
    as a transition mechanism include being able to forward only TCP connections and
    a possibility of high processing overhead in forwarding many ports using the same
    machine.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 隧道的灵活性允许多种其他组合，包括客户端能够转发端口并使用预生成的密钥以简化管理（无需登录）。使用 SSH 作为过渡机制的缺点包括仅能转发 TCP
    连接，并且在使用同一台机器转发多个端口时可能会产生较高的处理开销。
- en: IPv4 Residual Deployment via IPv6 (4rd)
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 IPv6 实现 IPv4 残余部署（4rd）
- en: 4rd is a stateless automatic tunneling mechanism to transparently tunnel IPv4
    packets over IPv6 networks. It is the reverse mechanism of 6rd. While IPv6 headers
    are too long to be mapped into IPv4 headers, so that 6rd requires encapsulation
    of full IPv6 packets in IPv4 packets, IPv4 headers can be reversibly translated
    into IPv6 headers in such a way that, during IPv6 domain traversal, UDP packets
    with checksums and TCP packets are valid IPv6 packets.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 4rd 是一种无状态的自动隧道机制，用于在 IPv6 网络上透明地隧道传输 IPv4 数据包。它是 6rd 的逆向机制。由于 IPv6 头部过长，无法映射到
    IPv4 头部，因此 6rd 需要将完整的 IPv6 数据包封装到 IPv4 数据包中，而 IPv4 头部可以反向转换为 IPv6 头部，确保在 IPv6
    域中传输时，具有校验和的 UDP 数据包和 TCP 数据包是有效的 IPv6 数据包。
- en: 4rd is in draft status at the time of writing. The draft is called “IPv4 Residual
    Deployment via IPv6—a Stateless Solution (4rd)” (*draft-ietf-softwire-4rd-08*).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 4rd 在撰写时处于草案状态。该草案名为“通过 IPv6 实现 IPv4 残余部署——无状态解决方案（4rd）”(*draft-ietf-softwire-4rd-08*)。
- en: Network Address and Protocol Translation
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络地址和协议转换
- en: NAT (Network Address Translation) and Protocol Translation are the most debated
    areas in IPv6 deployment scenarios. This section discusses the different forms
    of NAT that are available for the IPv4 address depletion problem and the integration
    of IPv6.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: NAT（网络地址转换）和协议转换是 IPv6 部署场景中争议最多的领域。本节讨论了为了解决 IPv4 地址枯竭问题而提供的不同形式的 NAT，以及 IPv6
    的整合。
- en: Network Address and Protocol Translation techniques offer transition mechanisms
    in addition to dual-stack and tunneling techniques. The goal is to provide transparent
    routing for nodes in IPv6 networks to communicate with nodes in IPv4 networks
    and vice versa.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 网络地址和协议转换技术提供了除双栈和隧道技术之外的过渡机制。其目标是为 IPv6 网络中的节点与 IPv4 网络中的节点之间的通信提供透明的路由，并支持双向通信。
- en: Note
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While with tunneling, the original IPv6 packet remains untouched, simply encapsulated
    in an IPv4 header and then decapsulated again at the tunnel endpoint, a translated
    packet is modified at the translator, according to the rules defined in what is
    called Stateless IP/ICMP Translation Algorithm (SIIT; RFC 6145).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与隧道技术不同，原始的 IPv6 数据包保持不变，仅被封装在 IPv4 头部中，然后在隧道端点解封装；而翻译数据包则在翻译器处根据所定义的规则进行修改，这些规则被称为无状态
    IP/ICMP 转换算法（SIIT；RFC 6145）。
- en: In the IPv4 world, Network Address and Port Translation (NAPT, usually simply
    called NAT) was defined many years ago to map between private addresses inside
    a network with a public address toward the outside world, in order to address
    the ongoing depletion of the public IPv4 address pool. This is a stateful technique,
    because the gateway needs to maintain state in order to route return packets correctly.
    Today, in our dual-stack world, this type of NAT is often called *NAT44*. In order
    to provide always-on connectivity to many devices, NAT not just maps devices and
    addresses, but also uses ports for each address to map multiple private addresses
    to one public address. There are 65,636 port numbers available for UDP and TCP
    each, many of which are unused. So NAT actually maps the internal private address
    and the port number to the outside public address and port number. This way it
    can map a large number of sessions for each public address. This NAT usually sits
    at the customer edge and runs on the CPE (Customer Premises Equipment).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPv4 环境中，网络地址和端口转换（NAPT，通常简称为 NAT）早在许多年前就被定义，用于将网络内部的私有地址映射到面向外部世界的公共地址，以解决公共
    IPv4 地址池的持续枯竭问题。这是一种有状态的技术，因为网关需要维护状态以正确地路由返回数据包。在我们当前的双栈环境中，这种类型的 NAT 通常被称为*NAT44*。为了为众多设备提供始终在线的连接，NAT
    不仅仅是映射设备和地址，还为每个地址使用端口，将多个私有地址映射到一个公共地址上。UDP 和 TCP 每种协议都有 65,636 个端口号可用，其中许多端口未被使用。因此，NAT
    实际上是将内部的私有地址和端口号映射到外部的公共地址和端口号上。这样，它就可以为每个公共地址映射大量的会话。这个 NAT 通常位于客户边缘，并运行在 CPE（客户驻地设备）上。
- en: The fact that we have waited too long with the deployment of IPv6 and are now
    running out of IPv4 address space will force us to use this type of transition
    technology to deal with the exponential growth of the Internet. The problem is
    that if new Internet users only get IPv6 addresses, they will not be able to access
    the still predominantly IPv4-accessible web content. So the IETF working groups
    decided to define standard translation methods to prevent the industry from developing
    an ungovernable variety of nonstandard methods.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拖延了IPv6的部署，并且现在IPv4地址空间即将耗尽，这将迫使我们使用这种过渡技术来应对互联网的指数级增长。问题在于，如果新的互联网用户仅获得IPv6地址，他们将无法访问目前仍以IPv4为主的网络内容。因此，IETF工作组决定定义标准的翻译方法，以防止行业开发出不可控的非标准方法。
- en: Before we go into the different types of NAT available today, let us have a
    look at the specification for IP and ICMP translation.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论今天可用的不同类型的NAT之前，先来看看IP和ICMP翻译的规范。
- en: Stateless IP/ICMP Translation
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无状态IP/ICMP翻译
- en: For the case in which IPv4-only hosts want to communicate with IPv6-only hosts
    or vice versa, RFC 6145 defines how a protocol translator has to translate the
    IP and ICMP headers for both parties to understand each other. For example, you
    might have a new network segment and want to roll out native IPv6 hosts. With
    the implementation of a protocol translator, it is possible to set up the new
    IPv6-only network internally and have those IPv6-only clients access the standard
    IPv4 Internet or any other IPv4-only node.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4-only主机希望与IPv6-only主机通信，或反之的情况下，RFC 6145定义了协议翻译器如何翻译IP和ICMP头，以使双方能够理解对方。例如，你可能有一个新的网络段，并希望推出本地IPv6主机。通过实现协议翻译器，可以内部设置新的IPv6-only网络，并让这些IPv6-only客户端访问标准的IPv4互联网或任何其他IPv4-only节点。
- en: For this discussion, we need to introduce a few terms. They are defined in RFC
    6052, “IPv6 Addressing of IPv4/IPv6 Translators,” which is a part of a series
    of documents about IPv4/IPv6 translation. It specifies how an individual IPv6
    address is translated to an IPv4 address and vice versa, in cases where an algorithmic
    mapping is used.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论中，我们需要引入一些术语。它们在RFC 6052《IPv4/IPv6翻译器的IPv6地址分配》中有所定义，这是关于IPv4/IPv6翻译系列文档的一部分。该文档规定了在使用算法映射时，如何将单个IPv6地址转换为IPv4地址，反之亦然。
- en: '*Address translator*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*地址翻译器*'
- en: A device that derives an IPv4 address from an IPv6 address or vice versa. This
    applies to devices that do IPv4/IPv6 translation, and also to other devices that
    manipulate addresses such as name-resolution proxies (e.g., DNS64 described later)
    and possibly other types of Application Layer Gateways (ALGs).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一种从IPv6地址派生IPv4地址或反向操作的设备。这适用于进行IPv4/IPv6翻译的设备，也适用于其他操作地址的设备，如名称解析代理（例如稍后描述的DNS64）以及其他类型的应用层网关（ALG）。
- en: '*IPv4-converted IPv6 address*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4转换IPv6地址*'
- en: An IPv6 address used to represent an IPv4 node in an IPv6 network. It is a variant
    of IPv4-embedded IPv6 addresses.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示IPv6网络中IPv4节点的IPv6地址。它是IPv4嵌入式IPv6地址的一种变体。
- en: '*IPv4-embedded IPv6 address*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4嵌入式IPv6地址*'
- en: An IPv6 address in which 32 bits represent an IPv4 address.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一种IPv6地址，其中32位表示一个IPv4地址。
- en: '*IPv4/IPv6 translator*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4/IPv6翻译器*'
- en: A device that translates IPv4 packets to IPv6 packets and vice versa. The translation
    can be *stateless* (no per-flow state required) or *stateful* (per-flow state
    is created when first packet in a flow is received).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一种将IPv4数据包转换为IPv6数据包，反之亦然的设备。翻译可以是*无状态*（不需要每个流的状态）或*有状态*（当接收到流中的第一个数据包时，会创建每个流的状态）。
- en: '*IPv4-translatable IPv6 address*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4可转换IPv6地址*'
- en: An IPv6 address assigned to an IPv6 node for use with stateless translation.
    It is a variant of IPv4-embedded IPv6 addresses.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给IPv6节点用于无状态翻译的IPv6地址。它是IPv4嵌入式IPv6地址的一种变体。
- en: '*Network-specific prefix*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络特定前缀*'
- en: An IPv6 prefix assigned by an organization for use in algorithmic mapping.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由组织分配的用于算法映射的IPv6前缀。
- en: '*Well-known prefix*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*著名前缀*'
- en: The well-known prefix to be used for algorithmic mappings is `64:ff9b::/96`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 用于算法映射的著名前缀是`64:ff9b::/96`。
- en: All IPv4-embedded addresses follow the same format described in a table in RFC
    6052\. A table, because they are composed of a variable-length prefix, the embedded
    IPv4 address, and a variable-length suffix (depending on the total length of the
    prefix, which can vary from 32 bits to 96 bits). The table in the RFC outlines
    all possible options.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 所有嵌入 IPv4 的地址都遵循 RFC 6052 中表格描述的相同格式。该表格包含一个可变长度的前缀、嵌入的 IPv4 地址和一个可变长度的后缀（后缀的长度取决于前缀的总长度，前缀的长度可以从
    32 位到 96 位不等）。RFC 中的表格列出了所有可能的选项。
- en: The prefix can either be a network-specific prefix or the well-known translation
    prefix. For stateless translation, a network-specific prefix should be used. For
    stateful translation, an organization can choose between a network-specific prefix
    or the well-known prefix. The well-known prefix should be used in most cases,
    except if it deems appropriate for management and operational reasons, or in the
    scenario where the IPv6 Internet connects to an IPv4 network.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀可以是网络特定的前缀或是著名的翻译前缀。对于无状态翻译，应使用网络特定前缀。对于有状态翻译，组织可以在网络特定前缀和著名前缀之间选择。著名前缀应在大多数情况下使用，除非出于管理和操作原因，或在
    IPv6 网络连接到 IPv4 网络的场景中，认为使用其他前缀更合适。
- en: The companion RFC 6144, “Framework for IPv4/IPv6 Translation,” describes eight
    different scenarios and outlines the requirements and rules for stateful or stateless
    translation. They are listed in the section [NAT64 scenarios](ch07.html#nat64_scenarios
    "NAT64 scenarios").
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的 RFC 6144 《IPv4/IPv6 翻译框架》描述了八种不同的场景，并概述了有状态和无状态翻译的要求和规则。它们列在[NAT64 场景](ch07.html#nat64_scenarios
    "NAT64 scenarios")一节中。
- en: TCP and UDP headers generally do not need to be modified by the translator.
    One exception is UDP headers that need a checksum for IPv6 because a UDP checksum
    is required for IPv6\. The same is true for ICMPv4 messages that need a checksum
    for ICMPv6\. In addition to the checksum, ICMP error messages contain the IP header
    of the original packet in the payload that needs to be modified by the translator;
    otherwise, the receiving node cannot understand it. IPv4 options and IPv6 Routing
    headers, Hop-by-Hop Options headers, and Destination Option headers are not translated.
    Also, the translation techniques cannot be used for multicast traffic, because
    IPv4 multicast addresses cannot be mapped into IPv6 multicast addresses and vice
    versa.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 和 UDP 头部通常不需要由翻译器修改。一个例外是需要为 IPv6 提供校验和的 UDP 头部，因为 IPv6 需要 UDP 校验和。ICMPv4
    消息同样需要为 ICMPv6 提供校验和。此外，ICMP 错误消息的有效负载中包含原始数据包的 IP 头部，需要由翻译器修改；否则，接收节点无法理解该数据包。IPv4
    选项、IPv6 路由头、逐跳选项头和目的选项头不进行翻译。此外，翻译技术不能用于多播流量，因为 IPv4 多播地址无法映射到 IPv6 多播地址，反之亦然。
- en: Just as with dual-stack nodes, applications running on nodes that use IP/ICMP
    translation need a mechanism to determine which protocol version to use for communication
    with their peers.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在双栈节点中一样，运行 IP/ICMP 翻译的节点上的应用程序需要一种机制来确定与对等节点通信时使用哪个协议版本。
- en: Translating IPv4 to IPv6
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 IPv4 翻译为 IPv6
- en: An IPv4-to-IPv6 translator receives an IPv4 datagram. Because it has been configured
    to know the pool of IPv4 addresses that represent the internal IPv6 nodes, the
    translator knows that the packet needs translation. It removes the IPv4 header
    and replaces it with an IPv6 header by translating all the information from the
    IPv4 header into the IPv6 header.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv4 到 IPv6 的翻译器接收到一个 IPv4 数据报。因为它已经配置为知道代表内部 IPv6 节点的 IPv4 地址池，翻译器知道该数据包需要翻译。它移除
    IPv4 头部，并通过将 IPv4 头部的所有信息翻译到 IPv6 头部，来替换为 IPv6 头部。
- en: Path MTU Discovery is optional in IPv4 but mandatory in IPv6\. If an IPv4 host
    does Path MTU Discovery by setting the Don’t Fragment Bit in the header, Path
    MTU Discovery works even through the translator. The sender may receive Packet
    Too Big messages from both IPv4 and IPv6 routers. If the Don’t Fragment Bit is
    not set in the IPv4 packet, an IPv6 translator has to ensure that the packet can
    safely travel through the IPv6 network. It does this by fragmenting the IPv4 packet
    if necessary, using the minimum MTU for IPv6, 1,280 bytes. IPv6 guarantees that
    1,280-byte packets will be delivered without a need for further fragmentation.
    In this case, the translator always includes a fragment header to indicate that
    the sender allows fragmentation. Should this packet travel through an IPv6-to-IPv4
    translator, the translator knows it can fragment the packet.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 路径 MTU 探测在 IPv4 中是可选的，但在 IPv6 中是强制性的。如果 IPv4 主机通过在头部设置不分片位来进行路径 MTU 探测，那么即使通过翻译器，路径
    MTU 探测也能正常工作。发送方可能会从 IPv4 和 IPv6 路由器接收到“数据包过大”消息。如果在 IPv4 数据包中未设置不分片位，则 IPv6 翻译器必须确保该数据包可以安全地通过
    IPv6 网络。它通过必要时对 IPv4 数据包进行分片来实现这一点，使用 IPv6 的最小 MTU 1,280 字节。IPv6 保证 1,280 字节的数据包可以顺利传输，无需进一步分片。在这种情况下，翻译器始终包括一个分片头，以表明发送方允许分片。如果该数据包通过
    IPv6 到 IPv4 的翻译器，翻译器知道它可以对该数据包进行分片。
- en: For a UDP packet with a zero checksum, the translator must calculate a valid
    checksum for IPv6\. If a translator receives the first fragment of a fragmented
    UDP packet with a zero checksum, it should drop the packet and generate a system
    message specifying the IP address and port number. Further fragments should be
    silently discarded.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个校验和为零的 UDP 数据包，翻译器必须计算一个有效的 IPv6 校验和。如果翻译器接收到一个分片的 UDP 数据包的第一个分片，且其校验和为零，它应丢弃该数据包并生成一个系统消息，指定
    IP 地址和端口号。后续分片应被静默丢弃。
- en: Translating ICMPv4 to ICMPv6 and vice versa
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 ICMPv4 转换为 ICMPv6 及反向转换
- en: For all ICMPv4 messages, the translator has to compute a valid checksum because
    it is required with ICMPv6\. In addition to this, the type values have to be translated
    and, for error messages, the included IP header also needs to be translated. Internet
    Group Management Protocol (IGMP) messages are single-hop messages and should not
    be forwarded over routers. Therefore, they do not require translation and are
    silently discarded.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 ICMPv4 消息，翻译器必须计算一个有效的校验和，因为 ICMPv6 要求校验和。此外，还需要转换类型值，对于错误消息，还需要转换其中包含的
    IP 头。互联网组管理协议（IGMP）消息是单跳消息，不应通过路由器转发。因此，它们不需要转换，并会被静默丢弃。
- en: The same translation rules apply to the translation of ICMPv6 messages to ICMPv4
    messages, only in reverse order.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的翻译规则适用于 ICMPv6 消息到 ICMPv4 消息的转换，只是顺序相反。
- en: Translating IPv6 to IPv4
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 IPv6 转换为 IPv4
- en: This process is not much different from the translation discussed previously.
    In this case, the translator knows that it has to translate from IPv6 to IPv4
    based on the IPv4-mapped Destination address. It removes the IPv6 header and replaces
    it with an IPv4 header. The minimum MTU for IPv4 is 576 bytes; the minimum MTU
    for IPv6 is 1,280 bytes. If a translator receives a packet for an IPv4 network
    with a smaller MTU, it creates 1,280-byte packets and fragments them after translation.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与之前讨论的翻译过程没有太大区别。在这种情况下，翻译器知道它必须根据 IPv4 映射的目标地址将 IPv6 转换为 IPv4。它移除 IPv6
    头并用 IPv4 头替换。IPv4 的最小 MTU 为 576 字节，IPv6 的最小 MTU 为 1,280 字节。如果翻译器收到一个用于 IPv4 网络的较小
    MTU 的数据包，它将在翻译后创建 1,280 字节的数据包并进行分片。
- en: NAT to Extend IPv4 Address Space
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NAT 扩展 IPv4 地址空间
- en: This section is not really about IPv6 transition. It explains the ways NAT is
    used today in order to extend IPv4 address space (and this is what NAT was originally
    designed for). These mechanisms will be used by ISPs all over the world because
    we waited too long and the IPv4 address space is now exhausted. These mechanisms
    have a major impact on how users access IPv4 websites.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本节实际上并不是关于 IPv6 过渡的内容。它解释了 NAT 如何被用于扩展 IPv4 地址空间（这也是 NAT 最初的设计目的）。这些机制将被全球的
    ISP 使用，因为我们等待得太久，IPv4 地址空间已经耗尽。这些机制对用户访问 IPv4 网站的方式产生了重大影响。
- en: Carrier Grade NAT
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运营商级 NAT
- en: As providers run out of IPv4 addresses and cannot cover Internet growth with
    IPv4, they have to deploy IPv6\. But users want to be dual-stacked as they want
    to be able to access the IPv4 content on the Internet. So why not NAT the IPv4
    part of the Internet connection? This lets users access IPv6 content over IPv6,
    but still get to IPv4 content over their NATed IPv4 connection.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 随着提供商用完IPv4地址且无法用IPv4满足互联网增长的需求，他们必须部署IPv6。但用户希望实现双栈（dual-stack），因为他们希望能够访问互联网上的IPv4内容。那么，为什么不对互联网连接的IPv4部分进行NAT转换呢？这样用户可以通过IPv6访问IPv6内容，但仍能通过其NAT转换的IPv4连接访问IPv4内容。
- en: This can be achieved by using what we call Carrier Grade NAT (CGN, also called
    LSN for Large Scale NAT), or *NAT444*. It means we add another layer of NAT to
    the NAT44 by adding a NAT44 inside the ISP’s network. Traditional NAT44 is between
    the customer network and the ISP network. CGN is between the customer networks
    and the ISP network and allows the ISP to assign a private IPv4 address to the
    customers, not a public one. Or in other words, the traditional customer-side
    NAT now translates from private IPv4 inside to private IPv4 outside. [Figure 7-20](ch07.html#carrier_grade_nat-id1
    "Figure 7-20. Carrier Grade NAT") shows this in a diagram.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过我们所称的运营商级NAT（CGN，也叫大规模NAT（LSN））来实现，或者称为*NAT444*。这意味着我们通过在ISP网络内增加一个NAT44层，将NAT44与运营商级NAT（CGN）相结合。传统的NAT44位于客户网络和ISP网络之间。而CGN则位于客户网络和ISP网络之间，允许ISP为客户分配私有IPv4地址，而不是公共地址。换句话说，传统的客户端NAT现在将私有IPv4地址从内部转换为私有IPv4地址到外部。[图7-20](ch07.html#carrier_grade_nat-id1
    "图7-20. 运营商级NAT")以图示方式展示了这一点。
- en: '![Carrier Grade NAT](images/ipv6_0720.png)Figure 7-20. Carrier Grade NAT'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![运营商级NAT](images/ipv6_0720.png)图7-20. 运营商级NAT'
- en: On the bottom part we see the traditional NAT connecting a customer’s privately
    addressed networks through NAT with the provider network. In this NAT444 scenario,
    the translation is from private IPv4 to private IPv4\. This allows the ISP to
    connect many customers through a single public IPv4 address on the outside.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们看到传统的NAT通过NAT将客户的私有地址网络连接到提供商网络。在这个NAT444场景中，地址转换是从私有IPv4到私有IPv4。这允许ISP通过外部的单一公共IPv4地址连接多个客户。
- en: Let’s follow a packet. It originates inside the customer site. Its address is
    converted from private inside to a private address from within the CGN. When leaving
    the ISP network, it gets the public address assigned to the outside interface
    of the CGN. The packet goes through address translation and port mapping twice.
    This mechanism is called NAT444 because it only translates IPv4 to IPv4, with
    the goal to expand the address space. The advantage is that it can mostly be achieved
    with current equipment and implementations.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪一个数据包。它从客户站点内部发起，地址从私有内部地址转换为CGN内部的私有地址。当离开ISP网络时，它会获得分配给CGN外部接口的公共地址。该数据包经过两次地址转换和端口映射。这个机制被称为NAT444，因为它只将IPv4转换为IPv4，目的是扩展地址空间。其优点是大多数情况下可以通过现有设备和实现来完成。
- en: Experience will have to show how this scales with large numbers of users. The
    processing it takes for all the translations and mappings for a large number of
    users will have its limits that are yet to be determined. There may also be issues
    with overlapping private space, if an organization internally uses the same range
    as the provider within the CGN. Another issue might occur if customers connected
    to the same CGN want to send traffic to each other. Their packets may have to
    be routed to the outside and come back with a public IPv4 source address; otherwise,
    they may be filtered by traditional ACLs based on their private source address.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 经验将显示这一方案在大量用户中如何扩展。对于大量用户的所有翻译和映射所需的处理能力将有其极限，而这些极限尚未确定。如果一个组织在内部使用与提供商在CGN中相同的地址范围，可能还会出现重叠私有空间的问题。如果连接到同一CGN的客户想要互相发送流量，可能也会出现问题。它们的数据包可能必须路由到外部，再返回时使用公共IPv4源地址；否则，可能会被基于其私有源地址的传统访问控制列表（ACL）过滤掉。
- en: Where with traditional NAT, users in one site shared one public IPv4 address,
    with CGN multiple customers share one public IPv4 address. This can create some
    critical issues. For instance, if somebody successfully attacks the public IPv4
    address, not just one customer, but all customers using that CGN IPv4 address
    may be affected. If one of the customers is a bad guy and blacklisted, all of
    the customers sharing the same address will be affected.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的NAT不同，在传统的NAT中，一个站点的用户共享一个公共IPv4地址，而在CGN中，多个客户共享一个公共IPv4地址。这可能会引发一些关键问题。例如，如果有人成功攻击了该公共IPv4地址，不仅是一个客户，所有使用该CGN
    IPv4地址的客户都可能受到影响。如果其中一个客户是恶意用户并被列入黑名单，那么所有共享相同地址的客户都将受到影响。
- en: Another issue is the fact that all these customers share a fixed pool of ports
    and so only a limited number of ports per customer will be available to a probably
    increasing number of customers. When users run applications that use a large number
    of multiple simultaneous sessions, such as Google Maps or iTunes to name two examples,
    the CGN gateway may run out of port numbers and sessions. And the fact is that
    today’s applications have an increasing appetite for parallel sessions. This leads
    to the fact that applications or services may not run well or even fail. For a
    user sitting behind a CGN this is usually not traceable. The user will assume
    that the website is not running or has issues.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，所有这些客户共享一个固定的端口池，因此每个客户可用的端口数量有限，而客户的数量可能会增加。当用户运行需要大量多个同时会话的应用程序时，比如Google
    Maps或iTunes等，CGN网关可能会耗尽端口号和会话。事实上，今天的应用程序对并行会话的需求不断增加。这导致应用程序或服务可能无法正常运行，甚至失败。对于一个位于CGN后面的用户来说，这通常是无法追踪的。用户会认为该网站没有运行或存在问题。
- en: Note
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: From the perspective of a content provider, you want to offer your public services
    dual-stack in order to bypass CGNs and make sure your customers have a good experience
    when they visit your website. If your content is dual-stack, Internet users with
    IPv4 CGN access can come to your site using native IPv6 (if their provider offers
    IPv6 Internet access).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 从内容提供者的角度来看，你希望提供双栈公共服务，以绕过CGN，并确保客户在访问你的网站时有良好的体验。如果你的内容是双栈的，那么使用IPv4 CGN访问的互联网用户可以通过原生IPv6访问你的网站（前提是他们的服务提供商提供IPv6互联网接入）。
- en: There is an interesting RFC, RFC 7021, “Assessing the Impact of Carrier-Grade
    NAT on Network Applications,” which summarizes CGN tests performed by CableLabs,
    Time Warner Cable, and Rogers Communications. They independently tested the impacts
    of NAT444 on many popular Internet services using a variety of test scenarios,
    network topologies, and vendor equipment. The RFC identifies areas where adding
    a second layer of NAT disrupts the communication channel for common Internet applications.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有一篇有趣的RFC，RFC 7021《评估运营商级NAT对网络应用的影响》，它总结了CableLabs、时代华纳有线电视公司和罗杰斯通信公司对CGN的测试。他们独立测试了NAT444对许多流行互联网服务的影响，使用了多种测试场景、网络拓扑和供应商设备。该RFC指出，增加第二层NAT会破坏常见互联网应用的通信通道。
- en: NAT464
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NAT464
- en: Another way to solve this problem can be to deploy IPv6-only between the customer
    edge and the provider network. This requires translation from IPv4 to IPv6 at
    the customer edge and translation again from IPv6 to IPv4 at the CGN. This reduces
    the need for IPv4 addresses on the provider side. Translation becomes more difficult
    as translation across protocols (from IPv4 to IPv6) is more complex than address
    translation within one protocol family. Also NAT444 is widely implemented and
    available while implementations for NAT464 are not so widespread at the time of
    writing. [Figure 7-21](ch07.html#nat464-id1 "Figure 7-21. NAT464") shows the NAT464
    network.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方式是，在客户边缘和服务提供商网络之间部署仅IPv6。这需要在客户边缘进行IPv4到IPv6的转换，并在CGN处进行IPv6到IPv4的转换。这减少了服务提供商端对IPv4地址的需求。因为跨协议的转换（从IPv4到IPv6）比同一协议族内的地址转换更为复杂，转换变得更加困难。另外，NAT444被广泛实现并可用，而NAT464的实现目前还没有那么普及。[图7-21](ch07.html#nat464-id1
    "图7-21. NAT464")展示了NAT464网络。
- en: '![NAT464](images/ipv6_0721.png)Figure 7-21. NAT464'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![NAT464](images/ipv6_0721.png)图7-21. NAT464'
- en: In this case, the provider conserves IPv4 address space not by assigning private
    IPv4 addresses to the customer CPEs, but rather by using an IPv6-only network
    and translating the customer’s IPv4 traffic to IPv6 with NAT46 and translating
    it back to IPv4 with NAT64 at the CGN. In both cases, with CGN and NAT464, multiple
    customers share one public IPv4 address.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务提供商通过使用仅 IPv6 的网络，并通过 NAT46 将客户的 IPv4 流量转换为 IPv6，再通过 CGN 使用 NAT64 将其转换回
    IPv4，从而节省了 IPv4 地址空间，而不是为客户的 CPE 分配私有 IPv4 地址。在这两种情况下，通过 CGN 和 NAT464，多个客户共享一个公共
    IPv4 地址。
- en: The main disadvantage of this type of translation in general is, besides the
    fact that a NAT device is always a bottleneck, that when you have to translate
    IPv6 to IPv4, you lose all the advanced features of IPv6, because they cannot
    be translated to IPv4\. So, for instance, if the packet has Extension headers,
    not all the information can be translated into IPv4 options. But in this scenario,
    where the applications are IPv4 and the tunnel is used to get from one IPv4 island
    to the next, there are probably no advanced IPv6 features to be lost.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的转换的一大缺点是，除了 NAT 设备始终是瓶颈之外，当你必须将 IPv6 转换为 IPv4 时，你会失去 IPv6 的所有高级功能，因为它们无法转换为
    IPv4。例如，如果数据包具有扩展头部，并非所有信息都能转换为 IPv4 选项。但是，在这个场景中，由于应用程序是 IPv4 并且隧道用于从一个 IPv4
    网络到另一个 IPv4 网络，可能不会丢失任何高级的 IPv6 功能。
- en: DS-Lite
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DS-Lite
- en: 'DS-Lite is another mechanism to allow for IPv6-only connection between the
    customer site and the CGN. Instead of translating from IPv4 to IPv6 and vice versa,
    such as in NAT464, the IPv4 packets are tunneled in IPv6 to the CGN. That is to
    say, one level of translation from IPv4 to IPv6 and IPv6 to IPv4, as in NAT464,
    is removed. DS-Lite is specified in RFC 6333\. New terms in the specification
    are:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: DS-Lite 是另一种机制，允许客户站点与 CGN 之间仅使用 IPv6 连接。与 NAT464 中的 IPv4 到 IPv6 和 IPv6 到 IPv4
    的双向转换不同，IPv4 数据包被封装在 IPv6 中传输到 CGN。也就是说，去除了一个从 IPv4 到 IPv6 和 IPv6 到 IPv4 的转换层，如同
    NAT464 中那样。DS-Lite 在 RFC 6333 中进行了规范。该规范中的新术语包括：
- en: '*DS-Lite Basic Bridging BroadBand element (B4)*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*DS-Lite 基本桥接宽带元素 (B4)*'
- en: B4 is a function implemented on a dual-stack capable node. This node can be
    either a directly connected node or a CPE (Customer Premise Equipment) that creates
    a tunnel to the AFTR (defined below).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: B4 是在支持双栈的节点上实现的一个功能。该节点可以是直接连接的节点，也可以是创建到 AFTR（下文定义）的隧道的 CPE（客户驻地设备）。
- en: '*DS-Lite Address Family Transition Router (AFTR)*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*DS-Lite 地址族过渡路由器 (AFTR)*'
- en: An AFTR is the combination of an IPv4-in-IPv6 tunnel endpoint and an IPv4-IPv4
    NAT implemented on the same node. The AFTR can be provisioned with different NAT
    pools and serve different groups of clients with different address pools.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: AFTR 是 IPv4-in-IPv6 隧道端点和同一节点上实现的 IPv4-IPv4 NAT 的组合。AFTR 可以配置不同的 NAT 池，并为不同的客户群提供不同的地址池。
- en: DS-Lite is shown in [Figure 7-22](ch07.html#ds-lite-id1 "Figure 7-22. DS-Lite").
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: DS-Lite 如图 [7-22](ch07.html#ds-lite-id1 "图7-22. DS-Lite") 所示。
- en: '![DS-Lite](images/ipv6_0722.png)Figure 7-22. DS-Lite'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![DS-Lite](images/ipv6_0722.png)图7-22. DS-Lite'
- en: The diagram shows that the private customer network is connected to the ISP
    private network through an IPv6 tunnel. The NAT maps the combination of IPv6 source
    address, IPv4 source address plus port to the outside IPv4 address plus port.
    Several customers are sharing one IPv4 public address. All IPv4 in IPv6 tunnels
    end on the AFTR. When customers communicate using IPv6, there are no tunnels,
    the AFTR is bypassed and the traffic goes out natively. The trick here is to ensure
    that source addresses are unique. If many customers using private RFC 1918 addresses
    connect, their source address isn’t distinguishable anymore. DS-Lite solves this
    problem by linking the IPv4 source address with the unique IPv6 address used for
    the tunnel.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示，私有客户网络通过 IPv6 隧道连接到 ISP 私有网络。NAT 将 IPv6 源地址、IPv4 源地址加端口的组合映射到外部 IPv4 地址加端口。多个客户共享一个公共
    IPv4 地址。所有在 IPv6 隧道中的 IPv4 数据流都在 AFTR 结束。当客户使用 IPv6 通信时，不需要隧道，AFTR 被绕过，流量直接出去。这里的关键是确保源地址是唯一的。如果多个客户使用私有
    RFC 1918 地址连接，其源地址将不再可区分。DS-Lite 通过将 IPv4 源地址与用于隧道的唯一 IPv6 地址关联，解决了这个问题。
- en: Usually the CPE has DHCPv4 functionality handing out private IPv4 address space
    to hosts in the home network. It also advertises itself as a DNS server and should
    run a DNS proxy to resolve DNS queries from IPv4 hosts with the service providers
    DNS servers over the IPv6 network. In order to establish the tunnel to the AFTR,
    the B4 element is configured with the IPv6 address of the AFTR either through
    manual configuration or through DHCPv6\. RFC 6334 defines a DHCPv6 DS-Lite option.
    A well-known IPv4 subnet address has been defined by the IANA to represent the
    B4 element. The range is `192.0.0.0/29`. `192.0.0.1` is reserved for the AFTR
    element and `192.0.0.2` is reserved for the B4 element.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，CPE 具有 DHCPv4 功能，向家庭网络中的主机分配私有 IPv4 地址空间。它还会自我广播为 DNS 服务器，并应运行 DNS 代理，将来自
    IPv4 主机的 DNS 查询通过 IPv6 网络转发至服务提供商的 DNS 服务器。为了建立与 AFTR 的隧道，B4 元件通过手动配置或 DHCPv6
    配置 AFTR 的 IPv6 地址。RFC 6334 定义了一个 DHCPv6 DS-Lite 选项。IANA 已定义了一个众所周知的 IPv4 子网地址来表示
    B4 元件。该范围为 `192.0.0.0/29`。`192.0.0.1` 被保留给 AFTR 元件，`192.0.0.2` 被保留给 B4 元件。
- en: DS-Lite removes one level of NAT compared to NAT444 or NAT464\. The disadvantage
    is that single users cannot be identified by their IP address anymore. Currently
    DS-Lite only specifies IPv4 in IPv6 tunnels. Other types of encapsulation could
    be defined in the future. RFC 6619, “Scalable Operation of Address Translators
    with Per-Interface Bindings,” for instance, defines a solution to use protocol
    translation during the migration period to IPv6 to deploy these mechanisms in
    a way that allows the support of a large user base without the need for a correspondingly
    large IPv4 address block.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于 NAT444 或 NAT464，DS-Lite 移除了一个 NAT 层级。其缺点是单个用户不再能通过 IP 地址来识别。目前，DS-Lite 仅在
    IPv6 隧道中指定 IPv4。未来可能会定义其他类型的封装。例如，RFC 6619《具有每接口绑定的地址转换器的可扩展操作》定义了一种解决方案，允许在向
    IPv6 迁移的过程中使用协议转换，以一种支持大规模用户基础的方式部署这些机制，而无需相应的大 IPv4 地址块。
- en: RFC 6908, “Deployment Considerations for DS-Lite,” refers to the scenarios for
    DS-Lite mentioned in the Appendix of RFC 6333 and describes problems that can
    arise when deploying DS-Lite and how they can be mitigated. The information and
    recommendations in this RFC are based on real-world experience and can be useful
    for operators.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 6908《DS-Lite 部署考虑事项》提到了 RFC 6333 附录中提到的 DS-Lite 场景，并描述了在部署 DS-Lite 时可能出现的问题以及如何缓解这些问题。该
    RFC 中的信息和建议基于现实世界的经验，对运营商具有参考价值。
- en: There is an extension to DS-Lite underway (in draft status at the time of writing),
    called *Lightweight 4over6* (LW46). It moves the Network Address and Port Translation
    (NAPT) function from the centralized DS-Lite tunnel concentrator to the tunnel
    client located in the CPE. This removes the requirement for a Carrier Grade NAT
    function in the tunnel concentrator and reduces the amount of centralized state
    that must be held to a per-subscriber level.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: DS-Lite 正在进行扩展（在写作时为草稿状态），称为 *Lightweight 4over6*（LW46）。它将网络地址和端口转换（NAPT）功能从集中式的
    DS-Lite 隧道集中器移至位于 CPE 的隧道客户端。这消除了隧道集中器中对运营商级 NAT 功能的需求，并将必须保持的集中式状态减少到每个用户级别。
- en: NAT as an IPv6 Translation Mechanism
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NAT 作为 IPv6 翻译机制
- en: In the early days of IPv6 there was one main translation mechanism defined in
    RFC 2766, “NAT-PT, Network Address Translation—Protocol Translation.” It was moved
    to historic with RFC 4966 because it was too complex. The SIIT (Stateless IP/ICMP
    Translation) RFC is still active and the specification is used in newer forms
    of translators, such as in NAT64.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 IPv6 发展中，RFC 2766《NAT-PT，网络地址转换—协议转换》中定义了一个主要的翻译机制。由于其过于复杂，它在 RFC 4966
    中被移至历史性标准。SIIT（无状态 IP/ICMP 翻译）RFC 仍然有效，并且该规范在新型的翻译器中得到了使用，例如在 NAT64 中。
- en: The following sections describe a number of different translation techniques,
    some of them still in draft status. Depending on when you read this book, they
    may be published as an RFC.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了多种不同的翻译技术，其中一些仍处于草稿状态。根据您阅读本书的时间，它们可能会作为 RFC 发布。
- en: Note
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Expect to see more types and flavors of translation mechanisms to appear. But
    note that the main recommendation is to not use them if possible and go native
    IPv6 wherever you can, especially in the enterprise network. Providers may have
    to use translation mechanisms, mainly due to IPv4 address shortage. As an Internet
    customer you want to know what kind of access your provider gives you, from an
    IPv4 and IPv6 perspective.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 预计将会出现更多种类和形式的翻译机制。但请注意，主要的建议是，如果可能的话，不要使用这些机制，而是尽量使用原生IPv6，尤其是在企业网络中。服务提供商可能需要使用翻译机制，主要是由于IPv4地址短缺。作为互联网用户，你需要了解你的服务提供商从IPv4和IPv6角度提供的接入类型。
- en: Stateless NAT64
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无状态NAT64
- en: Stateless NAT64 provides a translation mechanism that translates IPv6 headers
    into IPv4 headers and vice versa. It is based on RFC 6144, which defines a framework
    for IPv4/IPv6 translation and provides an overview and discussion of all possible
    scenarios. Due to the stateless character, this mechanism is very efficient. It
    supports end-to-end transparency and has a better scalability than stateful translation.
    Multiple translators can be deployed in parallel without the need to synchronize
    state between them.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态NAT64提供了一种翻译机制，它将IPv6头部翻译为IPv4头部，反之亦然。它基于RFC 6144，该RFC定义了IPv4/IPv6翻译的框架，并提供了所有可能场景的概述和讨论。由于其无状态特性，该机制非常高效。它支持端到端透明性，并且具有比有状态翻译更好的可扩展性。多个翻译器可以并行部署，而无需在它们之间同步状态。
- en: For the stateless mechanism the translation information is carried in the address
    itself. To perform stateless translation, there must be a rule how an IPv6 address
    is translated to a corresponding IPv4 address and vice versa. A specific IPv6
    address range represents the IPv4 systems in the IPv6 world. This range is manually
    configured on the NAT device. In the IPv4 world all the IPv6 systems have directly
    correlated IPv4 addresses that can be mapped to a subset of the service provider’s
    IPv4 addresses. The IPv6 hosts are assigned IPv6 addresses through either manual
    configuration or DHCPv6\. The IPv4-embedded IPv6 address format is described in
    section 2.2 of RFC 6052\. The well-known prefix to use for an algorithmic mapping
    is `64:ff9b::/96`. Common implementations often allow you to configure your own
    prefix taken from your IPv6 address range.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无状态机制，翻译信息携带在地址本身中。要执行无状态翻译，必须有一个规则来定义如何将IPv6地址翻译为相应的IPv4地址，反之亦然。一个特定的IPv6地址范围代表了IPv6世界中的IPv4系统。这个范围在NAT设备上手动配置。在IPv4世界中，所有的IPv6系统都拥有直接关联的IPv4地址，可以映射到服务提供商的IPv4地址子集。IPv6主机通过手动配置或DHCPv6分配IPv6地址。嵌入IPv4的IPv6地址格式在RFC
    6052的第2.2节中进行了描述。用于算法映射的知名前缀是`64:ff9b::/96`。常见的实现通常允许你从你的IPv6地址范围中配置自己的前缀。
- en: With stateless NAT64, sessions can be initiated from both sides, from IPv4 to
    IPv6 and vice versa. The disadvantage is that it consumes an IPv4 address for
    each IPv6 device that needs translation. So it is not a solution to address IPv4
    address depletion. It can be used to provide public servers with an IP address
    for both protocols. But to aggregate many IPv6 users to a single IPv4 address,
    stateful NAT64 has to be used. Another limitation of stateless NAT64 is that only
    IPv4 options that have direct counterparts in IPv6 are translated, and it does
    not translate IPv6 Extension headers except for the Fragmentation header. The
    best use case for stateless NAT64 is probably to provide access to an IPv6 server
    to IPv4 clients.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无状态NAT64，能够从双方发起会话，即从IPv4到IPv6，反之亦然。其缺点是每个需要翻译的IPv6设备都会消耗一个IPv4地址。因此，它不是解决IPv4地址枯竭问题的方案。它可以用于为公共服务器提供支持两种协议的IP地址。但为了将多个IPv6用户聚合到一个IPv4地址上，必须使用有状态NAT64。无状态NAT64的另一个限制是，只有IPv4选项中在IPv6中有直接对应项的才会被翻译，并且它不翻译IPv6扩展头部，除了分片头部。无状态NAT64的最佳使用案例可能是为IPv4客户端提供访问IPv6服务器的功能。
- en: Stateful NAT64 and DNS64
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有状态NAT64和DNS64
- en: This scenario is used where users only have IPv6 addresses but need to connect
    to IPv4 networks and to the IPv4 Internet. One or more public IPv4 addresses are
    assigned to the translator to be shared among the IPv6 clients. When stateful
    NAT64 is used with DNS64, no changes are usually required in the IPv6 client or
    the IPv4 server. To have support for DNS64, use BIND 9.8.0\. Stateful NAT64 is
    specified in RFC 6146 and DNS64 in RFC 6147.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 该场景用于仅拥有 IPv6 地址的用户需要连接到 IPv4 网络及 IPv4 互联网的情况。一个或多个公共 IPv4 地址被分配给翻译器，由 IPv6
    客户端共享。当使用 DNS64 配合有状态 NAT64 时，通常不需要在 IPv6 客户端或 IPv4 服务器中做出任何更改。要支持 DNS64，请使用 BIND
    9.8.0。RFC 6146 规定了有状态 NAT64，RFC 6147 规定了 DNS64。
- en: '[Figure 7-23](ch07.html#stateful_nat64_and_dns64-id1 "Figure 7-23. Stateful
    NAT64 and DNS64") shows how this works.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-23](ch07.html#stateful_nat64_and_dns64-id1 "图 7-23. 有状态 NAT64 和 DNS64")
    显示了这一工作原理。'
- en: '![Stateful NAT64 and DNS64](images/ipv6_0723.png)Figure 7-23. Stateful NAT64
    and DNS64'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![有状态 NAT64 和 DNS64](images/ipv6_0723.png)图 7-23. 有状态 NAT64 和 DNS64'
- en: The IPv6 client sends a DNS AAAA request to the DNS64 server for a certain domain
    name. If the name server has an AAAA record, it will pass the information and
    the client will connect over IPv6\. If the DNS64 server does not have a AAAA record,
    because it is an IPv4-only service, it finds the corresponding A record and creates
    a synthetic record. The name server uses the well-known prefix of `64:ff9b::/96`
    or the specific prefix chosen and configured for this purpose and inserts the
    IPv4 address learned from the A record into the 32 low-order bits of the IPv6
    address. So if the A record was `203.10.100.2`, the IPv6 address will be `64:ff9b::203.10.100.2`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 客户端向 DNS64 服务器发送 DNS AAAA 请求以查询某个域名。如果该域名服务器有 AAAA 记录，它会传递相关信息，客户端将通过 IPv6
    连接。如果 DNS64 服务器没有 AAAA 记录，因为它是仅支持 IPv4 的服务，它会找到相应的 A 记录并创建合成记录。域名服务器使用 `64:ff9b::/96`
    的知名前缀，或为此目的选择并配置的特定前缀，将从 A 记录中获取的 IPv4 地址插入到 IPv6 地址的低 32 位。因此，如果 A 记录是 `203.10.100.2`，IPv6
    地址将是 `64:ff9b::203.10.100.2`。
- en: When the client initializes a connection to this address it will be routed through
    the NAT64 gateway, which will use an IPv4 address from its pool with an associated
    port number, creating a mapping entry for the two addresses. It will then translate
    the IPv6 header into an IPv4 header using the translation mechanisms described
    in RFC 6145, and send it to the destination IPv4 address, learned from the IPv6
    address.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端初始化连接到此地址时，它将通过 NAT64 网关进行路由，NAT64 网关将使用其池中的一个 IPv4 地址及相关端口号，创建这两个地址的映射条目。然后，它将使用
    RFC 6145 中描述的翻译机制，将 IPv6 头部翻译为 IPv4 头部，并将其发送到从 IPv6 地址中获取的目标 IPv4 地址。
- en: Stateful NAT64 only supports IPv6-initiated connections and is therefore suited
    for IPv6-only hosts to provide access to an IPv4 host. The advantage is that many
    IPv6-only hosts can connect to the IPv4 Internet through a single IPv4 public
    address. If an IPv4 device needs to speak to an IPv6-only device, the translation
    must be configured manually.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态 NAT64 仅支持由 IPv6 发起的连接，因此适用于提供 IPv4 主机访问的 IPv6 单栈主机。其优势在于，许多 IPv6 单栈主机可以通过一个公共
    IPv4 地址连接到 IPv4 互联网。如果 IPv4 设备需要与 IPv6 单栈设备通信，必须手动配置翻译。
- en: This has been tested and works well for general Internet access. Problems arise
    when IPv4 addresses are embedded in applications or when IPv4 literals are used.
    RFC 7050 defines a method how clients can discover a NAT64 prefix if they can’t
    query a DNS64 server. Application developers should stick to using FQDNs (Fully
    Qualified Domain Names) in applications instead of IP addresses. A variety of
    vendors have implemented stateful NAT64 and large mobile providers are doing trials.
    In the mobile world this mechanism may be preferred as it uses less power on the
    mobile client (battery) than a dual-stack client.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 经过测试，这种方法在一般的互联网访问中运行良好。但当 IPv4 地址嵌入应用程序中或使用 IPv4 字面量时，会出现问题。RFC 7050 定义了一种方法，说明客户端如果无法查询
    DNS64 服务器时，如何发现 NAT64 前缀。应用程序开发人员应坚持在应用程序中使用 FQDN（完全限定域名）而非 IP 地址。一些厂商已实现有状态 NAT64，许多大型移动提供商正在进行试验。在移动世界中，这种机制可能更受欢迎，因为它比双栈客户端消耗更少的移动客户端电池。
- en: NAT64 scenarios
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NAT64 场景
- en: 'As listed in RFC 6144, NAT64 can translate eight different scenarios. The following
    list shows which type of NAT64 supports the translation:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如 RFC 6144 中所列，NAT64 可以翻译八种不同的场景。下列清单显示了哪些类型的 NAT64 支持翻译：
- en: '*An IPv6 network to the IPv4 Internet*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6 网络到 IPv4 互联网*'
- en: Both stateless and stateful NAT64 can support this scenario.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态和有状态 NAT64 都可以支持此场景。
- en: '*The IPv4 Internet to an IPv6 network*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4 互联网到 IPv6 网络*'
- en: For this scenario to work with stateful NAT64, a DNS Application Level Gateway
    (ALG) would have to be used. This was deprecated with RFC 4966\. Stateless NAT64
    can be used for this scenario as it supports connections initiated by IPv4 nodes.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要使该场景与有状态 NAT64 配合工作，必须使用 DNS 应用层网关（ALG）。此功能已在 RFC 4966 中弃用。可以使用无状态 NAT64 来支持该场景，因为它支持由
    IPv4 节点发起的连接。
- en: '*The IPv6 Internet to an IPv4 network*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6 互联网到 IPv4 网络*'
- en: Stateless NAT64 does not work with this scenario because stateless NAT64 only
    supports 1:1 address translation. The IPv4 address space could only support a
    small subset of the IPv6 address space. But IPv6-initiated connections can be
    supported through stateful NAT64\. A network-specific prefix will be assigned
    to the translator that assigns the hosts IPv4-converted IPv6 addresses. Static
    AAAA records can be put into DNS to represent these IPv4-only hosts.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态 NAT64 不适用于此场景，因为无状态 NAT64 仅支持 1:1 地址转换。IPv4 地址空间只能支持 IPv6 地址空间的一小部分。但通过有状态
    NAT64，可以支持 IPv6 发起的连接。一个网络特定的前缀将分配给转换器，用于为主机分配已转换为 IPv6 的 IPv4 地址。可以将静态 AAAA 记录放入
    DNS 中，表示这些仅支持 IPv4 的主机。
- en: '*An IPv4 network to the IPv6 Internet*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4 网络到 IPv6 互联网*'
- en: For this scenario to work with stateful NAT64, a DNS Application Level Gateway
    (ALG) would have to be used. This was deprecated with RFC 4966\. This scenario
    is not considered viable as these requirements will only occur in a later deployment
    state of the IPv6 Internet. For this scenario, other techniques should be considered.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使该场景与有状态 NAT64 配合工作，必须使用 DNS 应用层网关（ALG）。此功能已在 RFC 4966 中弃用。此场景被认为不可行，因为这些需求只会出现在
    IPv6 互联网的后期部署阶段。对于该场景，应考虑其他技术。
- en: '*An IPv6 network to an IPv4 network*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6 网络到 IPv4 网络*'
- en: For this scenario, both networks are within the same organization. This scenario
    is the same as scenario one from a translation perspective. So both stateless
    and stateful translation can be used.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此场景，两个网络位于同一组织内。从转换的角度来看，该场景与场景一相同。因此，可以使用无状态和有状态转换。
- en: '*An IPv4 network to an IPv6 network*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4 网络到 IPv6 网络*'
- en: For this scenario, both networks are within the same organization. This scenario
    is the same as scenario two from a translation perspective. So the same rules
    apply here.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此场景，两个网络位于同一组织内。从转换的角度来看，该场景与场景二相同。因此，适用相同的规则。
- en: '*The IPv6 Internet to the IPv4 Internet and vice versa*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv6 互联网到 IPv4 互联网，反之亦然*'
- en: Due to the huge difference in size between the two address spaces, there is
    no viable translation technique to handle unlimited IPv6 address translation.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个地址空间之间存在巨大的大小差异，目前没有可行的转换技术可以处理无限制的 IPv6 地址转换。
- en: If you are interested in operational experience with NAT64 in combination with
    CGN or as a server frontend (FE) mechanism, please refer to RFC xxxx (*draft-ietf-v6ops-nat64-experience-10.txt*).
    It is a report of operational deployment and testing of a NAT64 service between
    an IPv6-only mobile network and the larger IPv4 Internet as well as a NAT64 service
    in an IDC environment. This testing includes the use of NAT64 CGN and NAT64 FE;
    its coexistence with more traditional NAT44; reliability, availability, and maintainability
    issues; the transparency or lack of it regarding source addresses; quality of
    experience; MTU issues; and ULA-related issues.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对 NAT64 与 CGN 或作为服务器前端（FE）机制的操作经验感兴趣，请参阅 RFC xxxx（*draft-ietf-v6ops-nat64-experience-10.txt*）。该报告记录了在
    IPv6 仅移动网络与更大的 IPv4 互联网之间部署和测试 NAT64 服务的操作经验，以及在 IDC 环境中部署的 NAT64 服务。此测试包括 NAT64
    CGN 和 NAT64 FE 的使用；它与更传统的 NAT44 的共存；可靠性、可用性和可维护性问题；源地址的透明性或缺失；体验质量；MTU 问题；以及与
    ULA 相关的问题。
- en: RFC 6889, “Analysis of Stateful 64 Translation,” analyzes how stateful NAT64
    solves the issues that led to the deprecation of NAT-PT (RFC 2766).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 6889《有状态 64 翻译分析》分析了有状态 NAT64 如何解决导致 NAT-PT（RFC 2766）被弃用的问题。
- en: 464XLAT
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 464XLAT
- en: 464XLAT is not a separate transition mechanism. RFC 6877 describes an architecture
    that combines stateful translation in the core with stateless translation at the
    edge of the network. This provides IPv4 connectivity for IPv4-only applications
    across an IPv6-only network.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 464XLAT 不是一个独立的过渡机制。RFC 6877 描述了一个架构，该架构将核心网络中的有状态转换与网络边缘的无状态转换相结合。这为 IPv4 仅应用程序提供了跨
    IPv6 仅网络的 IPv4 连接。
- en: 'To discuss 464XLAT, we have to introduce two terms:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论 464XLAT，我们必须引入两个术语：
- en: '*PLAT*'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '*PLAT*'
- en: PLAT is a provider-side translator (XLAT) that complies with RFC 6146 on stateful
    NAT64\. It translates N:1 global IPv6 addresses to global IPv4 addresses and vice
    versa.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: PLAT 是一种提供者端翻译器（XLAT），遵循 RFC 6146 中关于有状态 NAT64 的规范。它将 N:1 的全局 IPv6 地址转换为全局 IPv4
    地址，反之亦然。
- en: '*CLAT*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*CLAT*'
- en: CLAT is the customer-side translator (XLAT). It complies with RFC 6145 on IP/ICMP
    Translation Algorithms. It translates 1:1 private IPv4 addresses to global IPv6
    addresses and vice versa. The CLAT can run on a router or on an end device such
    as a mobile phone. It performs IP routing to forward packets through the stateless
    translation.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: CLAT 是客户侧翻译器（XLAT）。它遵循 RFC 6145 中关于 IP/ICMP 翻译算法的规范。它将 1:1 的私有 IPv4 地址转换为全局
    IPv6 地址，反之亦然。CLAT 可以运行在路由器上或终端设备上，例如手机。它执行 IP 路由，转发数据包通过无状态翻译。
- en: 464XLAT provides easy-to-use transition services as it requires no new protocols.
    It encourages the deployment of IPv6-only networks that are less expensive to
    operate than dual-stack networks. It is also needed in cases where there are no
    IPv4 addresses available anymore, but IPv6-only hosts need access to IPv4 applications.
    So it decouples network growth at the edge from IPv4 address availability.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 464XLAT 提供易于使用的过渡服务，因为它不需要新的协议。它鼓励部署 IPv6-only 网络，这些网络比双栈网络的运营成本更低。当 IPv4 地址不再可用，但
    IPv6-only 主机仍需访问 IPv4 应用程序时，它也非常必要。因此，它将网络边缘的增长与 IPv4 地址的可用性解耦。
- en: '[Figure 7-24](ch07.html#xlat_architecture "Figure 7-24. 464XLAT architecture")
    shows the 464XLAT architecture.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-24](ch07.html#xlat_architecture "图 7-24. 464XLAT 架构") 展示了 464XLAT 架构。'
- en: '![464XLAT architecture](images/ipv6_0724.png)Figure 7-24. 464XLAT architecture'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '![464XLAT 架构](images/ipv6_0724.png) 图 7-24. 464XLAT 架构'
- en: 'On the left side of the diagram, you see three different types of clients:
    an IPv6-only host, a dual-stack host with a private IPv4 address, and an IPv4-only
    host, also with a private IPv4 address. The IPv6 hosts can reach the IPv6 Internet
    directly without translation. IPv6 hosts can reach global IPv4 hosts through the
    PLAT (NAT64). The IPv4 hosts can reach global IPv4 hosts via stateless translation
    on the CLAT and stateful translation on the PLAT.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，您可以看到三种不同类型的客户端：一个 IPv6-only 主机，一个具有私有 IPv4 地址的双栈主机，以及一个 IPv4-only 主机，也具有私有
    IPv4 地址。IPv6 主机可以直接访问 IPv6 网络，而无需翻译。IPv6 主机可以通过 PLAT（NAT64）访问全球 IPv4 主机。IPv4 主机可以通过
    CLAT 上的无状态翻译和 PLAT 上的有状态翻译访问全球 IPv4 主机。
- en: The 464XLAT address format follows the IPv4-embedded IPv6 address format described
    in the table in section 2.2 of RFC 6052, “IPv6 Addressing of IPv4/IPv6 Translators.”
    The CLAT needs a /64 IPv6 prefix for the uplink interface and a /64 prefix for
    each downlink interface and a dedicated /64 prefix for the purpose of sending
    and receiving statelessly translated packets.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 464XLAT 地址格式遵循 RFC 6052 中第 2.2 节表格所描述的 IPv4 嵌入式 IPv6 地址格式，标题为“IPv4/IPv6 翻译器的
    IPv6 地址分配”。CLAT 需要一个用于上行接口的 /64 IPv6 前缀，一个用于每个下行接口的 /64 前缀，以及一个专用的 /64 前缀，用于发送和接收无状态翻译的数据包。
- en: An IPv6-only host that wants to discover a NAT64 prefix sends a DNS query for
    a AAAA record for the domain `ipv4only.arpa` (RFC 7050) to its DNS server. If
    there is a NAT64 prefix, the host gets a DNS reply with a synthesized AAAA record.
    This AAAA record contains the IPv6 prefix plus the 32 bits of the IPv4 address
    for `ipv4only.arpa`. The CLAT uses the prefix to send packets to the translator.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 想要发现 NAT64 前缀的 IPv6-only 主机会向其 DNS 服务器发送一个查询请求，查询域名 `ipv4only.arpa` 的 AAAA 记录（RFC
    7050）。如果存在 NAT64 前缀，主机会收到一个 DNS 响应，其中包含合成的 AAAA 记录。这个 AAAA 记录包含了 IPv6 前缀和 `ipv4only.arpa`
    的 32 位 IPv4 地址。CLAT 使用该前缀将数据包发送给翻译器。
- en: This architecture supports IPv4 in the client-server model. It is not designed
    for IPv4 peer-to-peer communication or inbound IPv4 connections. It is based on
    IPv6 transport and supports native IPv6 communication. The advantage is that it
    also works for IPv4 applications that contain literals, as only the IP header
    is translated and the payload of the packet is encapsulated in the translated
    header.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 该架构支持客户端-服务器模型中的 IPv4。它并不设计用于 IPv4 点对点通信或入站 IPv4 连接。它基于 IPv6 传输，并支持原生的 IPv6
    通信。其优点在于，它同样适用于包含字面值的 IPv4 应用程序，因为仅 IP 头部会被翻译，数据包的有效负载则被封装在翻译后的头部中。
- en: MAP
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MAP
- en: A new mechanism has been developed called *MAP*. It comes in two flavors, both
    specifying mechanisms to map IPv4 to IPv6\. Draft *“draft-ietf-softwire-map,”*
    called MAP-E, specifies the encapsulation of IPv4 packets in IPv6 including the
    address mapping with independence between IPv6 and IPv4 addresses. The other draft,
    *“draft-ietf-softwire-map-t,”* specifies the MAP-T mechanism, which uses the same
    address- and port-mapping algorithm and offers the same functionality as MAP-E,
    but does translation instead of encapsulation. Both mechanisms serve the purpose
    of delivering IPv4 services across an IPv6-only infrastructure, a situation and
    requirement which will become more and more common in the future.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 开发了一种新机制，称为*MAP*。它有两种版本，都指定了将IPv4映射到IPv6的机制。草案*“draft-ietf-softwire-map”*，即MAP-E，指定了IPv4数据包在IPv6中的封装，包括IPv6和IPv4地址之间的地址映射，且两者之间相互独立。另一个草案*“draft-ietf-softwire-map-t”*指定了MAP-T机制，它使用相同的地址和端口映射算法，并提供与MAP-E相同的功能，但采用的是转换而不是封装。两种机制的目的是在仅支持IPv6的基础设施中提供IPv4服务，这种情况和需求在未来将会变得越来越普遍。
- en: The big advantage of MAP compared with CGN, NAT464, and DS-Lite is that it requires
    no central stateful translator on the service provider’s network. This allows
    providers to deploy native IPv6 and share the scarce IPv4 address resources with
    much less overhead.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与CGN、NAT464和DS-Lite相比，MAP的最大优势在于它不需要在服务提供商网络中部署中央有状态转换器。这使得提供商可以部署原生IPv6，并以更少的开销共享稀缺的IPv4地址资源。
- en: MAP is shown in [Figure 7-25](ch07.html#map-id1 "Figure 7-25. MAP").
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: MAP如[图7-25](ch07.html#map-id1 "图7-25. MAP")所示。
- en: '![MAP](images/ipv6_0725.png)Figure 7-25. MAP'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '![MAP](images/ipv6_0725.png)图7-25. MAP'
- en: As you can see in the figure, the translation is moved to the CPE. All traffic
    through the provider network is now IPv6-only. This removes the need for a stateful
    CGN; the IPv6 traffic is forwarded by the Border Router (BR). The BR handles the
    traffic from a given MAP domain and is reachable via anycast.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，转换被移到了CPE端。通过服务提供商网络的所有流量现在都是IPv6-only。这消除了对有状态CGN的需求；IPv6流量由边界路由器（BR）转发。BR处理来自特定MAP域的流量，并且可以通过Anycast访问。
- en: MAP uses an IPv6-address-to-IPv4-address mapping with port-mapping algorithm.
    Specific bits in the IPv6 address space are used to represent both IPv4 addresses
    and ports. With MAP-T, the IP header is translated; with MAP-E, the IPv4 datagram
    is encapsulated in an IPv6 header. NAT44 as used with MAP differs slightly from
    traditional NAT44, as it allows assigning a port range to each of the CPEs sharing
    the same public IPv4 address. This address and port combination is then translated
    into the IPv6 address space on the MAP CPE. This stateless address mapping between
    IPv4 and IPv6 addresses removes the need for a large stateful translator in the
    provider network.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: MAP使用IPv6地址到IPv4地址的映射以及端口映射算法。IPv6地址空间中的特定位被用于表示IPv4地址和端口。在MAP-T中，IP头部被转换；在MAP-E中，IPv4数据报被封装在IPv6头部中。与传统NAT44相比，MAP所使用的NAT44略有不同，它允许为每个共享相同公共IPv4地址的CPE分配一个端口范围。然后，将该地址和端口组合转换为MAP
    CPE上的IPv6地址空间。这种IPv4和IPv6地址之间的无状态映射消除了在服务提供商网络中使用大型有状态转换器的需求。
- en: All nodes in a MAP domain must be provisioned with a set of parameters, which
    are used to implement the MAP functions. They can be configured manually or provisioned
    by DHCP. There are three rules, the *Basic Mapping Rule* (BMR), the *Default Mapping
    Rule* (DMR), and the *Forwarding Mapping Rules* (FMR). The mapping rules define
    the forwarding behavior for a MAP domain and make up the *Mapping Rule Table*
    (MRT), which serves as a routing table for the BR and CE.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: MAP域中的所有节点必须配置一组参数，用于实现MAP功能。这些参数可以手动配置或通过DHCP进行配置。这里有三条规则，分别是*基本映射规则*（BMR）、*默认映射规则*（DMR）和*转发映射规则*（FMR）。这些映射规则定义了MAP域的转发行为，并组成了*映射规则表*（MRT），它作为BR和CE的路由表。
- en: MAP-E is going to be a standards track RFC, while MAP-T is going to be an informational
    or experimental RFC. There is also a draft specifying DHCPv6 options for address
    mapping, so a DHCP server can provision the information needed for the address-mapping
    algorithm (*draft-ietf-softwire-map-dhcp-07*).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: MAP-E将成为标准化的RFC，而MAP-T将成为信息性或实验性的RFC。还有一个草案指定了用于地址映射的DHCPv6选项，以便DHCP服务器可以提供地址映射算法所需的信息（*draft-ietf-softwire-map-dhcp-07*）。
- en: NPTv6 and NAT66
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPTv6 和 NAT66
- en: 'A frequently asked question is whether there is or will be a counterpart to
    NAT (in this case, people usually refer to what we call NAT44) in IPv6\. Given
    the fact that NAT was originally designed as a temporary solution to the IPv4
    address depletion problem, you would expect a simple answer: no, because IPv6
    is the long-term solution to the address exhaustion problem. And by design, the
    developers of IPv6 had end-to-end IPv6 networks in mind with no NAT.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是，IPv6 是否存在或将来是否会出现类似于 NAT（在这种情况下，通常指的是我们所称的 NAT44）的方法。鉴于 NAT 最初是作为 IPv4
    地址耗尽问题的临时解决方案设计的，你可能会期待一个简单的答案：不会，因为 IPv6 是解决地址耗尽问题的长期解决方案。而且，IPv6 的开发者在设计时考虑的正是没有
    NAT 的端到端 IPv6 网络。
- en: Now, unfortunately people got very used to NAT in general and there are some
    use cases where some form of IPv6 NAT could be useful. So we can’t get around
    discussing NAT for IPv6\. Let us have a closer look at NPTv6.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不幸的是，人们普遍已经习惯了 NAT，并且在某些使用场景中，一些形式的 IPv6 NAT 可能是有用的。所以我们不得不讨论 IPv6 的 NAT。让我们更仔细地看看
    NPTv6。
- en: IPv6-to-IPv6 Prefix Translation (NPTv6)
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv6 到 IPv6 前缀转换（NPTv6）
- en: 'In the introduction to RFC 6296, “IPv6-to-IPv6 Network Prefix Translation,”
    the IETF clearly states that they do not recommend the use of NAT technology for
    IPv6\. So why do they publish a specification? One of the reasons is that they
    learned from the experience with IPv4 NAT. They did not publish a specification
    for NAT44 for the same reason: they did not think it was a good idea. This led
    to the fact that vendors started to implement their proprietary version of NAT44,
    which again led to the situation we face today, with multiple flavors of NAT44\.
    This adds a lot to the complexity. So the IETF decided that even though they do
    not want to encourage NAT in IPv6 networks, it would be better to still have a
    specification, so that at least everybody who was doing it used the same mechanism.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RFC 6296《IPv6 到 IPv6 网络前缀转换》的引言中，IETF 明确表示他们不推荐在 IPv6 中使用 NAT 技术。那么，为什么他们还要发布一个规范呢？其中一个原因是他们从
    IPv4 NAT 的经验中吸取了教训。他们没有发布 NAT44 规范，原因也是一样：他们认为这不是一个好主意。这导致厂商开始实现他们各自版本的 NAT44，这又导致了今天我们面临的情况，即出现了多种不同版本的
    NAT44。这大大增加了复杂性。因此，IETF 决定，尽管他们不想在 IPv6 网络中鼓励使用 NAT，但最好还是有一个规范，以便至少所有使用它的人都采用相同的机制。
- en: NPTv6 is a stateless IPv6-to-IPv6 network-prefix translation mechanism. It provides
    address independence to the network. Address independence means that addresses
    used inside the local network do not need to be renumbered in case the global
    prefix changes (due to a provider change, for instance). Sessions can be initiated
    from both sides (internal or external). You can also connect multiple NPTv6 Translators
    and also use them in multihoming scenarios. Section 2 in RFC 6296 describes some
    use cases.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: NPTv6 是一种无状态的 IPv6 到 IPv6 网络前缀转换机制。它为网络提供了地址独立性。地址独立性意味着，如果全局前缀发生变化（例如，由于服务提供商更换），本地网络内部使用的地址无需重新编号。会话可以从两端发起（内部或外部）。你还可以连接多个
    NPTv6 转换器，并在多宿主场景中使用它们。RFC 6296 第 2 节描述了一些使用案例。
- en: There is a major difference between NPTv6 and NAT44, stemming from the fact
    that NPTv6 is not designed to save addresses. So the address-mapping is a 1:1
    mapping and there is no need to modify port numbers and rewrite transport layer
    headers. In this respect, NPTv6 is less complex than traditional NAT44, but some
    issues still remain. For instance, it does not work with the IPsec Authentication
    Header, which provides protection for the IP header. Applications that transmit
    IP addresses in the payload may also stumble. The deployment of NPTv6 may also
    require configuring split DNS, as internal hosts want to resolve names for internal
    services to internal addresses, while external nodes need to obtain external addresses
    for the services. Some people perceive NAT44 to be a security feature due to the
    fact that it lets you hide your internal topology. NPTv6 does not hide your topology
    because the address mapping is 1:1\. Only the prefix is translated and it must
    be a prefix of the same size. So if you want to translate a /48 internally, you
    also need a /48 externally. But you may choose to only translate a subset of your
    prefix, such as one or several /64 out of your /48 (for instance, the client subnets
    that need Internet access).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: NPTv6 和 NAT44 之间存在一个主要区别，源于 NPTv6 并不是为了节省地址而设计的。因此，地址映射是 1:1 映射，不需要修改端口号或重写传输层头部。在这方面，NPTv6
    比传统的 NAT44 更简单，但仍然存在一些问题。例如，它无法与 IPsec 身份验证头（Authentication Header）一起工作，该头部为 IP
    头部提供保护。传输 IP 地址的应用程序也可能会遇到问题。部署 NPTv6 可能还需要配置拆分 DNS，因为内部主机希望将内部服务的名称解析为内部地址，而外部节点需要获取服务的外部地址。由于
    NAT44 允许隐藏内部拓扑，一些人认为它是一种安全功能。NPTv6 并不隐藏你的拓扑，因为地址映射是 1:1。只有前缀被翻译，并且它必须是相同大小的前缀。所以，如果你想在内部翻译一个
    /48 的地址，你也需要一个外部的 /48 地址。但你可以选择只翻译前缀的一个子集，比如从 /48 中的一个或几个 /64（例如，需要访问互联网的客户端子网）。
- en: Another option to have independence in your address space is to apply for Provider
    Independent (PI) address space. But not all organizations qualify to receive a
    PI allocation. If you do qualify you have to ensure that your ISP(s) are willing
    to install specific routes for your prefix. This can be especially difficult or
    troublesome if you have locations in different geographical regions. It is not
    guaranteed that you will get a U.S. ISP to route a PI prefix that was allocated
    from RIPE (Europe region).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使地址空间独立的选择是申请提供商独立（PI）地址空间。但并不是所有组织都符合资格接收 PI 分配。如果你符合资格，你必须确保你的 ISP(s) 愿意为你的前缀安装特定的路由。如果你在不同的地理区域有多个位置，这可能会特别困难或麻烦。如果你获得了
    RIPE（欧洲地区）分配的 PI 前缀，无法保证你会得到美国 ISP 的路由支持。
- en: NAT66
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NAT66
- en: NAT66 is the equivalent to NAT44\. The difference to NPTv6 is that this translator
    is stateful. An IPv6 address on one interface is translated to a new IPv6 address
    on another interface of the router or firewall. Return traffic has to come the
    same way back, as the device keeps a state table of all the translations. With
    NAT66 the internal and external prefixes do not need to be of the same size. Whether
    this is a good idea or not is your choice. Most will probably choose to deal with
    prefixes of the same size anyway, for simplicity reasons. There are implementations
    from different vendors on the market. NAT66 has the same problems as NAT44 and
    there will be many workarounds needed to make all applications work through it.
    Going back to our design recommendations, this means carefully evaluate whether
    you really need and want this and only do this if there is no simpler solution.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: NAT66 相当于 NAT44。与 NPTv6 的区别在于，NAT66 是有状态的翻译器。一个接口上的 IPv6 地址被翻译为路由器或防火墙的另一个接口上的新
    IPv6 地址。返回流量必须沿相同路径返回，因为设备会保持所有翻译的状态表。在 NAT66 中，内部和外部前缀不需要大小相同。是否这样做是你的选择。大多数人可能会选择处理相同大小的前缀，出于简化的考虑。市场上有来自不同供应商的实现。NAT66
    与 NAT44 存在相同的问题，许多应用程序仍然需要通过各种解决方法才能正常工作。回到我们的设计建议，这意味着需要仔细评估你是否真的需要并希望这样做，只有在没有更简单的解决方案时才采取此措施。
- en: Other Translation Techniques
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他翻译技术
- en: There are additional translation mechanisms, which I describe in this section.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我将描述一些额外的翻译机制。
- en: Bump-in-the-Host
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机中的碰撞（Bump-in-the-Host）
- en: Bump-in-the-Host (BIH) is a host-based IPv4-to-IPv6 protocol translation mechanism
    that allows a class of IPv4-only applications that work through NATs to communicate
    with IPv6-only peers. It is defined in RFC 6535\. The host on which applications
    are running may be connected to IPv6-only or dual-stack access networks. BIH hides
    IPv6 and makes the IPv4-only applications think they are talking with IPv4 peers
    by local synthesis of IPv4 addresses. This document obsoletes RFC 2767 (Bump-in-the-Stack)
    and RFC 3338 (Bump-in-the-API).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 主机内翻译（BIH）是一种基于主机的 IPv4 到 IPv6 协议翻译机制，它允许通过 NAT 工作的 IPv4-only 应用程序与 IPv6-only
    对等体通信。它在 RFC 6535 中定义。应用程序运行的主机可能连接到 IPv6-only 或双栈接入网络。BIH 隐藏了 IPv6，使 IPv4-only
    应用程序通过本地合成 IPv4 地址认为它们正在与 IPv4 对等体通信。本文件废除了 RFC 2767（Bump-in-the-Stack）和 RFC 3338（Bump-in-the-API）。
- en: Transport Relay Translator
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传输中继翻译器
- en: The Transport Relay Translator (TRT; see RFC 3142) is a translation mechanism
    to be used in an IPv6-only network on the transport layer. It sits in the IPv6
    network and allows communication between IPv6 nodes and IPv4 nodes. Every communication
    of an IPv6 client with an IPv4 application needs to go through the Relay Translator.
    In case of a TCP connection, the relay terminates the connection to the client
    and makes a new TCP connection on the other side to the IPv4 application. Internally,
    the translator translates between the two sessions. In case of a UDP connection,
    the translator simply translates and forwards the packet.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 传输中继翻译器（TRT；参见 RFC 3142）是一种在 IPv6-only 网络中用于传输层的翻译机制。它位于 IPv6 网络中，允许 IPv6 节点和
    IPv4 节点之间进行通信。每次 IPv6 客户端与 IPv4 应用程序通信时，都需要通过中继翻译器。如果是 TCP 连接，中继器会终止与客户端的连接，并在另一端与
    IPv4 应用程序建立新的 TCP 连接。在内部，翻译器在这两个会话之间进行转换。如果是 UDP 连接，中继器只需翻译并转发数据包。
- en: All translation techniques should be used only if there is no other choice.
    The overview in this chapter aims to give an idea of the variety of mechanisms
    to enable coexistence and smooth transition. The most important goal the developers
    had in mind was to provide mechanisms to give customers the possibility to move
    to an IPv6 network as soon as possible. The sooner you have an IPv6-dominant network,
    the better, because maintaining one protocol is always less costly than maintaining
    two.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 所有翻译技术应仅在没有其他选择时使用。本章的概述旨在展示各种机制，以便实现共存和顺利过渡。开发人员最重要的目标是提供机制，使客户能够尽快过渡到 IPv6
    网络。网络越早转向 IPv6 越好，因为维护单一协议总是比维护两个协议更具成本效益。
- en: Load Balancing
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载均衡
- en: 'If you have either IPv4 servers and applications and want to give access for
    IPv6 users, or the other way around, there are two potential options that cover
    this scenario:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有 IPv4 服务器和应用程序，并且希望为 IPv6 用户提供访问，或者反过来，有两种潜在的选项可以涵盖这种情况：
- en: Use stateless NAT64 (or NAT46, respectively)
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无状态 NAT64（或 NAT46）
- en: Use load balancers
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用负载均衡器
- en: The stateless NAT is easy to implement and does not require much resources.
    The load balancer choice is a common one and a good short-term solution, since
    load balancers are essentially mandatory pieces of equipment for the frontend
    in data centers anyway. Different load balancer vendors offer high-performance
    load balancers that support many different mechanisms and can be used in most
    scenarios. But make sure to test your specific planned scenario for performance
    under load and in dual-stack mode if that is going to be used.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态 NAT 易于实现，且不需要太多资源。负载均衡器选择是常见的且是一个很好的短期解决方案，因为负载均衡器在数据中心的前端几乎是必需的设备。不同的负载均衡器供应商提供高性能负载均衡器，支持多种机制，且可以用于大多数场景。但请确保在负载和双栈模式下测试你具体的计划场景的性能，如果需要使用双栈模式的话。
- en: Comparison
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Now that you have an overview of the available techniques, I’ll summarize them
    by listing advantages and disadvantages. This summary should help you determine
    which way to go and which combinations to choose.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了可用的技术概述，我将通过列出优缺点来总结它们。这一总结应该能帮助你确定选择哪种方案以及哪些组合适合使用。
- en: Dual-Stack
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双栈
- en: This technique is easy to use and flexible. It is your best option. Hosts can
    communicate with IPv4 hosts using IPv4 or communicate with IPv6 hosts using IPv6\.
    When everything has been upgraded to IPv6, the IPv4 stack can simply be disabled
    or removed. Whenever you can, deploying dual-stack hosts and routers offers the
    greatest flexibility in dealing with islands of IPv4-only applications, equipment,
    and networks. Dual-stack is also the basis for other transition mechanisms. Tunnels
    need dual-stacked endpoints, and translators need dual-stacked gateways.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术易于使用且灵活，是你最佳的选择。主机可以使用 IPv4 与 IPv4 主机通信，或者使用 IPv6 与 IPv6 主机通信。当一切都升级为 IPv6
    时，IPv4 栈可以简单地禁用或移除。只要条件允许，部署双栈主机和路由器可以提供最大的灵活性，以应对仅有 IPv4 的应用、设备和网络孤岛。双栈也是其他过渡机制的基础。隧道需要双栈端点，转换器需要双栈网关。
- en: 'Disadvantages of this technique include the following: you have two separate
    protocol stacks running, so you need additional CPU power and memory on the host.
    All the tables are kept twice: one per protocol stack. Generally, all applications
    running on the dual-stack host must be capable of determining whether this host
    is communicating with an IPv4 or IPv6 peer. In a dual-stack network, you need
    to have a routing protocol for each version of IP. If you are using dual-stack
    techniques, make sure that you have firewalls in place that protect not only your
    IPv4 network, but also your IPv6 network, and remember that you need separate
    security concepts and firewall rules for each protocol.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的缺点包括以下几点：你需要运行两个独立的协议栈，因此主机需要额外的 CPU 能力和内存。所有的表格都会被保留两次：每个协议栈一个。通常，所有运行在双栈主机上的应用程序必须能够确定该主机是在与
    IPv4 还是 IPv6 对等体通信。在双栈网络中，你需要为每个版本的 IP 配置路由协议。如果你使用双栈技术，请确保你有防火墙来保护不仅是你的 IPv4
    网络，还有你的 IPv6 网络，并且记住你需要为每个协议制定独立的安全策略和防火墙规则。
- en: It also makes troubleshooting problems more complicated. For instance, did an
    application that has problems with IPv6 attempt to connect via IPv4 instead of
    IPv6 and fail? How do you have to adjust your troubleshooting approaches to test
    and figure that out? Your helpdesk and IT support staff also need to understand
    how to use specific tools for IPv4 and IPv6 so they can rule out one protocol
    versus the other. So from an operational and support perspective, it may cost
    more to run a dual-stack network. This is one of the main reasons many enterprises
    consider to migrate to an IPv6-only infrastructure as soon as possible.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 它也让故障排除变得更加复杂。例如，某个与 IPv6 相关的问题的应用程序是否尝试通过 IPv4 而非 IPv6 连接并失败？你需要如何调整你的故障排除方法来测试并找出原因？你的帮助台和
    IT 支持人员还需要了解如何使用特定工具来处理 IPv4 和 IPv6，以便能够区分这两种协议。所以从运维和支持的角度来看，运行双栈网络可能会花费更多。这也是许多企业考虑尽快迁移到仅支持
    IPv6 的基础设施的主要原因之一。
- en: Tunneling
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隧道技术
- en: Tunneling allows you to migrate to IPv6 just the way you like. There is no specific
    upgrade order that needs to be followed. You can even upgrade single hosts or
    single subnets within your corporate network and connect separated IPv6 clouds
    through tunnels. You don’t need your ISP to support IPv6 in order to access remote
    IPv6 networks because you can tunnel through their IPv4 infrastructure. And you
    don’t need to upgrade your backbone first. As long as your backbone is IPv4, you
    can use tunnels to transport IPv6 packets over the backbone. If you have an MPLS
    infrastructure, you have the best foundation for using this to tunnel IPv6 packets
    as long as you do not want to upgrade the backbone routers to support IPv6 natively.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道技术允许你按照自己的方式迁移到 IPv6。没有必须遵循的特定升级顺序。你甚至可以升级公司网络中的单一主机或子网，通过隧道连接分离的 IPv6 云。你不需要你的
    ISP 支持 IPv6 来访问远程的 IPv6 网络，因为你可以通过他们的 IPv4 基础设施建立隧道。而且你不需要首先升级你的骨干网络。只要你的骨干网络是
    IPv4 的，你就可以通过隧道将 IPv6 数据包传输到骨干网络上。如果你有 MPLS 基础设施，只要不打算将骨干路由器升级为原生支持 IPv6，你就有最好的基础来使用它进行
    IPv6 数据包的隧道传输。
- en: The disadvantages are known from other tunneling techniques used in the past.
    Additional load is put on the router. A general rule is that stateless tunnels
    are preferred over stateful tunnels. The tunnel entry and exit points need time
    and CPU power for encapsulating and decapsulating packets. They also represent
    single points of failure. Troubleshooting gets more complex because you might
    run into hop count or MTU size issues, as well as fragmentation problems. Management
    of encapsulated traffic (e.g., per-protocol accounting) is also more difficult
    due to encapsulation. Tunnels also offer points for security attacks. Find more
    information on security issues in [Chapter 6](ch06.html "Chapter 6. Security with
    IPv6").
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点来自过去使用的其他隧道技术。路由器承受额外负担。一般来说，推荐使用无状态隧道而不是有状态隧道。隧道的入口和出口点需要时间和CPU资源来进行数据包的封装和解封装。它们也代表着单点故障。故障排除变得更加复杂，因为可能会遇到跳数或MTU大小问题，以及碎片化问题。由于封装，封装流量的管理（例如，每协议的计费）也变得更加困难。隧道还提供了安全攻击的点。有关安全问题的更多信息，请参见[第6章](ch06.html
    "第6章. IPv6安全")。
- en: Note
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: RFC 7059, “A Comparison of IPv6-over-IPv4 Tunnel Mechanisms,” provides a nice
    overview of currently available tunnel mechanisms, including considerations to
    make when choosing a suitable tunnel mechanism.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 7059，《IPv6-over-IPv4隧道机制比较》，提供了当前可用隧道机制的简要概述，包括选择合适隧道机制时需要考虑的因素。
- en: Translation
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译
- en: Translation should be used only if no other technique is possible and should
    be viewed as a temporary solution until one of the other techniques can be implemented.
    The disadvantages are that translation between IPv4 and IPv6 does not support
    the advanced features of IPv6, such as Extension headers and end-to-end security.
    It poses limitations on the design topology because replies have to come through
    the same NAT router from which they were sent. The NAT router is a single point
    of failure, and flexible routing mechanisms cannot be used. All applications that
    have IP addresses in the payload of the packets will stumble. The advantage of
    this method is that it allows IPv6 hosts to communicate directly with IPv4 hosts
    and vice versa. In certain cases NAT may help to deploy IPv6-only networks in
    an early stage. Pros and cons have to be considered, but this may be a viable
    solution.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译只应在没有其他技术可用时使用，并应视为临时解决方案，直到可以实施其他技术之一。其缺点是IPv4与IPv6之间的翻译不支持IPv6的高级特性，如扩展头和端到端安全性。它对设计拓扑结构提出了限制，因为回复必须通过相同的NAT路由器返回。NAT路由器是单点故障，并且不能使用灵活的路由机制。所有在数据包有效载荷中包含IP地址的应用都会遇到问题。这种方法的优点是，它允许IPv6主机直接与IPv4主机通信，反之亦然。在某些情况下，NAT可能有助于在早期阶段部署仅IPv6的网络。需要考虑利弊，但这可能是一个可行的解决方案。
- en: Now that you have mastered the IPv6 basics and your integration options, it
    is time to put it all in place and start the planning of your transition. Refer
    to [Chapter 9](ch09.html "Chapter 9. Planning for IPv6") for putting all the pieces
    together and understanding the planning process. It also contains some guidelines
    on IPv6 addressing concepts.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了IPv6的基础知识和集成选项，是时候将它们付诸实践，开始规划你的过渡过程。请参考[第9章](ch09.html "第9章. IPv6规划")，了解如何将所有要素结合起来并理解规划过程。该章节还包含一些有关IPv6地址概念的指导原则。
- en: Note
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may also refer to my companion book, *Planning for IPv6* (O’Reilly), to
    get more details on planning and the design considerations that are important.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以参考我的伴侣书籍，《IPv6规划》（O'Reilly），以获取有关规划和设计考虑因素的更多细节。
- en: References
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: Here’s a list of the most important RFCs and drafts mentioned in this chapter.
    Sometimes I include additional subject-related RFCs for your personal further
    study.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章中提到的最重要的RFC和草案列表。有时我还会包含一些额外的相关RFC，供你个人进一步学习。
- en: RFCs
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RFCs
- en: RFC 2185, “Routing Aspects of IPv6 Transition,” 1997
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2185，《IPv6过渡的路由方面》，1997年
- en: RFC 2473, “Generic Packet Tunneling in IPv6 Specification,” 1998
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2473，《IPv6中通用数据包隧道规范》，1998年
- en: RFC 2529, “Transmission of IPv6 over IPv4 Domains without Explicit Tunnels,”
    1999
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2529，《在没有显式隧道的IPv4域上传输IPv6》，1999年
- en: RFC 2553, “Basic Socket Interface Extensions for IPv6,” March 1999
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2553，《IPv6的基本套接字接口扩展》，1999年3月
- en: RFC 2663, “IP Network Address Translator (NAT) Terminology and Considerations,”
    1999
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2663，《IP网络地址转换器（NAT）术语和注意事项》，1999年
- en: RFC 2784, “Generic Routing Encapsulation (GRE),” 2000
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2784，《通用路由封装（GRE）》，2000年
- en: RFC 3022, “Traditional IP Network Address Translator (Traditional NAT),” 2001
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3022, “传统 IP 网络地址转换器（传统 NAT）”，2001
- en: RFC 3053, “IPv6 Tunnel Broker,” 2001
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3053, “IPv6 隧道代理”，2001
- en: RFC 3056, “Connection of IPv6 Domains via IPv4 Clouds,” 2001
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3056, “通过 IPv4 云连接 IPv6 域”，2001
- en: RFC 3068, “An Anycast Prefix for 6to4 Relay Routers,” 2001
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3068, “用于 6to4 中继路由器的 Anycast 前缀”，2001
- en: RFC 3107, “Carrying Label Information in BGP-4,” 2001
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3107, “在 BGP-4 中携带标签信息”，2001
- en: RFC 3142, “An IPv6-to-IPv4 Transport Relay Translator,” 2001
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3142, “IPv6 到 IPv4 传输中继翻译器”，2001
- en: RFC 3162, “RADIUS and IPv6,” 2001
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3162, “RADIUS 与 IPv6”，2001
- en: RFC 3484, “Default Address Selection for Internet Protocol version 6 (IPv6),”
    2003
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3484, “IPv6（互联网协议版本 6）默认地址选择”，2003
- en: RFC 3489, “STUN—Simple Traversal of User Datagram Protocol (UDP) Through Network
    Address Translators (NATs),” 2003
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3489, “STUN—用户数据报协议（UDP）通过网络地址转换（NAT）穿越的简单方法”，2003
- en: RFC 3493, “Basic Socket Interface Extensions for IPv6,” 2003
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3493, “IPv6 基本套接字接口扩展”，2003
- en: RFC 3542, “Advanced Sockets Application Program Interface (API) for IPv6,” 2003
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3542, “IPv6 的高级套接字应用程序接口（API）”，2003
- en: RFC 3582, “Goals for IPv6 Site-Multihoming Architectures,” 2003
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3582, “IPv6 站点多宿架构的目标”，2003
- en: RFC 3715, “IPsec-Network Address Translation (NAT) Compatibility Requirements,”
    2004
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3715, “IPsec-网络地址转换（NAT）兼容性要求”，2004
- en: RFC 3901, “DNS IPv6 Transport Operational Guidelines,” 2004
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3901, “DNS IPv6 传输操作指南”，2004
- en: RFC 3964, “Security Considerations for 6to4,” 2004
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3964, “6to4 安全性考虑”，2004
- en: RFC 3971, “Secure Neighbor Discovery,” 2005
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3971, “安全邻居发现”，2005
- en: RFC 3972, “Cryptographically Generated Addresses (CGA),” 2005
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 3972, “密码生成地址（CGA）”，2005
- en: RFC 4007, “IPv6 Scoped Address Architecture,” 2005
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4007, “IPv6 范围地址架构”，2005
- en: RFC 4029, “Scenarios and Analysis for Introducing IPv6 into ISP Networks,” 2005
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4029, “将 IPv6 引入 ISP 网络的场景与分析”，2005
- en: RFC 4038, “Application Aspects of IPv6 Transition,” 2005
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4038, “IPv6 过渡的应用方面”，2005
- en: RFC 4057, “IPv6 Enterprise Network Scenarios,” 2005
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4057, “IPv6 企业网络场景”，2005
- en: RFC 4159, “Deprecation of ‘ip6.int,’” 2005
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4159, “‘ip6.int’的弃用”，2005
- en: RFC 4177, “Architectural Approaches to Multihoming for IPv6,” 2005
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4177, “IPv6 多宿的架构方法”，2005
- en: RFC 4191, “Default Router Preferences and More-Specific Routes,” 2005
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4191, “默认路由器偏好和更具体的路由”，2005
- en: RFC 4192, “Procedures for Renumbering an IPv6 Network without a Flag Day,” 2005
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4192, “无需标志日的 IPv6 网络重新编号程序”，2005
- en: RFC 4213, “Basic Transition Mechanisms for IPv6 Hosts and Routers,” 2005
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4213, “IPv6 主机和路由器的基本过渡机制”，2005
- en: RFC 4215, “Analysis on IPv6 Transition in Third Generation Partnership Project
    (3GPP) Networks,” 2005
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4215, “第三代合作伙伴计划（3GPP）网络中 IPv6 过渡的分析”，2005
- en: RFC 4218, “Threats Relating to IPv6 Multihoming Solutions,” 2005
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4218, “与 IPv6 多宿解决方案相关的威胁”，2005
- en: RFC 4219, “Things Multihoming in IPv6 (MULTI6) Developers Should Think About,”
    2005
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4219, “IPv6 中的多宿（MULTI6）开发人员应该考虑的事项”，2005
- en: RFC 4241, “A Model of IPv6/IPv4 Dual Stack Internet Access Service,” 2005
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4241, “IPv6/IPv4 双栈互联网接入服务模型”，2005
- en: RFC 4282, “The Network Access Identifier,” 2005
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4282, “网络接入标识符”，2005
- en: 'RFC 4380, “Teredo: Tunneling IPv6 over UDP through Network Address Translations
    (NATs),” 2006'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4380, “Teredo：通过网络地址转换（NAT）使用 UDP 隧道 IPv6”，2006
- en: RFC 4554, “Use of VLANs for IPv4-IPv6 Coexistence in Enterprise Networks,” 2006
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4554, “企业网络中 IPv4-IPv6 共存的 VLAN 使用”，2006
- en: RFC 4659, “BGP-MPLS IP Virtual Private Network (VPN) Extension for IPv6 VPN,”
    2006
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4659, “IPv6 VPN 的 BGP-MPLS IP 虚拟专用网络（VPN）扩展”，2006
- en: RFC 4779, “ISP IPv6 Deployment Scenarios in Broadband Access Networks,” 2007
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4779, “宽带接入网络中的 ISP IPv6 部署场景”，2007
- en: RFC 4787, “Network Address Translation (NAT) Behavioral Requirements for Unicast
    UDP,” 2007
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4787, “单播 UDP 的网络地址转换（NAT）行为要求”，2007
- en: RFC 4798, “Connecting IPv6 Islands over IPv4 MPLS Using IPv6 Provider Edge Routers
    (6PE),” 2007
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4798, “通过 IPv4 MPLS 使用 IPv6 提供者边缘路由器（6PE）连接 IPv6 域”，2007
- en: RFC 4852, “IPv6 Enterprise Network Analysis—IP Layer 3 Focus,” 2007
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4852, “IPv6 企业网络分析—IP 层 3 重点”，2007
- en: RFC 4966, “Reasons to Move the Network Address Translator—Protocol Translator
    (NAT-PT) to Historic Status,” 2007
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 4966, “将网络地址转换器—协议转换器（NAT-PT）移至历史状态的原因”，2007
- en: RFC 5157, “IPv6 Implications for Network Scanning,” 2008
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 5157, “IPv6 对网络扫描的影响”，2008
- en: RFC 5181, “IPv6 Deployment Scenarios in 802.16 Networks,” 2008
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 5181, “802.16 网络中的 IPv6 部署场景”，2008
- en: RFC 5214, “Intra-Site Automatic Tunnel Addressing Protocol (ISATAP),” 2008
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 5214, “站点内自动隧道地址协议（ISATAP）”，2008
- en: RFC 5220, “Problem Statement for Default Address Selection in Multi-Prefix Environments,”
    2008
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5220, “多前缀环境中默认地址选择的问题陈述，” 2008  '
- en: RFC 5375, “IPv6 Unicast Address Assignment Considerations,” 2008
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5375, “IPv6单播地址分配注意事项，” 2008  '
- en: RFC 5569, “IPv6 Rapid Deployment on IPv4 Infrastructures (6rd),” 2010
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5569, “IPv6在IPv4基础设施上的快速部署（6rd），” 2010  '
- en: RFC 5571, “Softwire Hub and Spoke Deployment Framework with Layer Two Tunneling
    Protocol Version 2 (L2TPv2),” 2009
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5571, “带L2隧道协议版本2（L2TPv2）的软线中心和辐射部署框架，” 2009  '
- en: RFC 5572, “IPv6 Tunnel Broker with the Tunnel Setup Protocol,” 2010
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5572, “带隧道设置协议的IPv6隧道代理，” 2010  '
- en: RFC 5902, “IAB Thoughts on IPv6 Network Address Translation,” 2010
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5902, “IAB对IPv6网络地址转换的看法，” 2010  '
- en: RFC 5969, “IPv6 Rapid Deployment on IPv4 Infrastructures (6rd)—Protocol Specification,”
    2010
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5969, “IPv6在IPv4基础设施上的快速部署（6rd）—协议规范，” 2010  '
- en: RFC 5991, “Teredo Security Updates,” 2010
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 5991, “Teredo安全更新，” 2010  '
- en: RFC 6036, “Emerging Service Provider Scenarios for IPv6 Deployment,” 2010
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6036, “IPv6部署的服务提供商新兴场景，” 2010  '
- en: RFC 6052, “IPv6 Addressing of IPv4/IPv6 Translators,” 2010
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6052, “IPv6对IPv4/IPv6转换器的地址分配，” 2010  '
- en: RFC 6081\. “Teredo Extensions,” 2011
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6081, “Teredo扩展，” 2011  '
- en: RFC 6144, “Framework for IPv4/IPv6 Translation,” 2011
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6144, “IPv4/IPv6转换框架，” 2011  '
- en: RFC 6145, “Stateless IP/ICMP Translation,” 2011
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6145, “无状态IP/ICMP转换，” 2011  '
- en: 'RFC 6146, “Stateful NAT64: Network Address and Protocol Translation from IPv6
    Clients to IPv4 Servers,” 2011'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6146, “有状态NAT64：从IPv6客户端到IPv4服务器的网络地址与协议转换，” 2011  '
- en: 'RFC 6147, “DNS64: DNS Extensions for Network Address Translation from IPv6
    Clients to IPv4 Servers,” 2011'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6147, “DNS64：从IPv6客户端到IPv4服务器的网络地址转换的DNS扩展，” 2011  '
- en: RFC 6164, “Using 127-Bit IPv6 Prefixes on Inter-Router Links,” 2011
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6164, “在路由器之间的链路上使用127位IPv6前缀，” 2011  '
- en: RFC 6177, “IPv6 Address Assignment to End Sites,” 2011
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6177, “IPv6地址分配给最终站点，” 2011  '
- en: RFC 6180, “Guidelines for Using IPv6 Transition Mechanisms during IPv6 Deployment,”
    2011
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6180, “在IPv6部署过程中使用IPv6过渡机制的指南，” 2011  '
- en: RFC 6250, “Evolution of the IP Model,” 2011
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6250, “IP模型的演进，” 2011  '
- en: RFC 6269, “Issues with IP address sharing,” 2011
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6269, “IP地址共享问题，” 2011  '
- en: RFC 6296, “IPv6-to-IPv6 Network Prefix Translation,” 2011
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6296, “IPv6到IPv6网络前缀转换，” 2011  '
- en: RFC 6302, “Logging Recommendations for Internet-Facing Servers,” 2011
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6302, “面向互联网的服务器日志记录建议，” 2011  '
- en: RFC 6333, “Dual-Stack Lite Broadband Deployments Following IPv4 Exhaustion,”
    2011
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6333, “IPv4耗尽后的双栈Lite宽带部署，” 2011  '
- en: RFC 6334, “Dynamic Host Configuration Protocol for IPv6 (DHCPv6) Option for
    Dual-Stack Lite,” 2011
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6334, “IPv6的动态主机配置协议（DHCPv6）选项，用于双栈Lite，” 2011  '
- en: RFC 6343, “Advisory Guidelines for 6to4 Deployment,” 2011
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6343, “6to4部署的建议指南，” 2011  '
- en: RFC 6434, “IPv6 Node Requirements,” 2011
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6434, “IPv6节点要求，” 2011  '
- en: RFC 6459, “IPv6 in 3rd Generation Partnership Project (3GPP) Evolved Packet
    System (EPS),” 2012
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6459, “IPv6在3GPP演进分组系统（EPS）中的应用，” 2012  '
- en: RFC 6535, “Dual-Stack Hosts Using “Bump-in-the-Host” (BIH),” 2012
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6535, “使用‘Bump-in-the-Host’（BIH）的双栈主机，” 2012  '
- en: RFC 6540, “IPv6 Support Required for All IP-Capable Nodes,” 2012
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6540, “所有支持IP的节点必须支持IPv6，” 2012  '
- en: RFC 6586, “Experiences from an IPv6-only Network,” 2012
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6586, “来自IPv6-only网络的经验，” 2012  '
- en: RFC 6619, “Scalable Operation of Address Translators with Per-Interface Bindings,”
    2012
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6619, “具有每接口绑定的地址转换器的可扩展操作，” 2012  '
- en: RFC 6791, “Stateless Source Address Mapping for ICMPv6 Packets,” 2012
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6791, “ICMPv6数据包的无状态源地址映射，” 2012  '
- en: RFC 6830, “The Locator/ID Separation Protocol (LISP),” 2013
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6830, “定位符/标识符分离协议（LISP），” 2013  '
- en: RFC 6831, “The Locator/ID Separation Protocol (LISP) for Multicast Environments,”
    2013
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6831, “定位符/标识符分离协议（LISP）在多播环境中的应用，” 2013  '
- en: RFC 6832, “Interworking between Locator/ID Separation Protocol (LISP) and Non-LISP
    Sites,” 2013
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6832, “定位符/标识符分离协议（LISP）与非LISP站点之间的互联互通，” 2013  '
- en: RFC 6833, “Locator/ID Separation Protocol (LISP) Map-Server Interface,” 2013
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6833, “定位符/标识符分离协议（LISP）映射服务器接口，” 2013  '
- en: RFC 6834, “Locator/ID Separation Protocol (LISP) Map-Versioning,” 2013
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6834, “定位符/标识符分离协议（LISP）映射版本控制，” 2013  '
- en: RFC 6835, “The Locator/ID Separation Protocol Internet Groper (LIG),” 2013
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6835, “定位符/标识符分离协议互联网探测器（LIG），” 2013  '
- en: RFC 6836, “Locator/ID Separation Protocol Alternative Logical Topology (LISP+ALT),”
    2013
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6836, “定位符/标识符分离协议替代逻辑拓扑（LISP+ALT），” 2013  '
- en: RFC 6866, “Problem Statement for Renumbering IPv6 Hosts with Static Addresses
    in Enterprise Networks,” 2013
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6866, “企业网络中带静态地址的IPv6主机重编号问题陈述，” 2013
- en: 'RFC 6877, “464XLAT: Combination of Stateful and Stateless Translation,” 2013'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RFC 6877, “464XLAT：有状态与无状态转换的结合，” 2013  '
- en: RFC 6879, “IPv6 Enterprise Network Renumbering Scenarios, Considerations, and
    Methods,” 2013
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6879, “IPv6 企业网络重新编号场景、考虑事项和方法，”2013年
- en: RFC 6883, “IPv6 Guidance for Internet Content Providers and Application Service
    Providers,” 2013
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6883, “面向互联网内容提供商和应用服务提供商的 IPv6 指南，”2013年
- en: RFC 6886, “NAT Port Mapping Protocol /NAT-PMP), 2013
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6886, “NAT 端口映射协议（NAT-PMP），”2013年
- en: RFC 6888, “Common Requirements for Carrier-Grade NATs (CGNs),” 2013
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6888, “运营商级 NAT（CGN）的常见要求，”2013年
- en: RFC 6889, “Analysis of Stateful 64 Translation,” 2013
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6889, “有状态 64 翻译分析，”2013年
- en: RFC 6908, “Deployment Considerations for Dual-Stack Lite,” 2013
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6908, “双栈 Lite 部署考虑，”2013年
- en: RFC 6911, “RADIUS Attributes for IPv6 Access Networks,” 2013
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6911, “IPv6 访问网络的 RADIUS 属性，”2013年
- en: RFC 6921, “Design Considerations for Faster-Than-Light (FTL) Communication,”
    April 1, 2013
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 6921, “超光速（FTL）通信的设计考虑，”2013年4月1日
- en: RFC 7021, “Assessing the Impact of Carrier-Grade NAT on Network Applications,”
    2013
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7021, “评估运营商级 NAT 对网络应用程序的影响，”2013年
- en: RFC 7040, “Public IPv4-over-IPv6 Access Network,” 2013
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7040, “IPv4-over-IPv6 公共接入网络，”2013年
- en: RFC 7050, “Discovery of the IPv6 Prefix Used for IPv6 Address Synthesis,” 2013
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7050, “用于 IPv6 地址合成的 IPv6 前缀发现，”2013年
- en: RFC 7051, “Analysis of Solution Proposals for Hosts to Learn NAT64 Prefix,”
    2013
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7051, “主机学习 NAT64 前缀的解决方案提案分析，”2013年
- en: RFC 7059, “A Comparison of IPv6-over-IPv4 Tunnel Mechanisms,” 2013
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7059, “IPv6-over-IPv4 隧道机制比较，”2013年
- en: RFC 7084, “Basic Requirements for IPv6 Customer Edge Routers,” 2013
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7084, “IPv6 客户端边缘路由器的基本要求，”2013年
- en: RFC 7157, “IPv6 Multihoming without Network Address Translation,” 2014
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7157, “无网络地址转换的 IPv6 多宿主（Multihoming），”2014年
- en: RFC 7225, “Discovering NAT64 IPv6 Prefixes Using the Port Control Protocol (PCP),”
    2014
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7225, “通过端口控制协议（PCP）发现 NAT64 IPv6 前缀，”2014年
- en: Drafts
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 草案
- en: Drafts can be found at [http://www.ietf.org/ID.html](http://www.ietf.org/ID.html).
    To locate the latest version of a draft, refer to [https://datatracker.ietf.org/public/pidtracker.cgi](https://datatracker.ietf.org/public/pidtracker.cgi).
    You can enter the draft name without a version number and the most current version
    will come up. If a draft does not show up, it was possibly deleted. If it was
    published as an RFC, the RFC number will be displayed. [http://tools.ietf.org/wg](http://tools.ietf.org/wg)
    is also a very useful site. More information on the process of standardization,
    RFCs, and drafts can be found in the [Appendix A](apa.html "Appendix A. RFCs").
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 草案可以在[http://www.ietf.org/ID.html](http://www.ietf.org/ID.html)找到。要查找草案的最新版本，请参考[https://datatracker.ietf.org/public/pidtracker.cgi](https://datatracker.ietf.org/public/pidtracker.cgi)。您可以输入草案名称而不带版本号，最新版本将会显示。如果草案未显示，可能已被删除。如果已发布为
    RFC，将显示 RFC 编号。[http://tools.ietf.org/wg](http://tools.ietf.org/wg)也是一个非常有用的网站。有关标准化过程、RFC
    和草案的更多信息，请参见[附录 A](apa.html "附录 A. RFCs")。
- en: 'Here’s a list of drafts I refer to in this chapter, as well as interesting
    drafts that relate to the topics in this chapter:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了我在本章中参考的草案，以及与本章主题相关的有趣草案：
- en: “Mapping of Address and Port with Encapsulation (MAP)”
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: “地址和端口的映射与封装（MAP）”
- en: '*draft-ietf-softwire-map-10*'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '*draft-ietf-softwire-map-10*'
- en: “Mapping of Address and Port using Translation (MAP-T)”
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: “使用翻译的地址和端口映射（MAP-T）”
- en: '*draft-ietf-softwire-map-t-05*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '*draft-ietf-softwire-map-t-05*'
- en: “DHCPv6 Options for Configuration of Softwire Address and Port Mapped Clients”
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: “用于配置软线地址和端口映射客户端的 DHCPv6 选项”
- en: '*draft-ietf-softwire-map-dhcp-07*'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*draft-ietf-softwire-map-dhcp-07*'
- en: '“Lightweight 4over6: An Extension to the DS-Lite Architecture”'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: “轻量级 4over6：对 DS-Lite 架构的扩展”
- en: '*draft-ietf-softwire-lw4over6-08*'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '*draft-ietf-softwire-lw4over6-08*'
- en: “IPv4 Residual Deployment via IPv6 - a Stateless Solution (4rd)”
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: “通过 IPv6 进行 IPv4 残留部署 - 一种无状态解决方案（4rd）”
- en: '*draft-ietf-softwire-4rd-08*'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '*draft-ietf-softwire-4rd-08*'
- en: “NAT64 Deployment Options and Experience”
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: “NAT64 部署选项和经验”
- en: '*draft-ietf-v6ops-nat64-experience-10*'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '*draft-ietf-v6ops-nat64-experience-10*'
